// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: buf/validate/validate.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Buf.Validate {

  /// <summary>Holder for reflection information generated from buf/validate/validate.proto</summary>
  public static partial class ValidateReflection {

    #region Descriptor
    /// <summary>File descriptor for buf/validate/validate.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ValidateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChtidWYvdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8SDGJ1Zi52YWxpZGF0ZRod",
            "YnVmL3ZhbGlkYXRlL2V4cHJlc3Npb24ucHJvdG8aH2J1Zi92YWxpZGF0ZS9w",
            "cml2L3ByaXZhdGUucHJvdG8aIGdvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9y",
            "LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aH2dvb2ds",
            "ZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8ibgoSTWVzc2FnZUNvbnN0cmFp",
            "bnRzEh8KCGRpc2FibGVkGAEgASgISABSCGRpc2FibGVkiAEBEioKA2NlbBgD",
            "IAMoCzIYLmJ1Zi52YWxpZGF0ZS5Db25zdHJhaW50UgNjZWxCCwoJX2Rpc2Fi",
            "bGVkIkAKEE9uZW9mQ29uc3RyYWludHMSHwoIcmVxdWlyZWQYASABKAhIAFII",
            "cmVxdWlyZWSIAQFCCwoJX3JlcXVpcmVkIvUJChBGaWVsZENvbnN0cmFpbnRz",
            "EioKA2NlbBgXIAMoCzIYLmJ1Zi52YWxpZGF0ZS5Db25zdHJhaW50UgNjZWwS",
            "GAoHc2tpcHBlZBgYIAEoCFIHc2tpcHBlZBIaCghyZXF1aXJlZBgZIAEoCFII",
            "cmVxdWlyZWQSIQoMaWdub3JlX2VtcHR5GBogASgIUgtpZ25vcmVFbXB0eRIw",
            "CgVmbG9hdBgBIAEoCzIYLmJ1Zi52YWxpZGF0ZS5GbG9hdFJ1bGVzSABSBWZs",
            "b2F0EjMKBmRvdWJsZRgCIAEoCzIZLmJ1Zi52YWxpZGF0ZS5Eb3VibGVSdWxl",
            "c0gAUgZkb3VibGUSMAoFaW50MzIYAyABKAsyGC5idWYudmFsaWRhdGUuSW50",
            "MzJSdWxlc0gAUgVpbnQzMhIwCgVpbnQ2NBgEIAEoCzIYLmJ1Zi52YWxpZGF0",
            "ZS5JbnQ2NFJ1bGVzSABSBWludDY0EjMKBnVpbnQzMhgFIAEoCzIZLmJ1Zi52",
            "YWxpZGF0ZS5VSW50MzJSdWxlc0gAUgZ1aW50MzISMwoGdWludDY0GAYgASgL",
            "MhkuYnVmLnZhbGlkYXRlLlVJbnQ2NFJ1bGVzSABSBnVpbnQ2NBIzCgZzaW50",
            "MzIYByABKAsyGS5idWYudmFsaWRhdGUuU0ludDMyUnVsZXNIAFIGc2ludDMy",
            "EjMKBnNpbnQ2NBgIIAEoCzIZLmJ1Zi52YWxpZGF0ZS5TSW50NjRSdWxlc0gA",
            "UgZzaW50NjQSNgoHZml4ZWQzMhgJIAEoCzIaLmJ1Zi52YWxpZGF0ZS5GaXhl",
            "ZDMyUnVsZXNIAFIHZml4ZWQzMhI2CgdmaXhlZDY0GAogASgLMhouYnVmLnZh",
            "bGlkYXRlLkZpeGVkNjRSdWxlc0gAUgdmaXhlZDY0EjkKCHNmaXhlZDMyGAsg",
            "ASgLMhsuYnVmLnZhbGlkYXRlLlNGaXhlZDMyUnVsZXNIAFIIc2ZpeGVkMzIS",
            "OQoIc2ZpeGVkNjQYDCABKAsyGy5idWYudmFsaWRhdGUuU0ZpeGVkNjRSdWxl",
            "c0gAUghzZml4ZWQ2NBItCgRib29sGA0gASgLMhcuYnVmLnZhbGlkYXRlLkJv",
            "b2xSdWxlc0gAUgRib29sEjMKBnN0cmluZxgOIAEoCzIZLmJ1Zi52YWxpZGF0",
            "ZS5TdHJpbmdSdWxlc0gAUgZzdHJpbmcSMAoFYnl0ZXMYDyABKAsyGC5idWYu",
            "dmFsaWRhdGUuQnl0ZXNSdWxlc0gAUgVieXRlcxItCgRlbnVtGBAgASgLMhcu",
            "YnVmLnZhbGlkYXRlLkVudW1SdWxlc0gAUgRlbnVtEjkKCHJlcGVhdGVkGBIg",
            "ASgLMhsuYnVmLnZhbGlkYXRlLlJlcGVhdGVkUnVsZXNIAFIIcmVwZWF0ZWQS",
            "KgoDbWFwGBMgASgLMhYuYnVmLnZhbGlkYXRlLk1hcFJ1bGVzSABSA21hcBIq",
            "CgNhbnkYFCABKAsyFi5idWYudmFsaWRhdGUuQW55UnVsZXNIAFIDYW55EjkK",
            "CGR1cmF0aW9uGBUgASgLMhsuYnVmLnZhbGlkYXRlLkR1cmF0aW9uUnVsZXNI",
            "AFIIZHVyYXRpb24SPAoJdGltZXN0YW1wGBYgASgLMhwuYnVmLnZhbGlkYXRl",
            "LlRpbWVzdGFtcFJ1bGVzSABSCXRpbWVzdGFtcEIGCgR0eXBlIvYUCgpGbG9h",
            "dFJ1bGVzEnYKBWNvbnN0GAEgASgCQluC+BhXClUKC2Zsb2F0LmNvbnN0GkZ0",
            "aGlzICE9IHJ1bGVzLmNvbnN0ID8gJ3ZhbHVlIG11c3QgZXF1YWwgJXMnLmZv",
            "cm1hdChbcnVsZXMuY29uc3RdKSA6ICcnSABSBWNvbnN0iAEBEpIBCgJsdBgC",
            "IAEoAkJ9gvgYeQp3CghmbG9hdC5sdBprIWhhcyhydWxlcy5ndGUpICYmICFo",
            "YXMocnVsZXMuZ3QpICYmIHRoaXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0",
            "IGJlIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5sdF0pIDogJydIAVIC",
            "bHSIAQESpQEKA2x0ZRgDIAEoAkKNAYL4GIgBCoUBCglmbG9hdC5sdGUaeCFo",
            "YXMocnVsZXMuZ3RlKSAmJiAhaGFzKHJ1bGVzLmd0KSAmJiB0aGlzID4gcnVs",
            "ZXMubHRlPyAndmFsdWUgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8g",
            "JXMnLmZvcm1hdChbcnVsZXMubHRlXSkgOiAnJ0gCUgNsdGWIAQESnwcKAmd0",
            "GAQgASgCQokHgvgYhAcKegoIZmxvYXQuZ3QabiFoYXMocnVsZXMubHQpICYm",
            "ICFoYXMocnVsZXMubHRlKSAmJiB0aGlzIDw9IHJ1bGVzLmd0PyAndmFsdWUg",
            "bXVzdCBiZSBncmVhdGVyIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RdKSA6",
            "ICcnCrMBCgtmbG9hdC5ndF9sdBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMu",
            "bHQgPj0gcnVsZXMuZ3QgJiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8",
            "PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBh",
            "bmQgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0p",
            "IDogJycKuwEKFWZsb2F0Lmd0X2x0X2V4Y2x1c2l2ZRqhAWhhcyhydWxlcy5s",
            "dCkgJiYgcnVsZXMubHQgPCBydWxlcy5ndCAmJiAocnVsZXMubHQgPD0gdGhp",
            "cyAmJiB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRl",
            "ciB0aGFuICVzIG9yIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndCwg",
            "cnVsZXMubHRdKSA6ICcnCsMBCgxmbG9hdC5ndF9sdGUasgFoYXMocnVsZXMu",
            "bHRlKSAmJiBydWxlcy5sdGUgPj0gcnVsZXMuZ3QgJiYgKHRoaXMgPiBydWxl",
            "cy5sdGUgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdy",
            "ZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5m",
            "b3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdGVdKSA6ICcnCssBChZmbG9hdC5n",
            "dF9sdGVfZXhjbHVzaXZlGrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRl",
            "IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBy",
            "dWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBs",
            "ZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1",
            "bGVzLmx0ZV0pIDogJydIA1ICZ3SIAQES7AcKA2d0ZRgFIAEoAkLUB4L4GM8H",
            "CogBCglmbG9hdC5ndGUaeyFoYXMocnVsZXMubHQpICYmICFoYXMocnVsZXMu",
            "bHRlKSAmJiB0aGlzIDwgcnVsZXMuZ3RlPyAndmFsdWUgbXVzdCBiZSBncmVh",
            "dGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3RlXSkg",
            "OiAnJwrCAQoMZmxvYXQuZ3RlX2x0GrEBaGFzKHJ1bGVzLmx0KSAmJiBydWxl",
            "cy5sdCA+PSBydWxlcy5ndGUgJiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhp",
            "cyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBv",
            "ciBlcXVhbCB0byAlcyBhbmQgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVz",
            "Lmd0ZSwgcnVsZXMubHRdKSA6ICcnCsoBChZmbG9hdC5ndGVfbHRfZXhjbHVz",
            "aXZlGq8BaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAm",
            "JiAocnVsZXMubHQgPD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3Zh",
            "bHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxl",
            "c3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAn",
            "JwrSAQoNZmxvYXQuZ3RlX2x0ZRrAAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVz",
            "Lmx0ZSA+PSBydWxlcy5ndGUgJiYgKHRoaXMgPiBydWxlcy5sdGUgfHwgdGhp",
            "cyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBv",
            "ciBlcXVhbCB0byAlcyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5m",
            "b3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRlXSkgOiAnJwraAQoXZmxvYXQu",
            "Z3RlX2x0ZV9leGNsdXNpdmUavgFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5s",
            "dGUgPCBydWxlcy5ndGUgJiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8",
            "IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBl",
            "cXVhbCB0byAlcyBvciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1h",
            "dChbcnVsZXMuZ3RlLCBydWxlcy5sdGVdKSA6ICcnSARSA2d0ZYgBARJ6CgJp",
            "bhgGIAMoAkJqgvgYZgpkCghmbG9hdC5pbhpYISh0aGlzIGluIGR5bihydWxl",
            "cylbJ2luJ10pID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0",
            "KFtkeW4ocnVsZXMpWydpbiddXSkgOiAnJ1ICaW4SfgoGbm90X2luGAcgAygC",
            "QmeC+BhjCmEKDGZsb2F0Lm5vdF9pbhpRdGhpcyBpbiBydWxlcy5ub3RfaW4g",
            "PyAndmFsdWUgbXVzdCBub3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtydWxl",
            "cy5ub3RfaW5dKSA6ICcnUgVub3RJbkIICgZfY29uc3RCBQoDX2x0QgYKBF9s",
            "dGVCBQoDX2d0QgYKBF9ndGUihhUKC0RvdWJsZVJ1bGVzEncKBWNvbnN0GAEg",
            "ASgBQlyC+BhYClYKDGRvdWJsZS5jb25zdBpGdGhpcyAhPSBydWxlcy5jb25z",
            "dCA/ICd2YWx1ZSBtdXN0IGVxdWFsICVzJy5mb3JtYXQoW3J1bGVzLmNvbnN0",
            "XSkgOiAnJ0gAUgVjb25zdIgBARKTAQoCbHQYAiABKAFCfoL4GHoKeAoJZG91",
            "YmxlLmx0GmshaGFzKHJ1bGVzLmd0ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYg",
            "dGhpcyA+PSBydWxlcy5sdD8gJ3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmx0XSkgOiAnJ0gBUgJsdIgBARKmAQoDbHRlGAMg",
            "ASgBQo4BgvgYiQEKhgEKCmRvdWJsZS5sdGUaeCFoYXMocnVsZXMuZ3RlKSAm",
            "JiAhaGFzKHJ1bGVzLmd0KSAmJiB0aGlzID4gcnVsZXMubHRlPyAndmFsdWUg",
            "bXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVs",
            "ZXMubHRlXSkgOiAnJ0gCUgNsdGWIAQESpAcKAmd0GAQgASgBQo4HgvgYiQcK",
            "ewoJZG91YmxlLmd0Gm4haGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0",
            "ZSkgJiYgdGhpcyA8PSBydWxlcy5ndD8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRl",
            "ciB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0XSkgOiAnJwq0AQoMZG91Ymxl",
            "Lmd0X2x0GqMBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA+PSBydWxlcy5n",
            "dCAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDw9IHJ1bGVzLmd0KT8g",
            "J3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFuZCBsZXNzIHRoYW4g",
            "JXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwq8AQoWZG91",
            "YmxlLmd0X2x0X2V4Y2x1c2l2ZRqhAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMu",
            "bHQgPCBydWxlcy5ndCAmJiAocnVsZXMubHQgPD0gdGhpcyAmJiB0aGlzIDw9",
            "IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIG9y",
            "IGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRdKSA6",
            "ICcnCsQBCg1kb3VibGUuZ3RfbHRlGrIBaGFzKHJ1bGVzLmx0ZSkgJiYgcnVs",
            "ZXMubHRlID49IHJ1bGVzLmd0ICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRo",
            "aXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "JXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxl",
            "cy5ndCwgcnVsZXMubHRlXSkgOiAnJwrMAQoXZG91YmxlLmd0X2x0ZV9leGNs",
            "dXNpdmUasAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPCBydWxlcy5n",
            "dCAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDw9IHJ1bGVzLmd0KT8g",
            "J3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIG9yIGxlc3MgdGhhbiBv",
            "ciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRlXSkg",
            "OiAnJ0gDUgJndIgBARLxBwoDZ3RlGAUgASgBQtkHgvgY1AcKiQEKCmRvdWJs",
            "ZS5ndGUaeyFoYXMocnVsZXMubHQpICYmICFoYXMocnVsZXMubHRlKSAmJiB0",
            "aGlzIDwgcnVsZXMuZ3RlPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "b3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3RlXSkgOiAnJwrDAQoN",
            "ZG91YmxlLmd0ZV9sdBqxAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0g",
            "cnVsZXMuZ3RlICYmICh0aGlzID49IHJ1bGVzLmx0IHx8IHRoaXMgPCBydWxl",
            "cy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwg",
            "dG8gJXMgYW5kIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1",
            "bGVzLmx0XSkgOiAnJwrLAQoXZG91YmxlLmd0ZV9sdF9leGNsdXNpdmUarwFo",
            "YXMocnVsZXMubHQpICYmIHJ1bGVzLmx0IDwgcnVsZXMuZ3RlICYmIChydWxl",
            "cy5sdCA8PSB0aGlzICYmIHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVz",
            "dCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgb3IgbGVzcyB0aGFu",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRdKSA6ICcnCtMBCg5k",
            "b3VibGUuZ3RlX2x0ZRrAAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA+",
            "PSBydWxlcy5ndGUgJiYgKHRoaXMgPiBydWxlcy5sdGUgfHwgdGhpcyA8IHJ1",
            "bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVh",
            "bCB0byAlcyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQo",
            "W3J1bGVzLmd0ZSwgcnVsZXMubHRlXSkgOiAnJwrbAQoYZG91YmxlLmd0ZV9s",
            "dGVfZXhjbHVzaXZlGr4BaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwg",
            "cnVsZXMuZ3RlICYmIChydWxlcy5sdGUgPCB0aGlzICYmIHRoaXMgPCBydWxl",
            "cy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwg",
            "dG8gJXMgb3IgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1",
            "bGVzLmd0ZSwgcnVsZXMubHRlXSkgOiAnJ0gEUgNndGWIAQESewoCaW4YBiAD",
            "KAFCa4L4GGcKZQoJZG91YmxlLmluGlghKHRoaXMgaW4gZHluKHJ1bGVzKVsn",
            "aW4nXSkgPyAndmFsdWUgbXVzdCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW2R5",
            "bihydWxlcylbJ2luJ11dKSA6ICcnUgJpbhJ/CgZub3RfaW4YByADKAFCaIL4",
            "GGQKYgoNZG91YmxlLm5vdF9pbhpRdGhpcyBpbiBydWxlcy5ub3RfaW4gPyAn",
            "dmFsdWUgbXVzdCBub3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtydWxlcy5u",
            "b3RfaW5dKSA6ICcnUgVub3RJbkIICgZfY29uc3RCBQoDX2x0QgYKBF9sdGVC",
            "BQoDX2d0QgYKBF9ndGUi9hQKCkludDMyUnVsZXMSdgoFY29uc3QYASABKAVC",
            "W4L4GFcKVQoLaW50MzIuY29uc3QaRnRoaXMgIT0gcnVsZXMuY29uc3QgPyAn",
            "dmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFtydWxlcy5jb25zdF0pIDog",
            "JydIAFIFY29uc3SIAQESkgEKAmx0GAIgASgFQn2C+Bh5CncKCGludDMyLmx0",
            "GmshaGFzKHJ1bGVzLmd0ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+",
            "PSBydWxlcy5sdD8gJ3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuICVzJy5mb3Jt",
            "YXQoW3J1bGVzLmx0XSkgOiAnJ0gBUgJsdIgBARKlAQoDbHRlGAMgASgFQo0B",
            "gvgYiAEKhQEKCWludDMyLmx0ZRp4IWhhcyhydWxlcy5ndGUpICYmICFoYXMo",
            "cnVsZXMuZ3QpICYmIHRoaXMgPiBydWxlcy5sdGU/ICd2YWx1ZSBtdXN0IGJl",
            "IGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5sdGVd",
            "KSA6ICcnSAJSA2x0ZYgBARKfBwoCZ3QYBCABKAVCiQeC+BiEBwp6CghpbnQz",
            "Mi5ndBpuIWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYmIHRo",
            "aXMgPD0gcnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAl",
            "cycuZm9ybWF0KFtydWxlcy5ndF0pIDogJycKswEKC2ludDMyLmd0X2x0GqMB",
            "aGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA+PSBydWxlcy5ndCAmJiAodGhp",
            "cyA+PSBydWxlcy5sdCB8fCB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11",
            "c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1h",
            "dChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwq7AQoVaW50MzIuZ3RfbHRf",
            "ZXhjbHVzaXZlGqEBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVz",
            "Lmd0ICYmIChydWxlcy5sdCA8PSB0aGlzICYmIHRoaXMgPD0gcnVsZXMuZ3Qp",
            "PyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMgb3IgbGVzcyB0aGFu",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKwwEKDGlu",
            "dDMyLmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA+PSBy",
            "dWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlzIDw9IHJ1bGVz",
            "Lmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFuZCBsZXNz",
            "IHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVz",
            "Lmx0ZV0pIDogJycKywEKFmludDMyLmd0X2x0ZV9leGNsdXNpdmUasAFoYXMo",
            "cnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPCBydWxlcy5ndCAmJiAocnVsZXMu",
            "bHRlIDwgdGhpcyAmJiB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3Qg",
            "YmUgZ3JlYXRlciB0aGFuICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAl",
            "cycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRlXSkgOiAnJ0gDUgJndIgB",
            "ARLsBwoDZ3RlGAUgASgFQtQHgvgYzwcKiAEKCWludDMyLmd0ZRp7IWhhcyhy",
            "dWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYmIHRoaXMgPCBydWxlcy5n",
            "dGU/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAl",
            "cycuZm9ybWF0KFtydWxlcy5ndGVdKSA6ICcnCsIBCgxpbnQzMi5ndGVfbHQa",
            "sQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1bGVzLmd0ZSAmJiAo",
            "dGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIGFuZCBsZXNz",
            "IHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxlcy5sdF0pIDogJycK",
            "ygEKFmludDMyLmd0ZV9sdF9leGNsdXNpdmUarwFoYXMocnVsZXMubHQpICYm",
            "IHJ1bGVzLmx0IDwgcnVsZXMuZ3RlICYmIChydWxlcy5sdCA8PSB0aGlzICYm",
            "IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRo",
            "YW4gb3IgZXF1YWwgdG8gJXMgb3IgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1",
            "bGVzLmd0ZSwgcnVsZXMubHRdKSA6ICcnCtIBCg1pbnQzMi5ndGVfbHRlGsAB",
            "aGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlID49IHJ1bGVzLmd0ZSAmJiAo",
            "dGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIGFuZCBsZXNz",
            "IHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxl",
            "cy5sdGVdKSA6ICcnCtoBChdpbnQzMi5ndGVfbHRlX2V4Y2x1c2l2ZRq+AWhh",
            "cyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8IHJ1bGVzLmd0ZSAmJiAocnVs",
            "ZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11",
            "c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhh",
            "biBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0",
            "ZV0pIDogJydIBFIDZ3RliAEBEnoKAmluGAYgAygFQmqC+BhmCmQKCGludDMy",
            "LmluGlghKHRoaXMgaW4gZHluKHJ1bGVzKVsnaW4nXSkgPyAndmFsdWUgbXVz",
            "dCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW2R5bihydWxlcylbJ2luJ11dKSA6",
            "ICcnUgJpbhJ+CgZub3RfaW4YByADKAVCZ4L4GGMKYQoMaW50MzIubm90X2lu",
            "GlF0aGlzIGluIHJ1bGVzLm5vdF9pbiA/ICd2YWx1ZSBtdXN0IG5vdCBiZSBp",
            "biBsaXN0ICVzJy5mb3JtYXQoW3J1bGVzLm5vdF9pbl0pIDogJydSBW5vdElu",
            "QggKBl9jb25zdEIFCgNfbHRCBgoEX2x0ZUIFCgNfZ3RCBgoEX2d0ZSL2FAoK",
            "SW50NjRSdWxlcxJ2CgVjb25zdBgBIAEoA0JbgvgYVwpVCgtpbnQ2NC5jb25z",
            "dBpGdGhpcyAhPSBydWxlcy5jb25zdCA/ICd2YWx1ZSBtdXN0IGVxdWFsICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmNvbnN0XSkgOiAnJ0gAUgVjb25zdIgBARKSAQoC",
            "bHQYAiABKANCfYL4GHkKdwoIaW50NjQubHQaayFoYXMocnVsZXMuZ3RlKSAm",
            "JiAhaGFzKHJ1bGVzLmd0KSAmJiB0aGlzID49IHJ1bGVzLmx0PyAndmFsdWUg",
            "bXVzdCBiZSBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMubHRdKSA6ICcn",
            "SAFSAmx0iAEBEqUBCgNsdGUYAyABKANCjQGC+BiIAQqFAQoJaW50NjQubHRl",
            "GnghaGFzKHJ1bGVzLmd0ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+",
            "IHJ1bGVzLmx0ZT8gJ3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFs",
            "IHRvICVzJy5mb3JtYXQoW3J1bGVzLmx0ZV0pIDogJydIAlIDbHRliAEBEp8H",
            "CgJndBgEIAEoA0KJB4L4GIQHCnoKCGludDY0Lmd0Gm4haGFzKHJ1bGVzLmx0",
            "KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhpcyA8PSBydWxlcy5ndD8gJ3Zh",
            "bHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0",
            "XSkgOiAnJwqzAQoLaW50NjQuZ3RfbHQaowFoYXMocnVsZXMubHQpICYmIHJ1",
            "bGVzLmx0ID49IHJ1bGVzLmd0ICYmICh0aGlzID49IHJ1bGVzLmx0IHx8IHRo",
            "aXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "JXMgYW5kIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMu",
            "bHRdKSA6ICcnCrsBChVpbnQ2NC5ndF9sdF9leGNsdXNpdmUaoQFoYXMocnVs",
            "ZXMubHQpICYmIHJ1bGVzLmx0IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9",
            "IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdy",
            "ZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMu",
            "Z3QsIHJ1bGVzLmx0XSkgOiAnJwrDAQoMaW50NjQuZ3RfbHRlGrIBaGFzKHJ1",
            "bGVzLmx0ZSkgJiYgcnVsZXMubHRlID49IHJ1bGVzLmd0ICYmICh0aGlzID4g",
            "cnVsZXMubHRlIHx8IHRoaXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBi",
            "ZSBncmVhdGVyIHRoYW4gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAl",
            "cycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRlXSkgOiAnJwrLAQoWaW50",
            "NjQuZ3RfbHRlX2V4Y2x1c2l2ZRqwAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVz",
            "Lmx0ZSA8IHJ1bGVzLmd0ICYmIChydWxlcy5sdGUgPCB0aGlzICYmIHRoaXMg",
            "PD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMg",
            "b3IgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0",
            "LCBydWxlcy5sdGVdKSA6ICcnSANSAmd0iAEBEuwHCgNndGUYBSABKANC1AeC",
            "+BjPBwqIAQoJaW50NjQuZ3RlGnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1",
            "bGVzLmx0ZSkgJiYgdGhpcyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3QgYmUg",
            "Z3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0",
            "ZV0pIDogJycKwgEKDGludDY0Lmd0ZV9sdBqxAWhhcyhydWxlcy5sdCkgJiYg",
            "cnVsZXMubHQgPj0gcnVsZXMuZ3RlICYmICh0aGlzID49IHJ1bGVzLmx0IHx8",
            "IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRo",
            "YW4gb3IgZXF1YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrKAQoWaW50NjQuZ3RlX2x0X2V4",
            "Y2x1c2l2ZRqvAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPCBydWxlcy5n",
            "dGUgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhpcyA8IHJ1bGVzLmd0ZSk/",
            "ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBv",
            "ciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxlcy5sdF0p",
            "IDogJycK0gEKDWludDY0Lmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBy",
            "dWxlcy5sdGUgPj0gcnVsZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8",
            "IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRo",
            "YW4gb3IgZXF1YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAl",
            "cycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK2gEKF2lu",
            "dDY0Lmd0ZV9sdGVfZXhjbHVzaXZlGr4BaGFzKHJ1bGVzLmx0ZSkgJiYgcnVs",
            "ZXMubHRlIDwgcnVsZXMuZ3RlICYmIChydWxlcy5sdGUgPCB0aGlzICYmIHRo",
            "aXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "b3IgZXF1YWwgdG8gJXMgb3IgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5m",
            "b3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRlXSkgOiAnJ0gEUgNndGWIAQES",
            "egoCaW4YBiADKANCaoL4GGYKZAoIaW50NjQuaW4aWCEodGhpcyBpbiBkeW4o",
            "cnVsZXMpWydpbiddKSA/ICd2YWx1ZSBtdXN0IGJlIGluIGxpc3QgJXMnLmZv",
            "cm1hdChbZHluKHJ1bGVzKVsnaW4nXV0pIDogJydSAmluEn4KBm5vdF9pbhgH",
            "IAMoA0JngvgYYwphCgxpbnQ2NC5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90",
            "X2luID8gJ3ZhbHVlIG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChb",
            "cnVsZXMubm90X2luXSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIG",
            "CgRfbHRlQgUKA19ndEIGCgRfZ3RlIoYVCgtVSW50MzJSdWxlcxJ3CgVjb25z",
            "dBgBIAEoDUJcgvgYWApWCgx1aW50MzIuY29uc3QaRnRoaXMgIT0gcnVsZXMu",
            "Y29uc3QgPyAndmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFtydWxlcy5j",
            "b25zdF0pIDogJydIAFIFY29uc3SIAQESkwEKAmx0GAIgASgNQn6C+Bh6CngK",
            "CXVpbnQzMi5sdBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3Qp",
            "ICYmIHRoaXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhh",
            "biAlcycuZm9ybWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSIAQESpgEKA2x0",
            "ZRgDIAEoDUKOAYL4GIkBCoYBCgp1aW50MzIubHRlGnghaGFzKHJ1bGVzLmd0",
            "ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0ZT8gJ3Zh",
            "bHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQo",
            "W3J1bGVzLmx0ZV0pIDogJydIAlIDbHRliAEBEqQHCgJndBgEIAEoDUKOB4L4",
            "GIkHCnsKCXVpbnQzMi5ndBpuIWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxl",
            "cy5sdGUpICYmIHRoaXMgPD0gcnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdy",
            "ZWF0ZXIgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndF0pIDogJycKtAEKDHVp",
            "bnQzMi5ndF9sdBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVs",
            "ZXMuZ3QgJiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8PSBydWxlcy5n",
            "dCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0",
            "aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKvAEK",
            "FnVpbnQzMi5ndF9sdF9leGNsdXNpdmUaoQFoYXMocnVsZXMubHQpICYmIHJ1",
            "bGVzLmx0IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhp",
            "cyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAl",
            "cyBvciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0",
            "XSkgOiAnJwrEAQoNdWludDMyLmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYm",
            "IHJ1bGVzLmx0ZSA+PSBydWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8",
            "fCB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0",
            "aGFuICVzIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChb",
            "cnVsZXMuZ3QsIHJ1bGVzLmx0ZV0pIDogJycKzAEKF3VpbnQzMi5ndF9sdGVf",
            "ZXhjbHVzaXZlGrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVs",
            "ZXMuZ3QgJiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5n",
            "dCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRo",
            "YW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0",
            "ZV0pIDogJydIA1ICZ3SIAQES8QcKA2d0ZRgFIAEoDULZB4L4GNQHCokBCgp1",
            "aW50MzIuZ3RlGnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkg",
            "JiYgdGhpcyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0",
            "aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZV0pIDogJycK",
            "wwEKDXVpbnQzMi5ndGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0",
            "ID49IHJ1bGVzLmd0ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwg",
            "cnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVx",
            "dWFsIHRvICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3Rl",
            "LCBydWxlcy5sdF0pIDogJycKywEKF3VpbnQzMi5ndGVfbHRfZXhjbHVzaXZl",
            "Gq8BaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAo",
            "cnVsZXMubHQgPD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3Mg",
            "dGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrT",
            "AQoOdWludDMyLmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5s",
            "dGUgPj0gcnVsZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMg",
            "PCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3Ig",
            "ZXF1YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9y",
            "bWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK2wEKGHVpbnQzMi5n",
            "dGVfbHRlX2V4Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0",
            "ZSA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwg",
            "cnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVx",
            "dWFsIHRvICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0",
            "KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEnsKAmlu",
            "GAYgAygNQmuC+BhnCmUKCXVpbnQzMi5pbhpYISh0aGlzIGluIGR5bihydWxl",
            "cylbJ2luJ10pID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0",
            "KFtkeW4ocnVsZXMpWydpbiddXSkgOiAnJ1ICaW4SfwoGbm90X2luGAcgAygN",
            "QmiC+BhkCmIKDXVpbnQzMi5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90X2lu",
            "ID8gJ3ZhbHVlIG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbcnVs",
            "ZXMubm90X2luXSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIGCgRf",
            "bHRlQgUKA19ndEIGCgRfZ3RlIoYVCgtVSW50NjRSdWxlcxJ3CgVjb25zdBgB",
            "IAEoBEJcgvgYWApWCgx1aW50NjQuY29uc3QaRnRoaXMgIT0gcnVsZXMuY29u",
            "c3QgPyAndmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFtydWxlcy5jb25z",
            "dF0pIDogJydIAFIFY29uc3SIAQESkwEKAmx0GAIgASgEQn6C+Bh6CngKCXVp",
            "bnQ2NC5sdBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3QpICYm",
            "IHRoaXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiAl",
            "cycuZm9ybWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSIAQESpgEKA2x0ZRgD",
            "IAEoBEKOAYL4GIkBCoYBCgp1aW50NjQubHRlGnghaGFzKHJ1bGVzLmd0ZSkg",
            "JiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0ZT8gJ3ZhbHVl",
            "IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1",
            "bGVzLmx0ZV0pIDogJydIAlIDbHRliAEBEqQHCgJndBgEIAEoBEKOB4L4GIkH",
            "CnsKCXVpbnQ2NC5ndBpuIWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5s",
            "dGUpICYmIHRoaXMgPD0gcnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0",
            "ZXIgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndF0pIDogJycKtAEKDHVpbnQ2",
            "NC5ndF9sdBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVsZXMu",
            "Z3QgJiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8PSBydWxlcy5ndCk/",
            "ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFu",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKvAEKFnVp",
            "bnQ2NC5ndF9sdF9leGNsdXNpdmUaoQFoYXMocnVsZXMubHQpICYmIHJ1bGVz",
            "Lmx0IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhpcyA8",
            "PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBv",
            "ciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkg",
            "OiAnJwrEAQoNdWludDY0Lmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYmIHJ1",
            "bGVzLmx0ZSA+PSBydWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0",
            "aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFu",
            "ICVzIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVs",
            "ZXMuZ3QsIHJ1bGVzLmx0ZV0pIDogJycKzAEKF3VpbnQ2NC5ndF9sdGVfZXhj",
            "bHVzaXZlGrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMu",
            "Z3QgJiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/",
            "ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4g",
            "b3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0ZV0p",
            "IDogJydIA1ICZ3SIAQES8QcKA2d0ZRgFIAEoBELZB4L4GNQHCokBCgp1aW50",
            "NjQuZ3RlGnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYg",
            "dGhpcyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFu",
            "IG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZV0pIDogJycKwwEK",
            "DXVpbnQ2NC5ndGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49",
            "IHJ1bGVzLmd0ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVs",
            "ZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFs",
            "IHRvICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBy",
            "dWxlcy5sdF0pIDogJycKywEKF3VpbnQ2NC5ndGVfbHRfZXhjbHVzaXZlGq8B",
            "aGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAocnVs",
            "ZXMubHQgPD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11",
            "c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhh",
            "biAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrTAQoO",
            "dWludDY0Lmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUg",
            "Pj0gcnVsZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPCBy",
            "dWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1",
            "YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0",
            "KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK2wEKGHVpbnQ2NC5ndGVf",
            "bHRlX2V4Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8",
            "IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwgcnVs",
            "ZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFs",
            "IHRvICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEnsKAmluGAYg",
            "AygEQmuC+BhnCmUKCXVpbnQ2NC5pbhpYISh0aGlzIGluIGR5bihydWxlcylb",
            "J2luJ10pID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtk",
            "eW4ocnVsZXMpWydpbiddXSkgOiAnJ1ICaW4SfwoGbm90X2luGAcgAygEQmiC",
            "+BhkCmIKDXVpbnQ2NC5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90X2luID8g",
            "J3ZhbHVlIG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbcnVsZXMu",
            "bm90X2luXSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIGCgRfbHRl",
            "QgUKA19ndEIGCgRfZ3RlIoYVCgtTSW50MzJSdWxlcxJ3CgVjb25zdBgBIAEo",
            "EUJcgvgYWApWCgxzaW50MzIuY29uc3QaRnRoaXMgIT0gcnVsZXMuY29uc3Qg",
            "PyAndmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFtydWxlcy5jb25zdF0p",
            "IDogJydIAFIFY29uc3SIAQESkwEKAmx0GAIgASgRQn6C+Bh6CngKCXNpbnQz",
            "Mi5sdBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3QpICYmIHRo",
            "aXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiAlcycu",
            "Zm9ybWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSIAQESpgEKA2x0ZRgDIAEo",
            "EUKOAYL4GIkBCoYBCgpzaW50MzIubHRlGnghaGFzKHJ1bGVzLmd0ZSkgJiYg",
            "IWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0ZT8gJ3ZhbHVlIG11",
            "c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVz",
            "Lmx0ZV0pIDogJydIAlIDbHRliAEBEqQHCgJndBgEIAEoEUKOB4L4GIkHCnsK",
            "CXNpbnQzMi5ndBpuIWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUp",
            "ICYmIHRoaXMgPD0gcnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIg",
            "dGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndF0pIDogJycKtAEKDHNpbnQzMi5n",
            "dF9sdBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVsZXMuZ3Qg",
            "JiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2",
            "YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKvAEKFnNpbnQz",
            "Mi5ndF9sdF9leGNsdXNpdmUaoQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0",
            "IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhpcyA8PSBy",
            "dWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBs",
            "ZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAn",
            "JwrEAQoNc2ludDMyLmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVz",
            "Lmx0ZSA+PSBydWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlz",
            "IDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVz",
            "IGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMu",
            "Z3QsIHJ1bGVzLmx0ZV0pIDogJycKzAEKF3NpbnQzMi5ndF9sdGVfZXhjbHVz",
            "aXZlGrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMuZ3Qg",
            "JiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/ICd2",
            "YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4gb3Ig",
            "ZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0ZV0pIDog",
            "JydIA1ICZ3SIAQES8QcKA2d0ZRgFIAEoEULZB4L4GNQHCokBCgpzaW50MzIu",
            "Z3RlGnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhp",
            "cyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9y",
            "IGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZV0pIDogJycKwwEKDXNp",
            "bnQzMi5ndGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1",
            "bGVzLmd0ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVsZXMu",
            "Z3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRv",
            "ICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxl",
            "cy5sdF0pIDogJycKywEKF3NpbnQzMi5ndGVfbHRfZXhjbHVzaXZlGq8BaGFz",
            "KHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMu",
            "bHQgPD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3Qg",
            "YmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhhbiAl",
            "cycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrTAQoOc2lu",
            "dDMyLmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPj0g",
            "cnVsZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPCBydWxl",
            "cy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwg",
            "dG8gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK2wEKGHNpbnQzMi5ndGVfbHRl",
            "X2V4Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8IHJ1",
            "bGVzLmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwgcnVsZXMu",
            "Z3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRv",
            "ICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxl",
            "cy5ndGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEnsKAmluGAYgAygR",
            "QmuC+BhnCmUKCXNpbnQzMi5pbhpYISh0aGlzIGluIGR5bihydWxlcylbJ2lu",
            "J10pID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtkeW4o",
            "cnVsZXMpWydpbiddXSkgOiAnJ1ICaW4SfwoGbm90X2luGAcgAygRQmiC+Bhk",
            "CmIKDXNpbnQzMi5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90X2luID8gJ3Zh",
            "bHVlIG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbcnVsZXMubm90",
            "X2luXSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIGCgRfbHRlQgUK",
            "A19ndEIGCgRfZ3RlIoYVCgtTSW50NjRSdWxlcxJ3CgVjb25zdBgBIAEoEkJc",
            "gvgYWApWCgxzaW50NjQuY29uc3QaRnRoaXMgIT0gcnVsZXMuY29uc3QgPyAn",
            "dmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFtydWxlcy5jb25zdF0pIDog",
            "JydIAFIFY29uc3SIAQESkwEKAmx0GAIgASgSQn6C+Bh6CngKCXNpbnQ2NC5s",
            "dBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3QpICYmIHRoaXMg",
            "Pj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiAlcycuZm9y",
            "bWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSIAQESpgEKA2x0ZRgDIAEoEkKO",
            "AYL4GIkBCoYBCgpzaW50NjQubHRlGnghaGFzKHJ1bGVzLmd0ZSkgJiYgIWhh",
            "cyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0ZT8gJ3ZhbHVlIG11c3Qg",
            "YmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmx0",
            "ZV0pIDogJydIAlIDbHRliAEBEqQHCgJndBgEIAEoEkKOB4L4GIkHCnsKCXNp",
            "bnQ2NC5ndBpuIWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYm",
            "IHRoaXMgPD0gcnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhh",
            "biAlcycuZm9ybWF0KFtydWxlcy5ndF0pIDogJycKtAEKDHNpbnQ2NC5ndF9s",
            "dBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVsZXMuZ3QgJiYg",
            "KHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1",
            "ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuICVzJy5m",
            "b3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKvAEKFnNpbnQ2NC5n",
            "dF9sdF9leGNsdXNpdmUaoQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0IDwg",
            "cnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhpcyA8PSBydWxl",
            "cy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNz",
            "IHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwrE",
            "AQoNc2ludDY0Lmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0",
            "ZSA+PSBydWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlzIDw9",
            "IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFu",
            "ZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3Qs",
            "IHJ1bGVzLmx0ZV0pIDogJycKzAEKF3NpbnQ2NC5ndF9sdGVfZXhjbHVzaXZl",
            "GrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMuZ3QgJiYg",
            "KHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1",
            "ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4gb3IgZXF1",
            "YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0ZV0pIDogJydI",
            "A1ICZ3SIAQES8QcKA2d0ZRgFIAEoEkLZB4L4GNQHCokBCgpzaW50NjQuZ3Rl",
            "GnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhpcyA8",
            "IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVx",
            "dWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZV0pIDogJycKwwEKDXNpbnQ2",
            "NC5ndGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1bGVz",
            "Lmd0ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVsZXMuZ3Rl",
            "KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVz",
            "IGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxlcy5s",
            "dF0pIDogJycKywEKF3NpbnQ2NC5ndGVfbHRfZXhjbHVzaXZlGq8BaGFzKHJ1",
            "bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHQg",
            "PD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUg",
            "Z3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhhbiAlcycu",
            "Zm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrTAQoOc2ludDY0",
            "Lmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPj0gcnVs",
            "ZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPCBydWxlcy5n",
            "dGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8g",
            "JXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxl",
            "cy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK2wEKGHNpbnQ2NC5ndGVfbHRlX2V4",
            "Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8IHJ1bGVz",
            "Lmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3Rl",
            "KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVz",
            "IG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5n",
            "dGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEnsKAmluGAYgAygSQmuC",
            "+BhnCmUKCXNpbnQ2NC5pbhpYISh0aGlzIGluIGR5bihydWxlcylbJ2luJ10p",
            "ID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtkeW4ocnVs",
            "ZXMpWydpbiddXSkgOiAnJ1ICaW4SfwoGbm90X2luGAcgAygSQmiC+BhkCmIK",
            "DXNpbnQ2NC5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90X2luID8gJ3ZhbHVl",
            "IG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbcnVsZXMubm90X2lu",
            "XSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIGCgRfbHRlQgUKA19n",
            "dEIGCgRfZ3RlIpcVCgxGaXhlZDMyUnVsZXMSeAoFY29uc3QYASABKAdCXYL4",
            "GFkKVwoNZml4ZWQzMi5jb25zdBpGdGhpcyAhPSBydWxlcy5jb25zdCA/ICd2",
            "YWx1ZSBtdXN0IGVxdWFsICVzJy5mb3JtYXQoW3J1bGVzLmNvbnN0XSkgOiAn",
            "J0gAUgVjb25zdIgBARKUAQoCbHQYAiABKAdCf4L4GHsKeQoKZml4ZWQzMi5s",
            "dBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3QpICYmIHRoaXMg",
            "Pj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiAlcycuZm9y",
            "bWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSIAQESpwEKA2x0ZRgDIAEoB0KP",
            "AYL4GIoBCocBCgtmaXhlZDMyLmx0ZRp4IWhhcyhydWxlcy5ndGUpICYmICFo",
            "YXMocnVsZXMuZ3QpICYmIHRoaXMgPiBydWxlcy5sdGU/ICd2YWx1ZSBtdXN0",
            "IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5s",
            "dGVdKSA6ICcnSAJSA2x0ZYgBARKpBwoCZ3QYBCABKAdCkweC+BiOBwp8Cgpm",
            "aXhlZDMyLmd0Gm4haGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkg",
            "JiYgdGhpcyA8PSBydWxlcy5ndD8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0",
            "aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0XSkgOiAnJwq1AQoNZml4ZWQzMi5n",
            "dF9sdBqjAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVsZXMuZ3Qg",
            "JiYgKHRoaXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2",
            "YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKvQEKF2ZpeGVk",
            "MzIuZ3RfbHRfZXhjbHVzaXZlGqEBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5s",
            "dCA8IHJ1bGVzLmd0ICYmIChydWxlcy5sdCA8PSB0aGlzICYmIHRoaXMgPD0g",
            "cnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMgb3Ig",
            "bGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDog",
            "JycKxQEKDmZpeGVkMzIuZ3RfbHRlGrIBaGFzKHJ1bGVzLmx0ZSkgJiYgcnVs",
            "ZXMubHRlID49IHJ1bGVzLmd0ICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRo",
            "aXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "JXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxl",
            "cy5ndCwgcnVsZXMubHRlXSkgOiAnJwrNAQoYZml4ZWQzMi5ndF9sdGVfZXhj",
            "bHVzaXZlGrABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMu",
            "Z3QgJiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/",
            "ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4g",
            "b3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0ZV0p",
            "IDogJydIA1ICZ3SIAQES9gcKA2d0ZRgFIAEoB0LeB4L4GNkHCooBCgtmaXhl",
            "ZDMyLmd0ZRp7IWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYm",
            "IHRoaXMgPCBydWxlcy5ndGU/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhh",
            "biBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndGVdKSA6ICcnCsQB",
            "Cg5maXhlZDMyLmd0ZV9sdBqxAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQg",
            "Pj0gcnVsZXMuZ3RlICYmICh0aGlzID49IHJ1bGVzLmx0IHx8IHRoaXMgPCBy",
            "dWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1",
            "YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndGUs",
            "IHJ1bGVzLmx0XSkgOiAnJwrMAQoYZml4ZWQzMi5ndGVfbHRfZXhjbHVzaXZl",
            "Gq8BaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAo",
            "cnVsZXMubHQgPD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3Mg",
            "dGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrU",
            "AQoPZml4ZWQzMi5ndGVfbHRlGsABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMu",
            "bHRlID49IHJ1bGVzLmd0ZSAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlz",
            "IDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9y",
            "IGVxdWFsIHRvICVzIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZv",
            "cm1hdChbcnVsZXMuZ3RlLCBydWxlcy5sdGVdKSA6ICcnCtwBChlmaXhlZDMy",
            "Lmd0ZV9sdGVfZXhjbHVzaXZlGr4BaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMu",
            "bHRlIDwgcnVsZXMuZ3RlICYmIChydWxlcy5sdGUgPCB0aGlzICYmIHRoaXMg",
            "PCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3Ig",
            "ZXF1YWwgdG8gJXMgb3IgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3Jt",
            "YXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRlXSkgOiAnJ0gEUgNndGWIAQESfAoC",
            "aW4YBiADKAdCbIL4GGgKZgoKZml4ZWQzMi5pbhpYISh0aGlzIGluIGR5bihy",
            "dWxlcylbJ2luJ10pID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9y",
            "bWF0KFtkeW4ocnVsZXMpWydpbiddXSkgOiAnJ1ICaW4SgAEKBm5vdF9pbhgH",
            "IAMoB0JpgvgYZQpjCg5maXhlZDMyLm5vdF9pbhpRdGhpcyBpbiBydWxlcy5u",
            "b3RfaW4gPyAndmFsdWUgbXVzdCBub3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0",
            "KFtydWxlcy5ub3RfaW5dKSA6ICcnUgVub3RJbkIICgZfY29uc3RCBQoDX2x0",
            "QgYKBF9sdGVCBQoDX2d0QgYKBF9ndGUilxUKDEZpeGVkNjRSdWxlcxJ4CgVj",
            "b25zdBgBIAEoBkJdgvgYWQpXCg1maXhlZDY0LmNvbnN0GkZ0aGlzICE9IHJ1",
            "bGVzLmNvbnN0ID8gJ3ZhbHVlIG11c3QgZXF1YWwgJXMnLmZvcm1hdChbcnVs",
            "ZXMuY29uc3RdKSA6ICcnSABSBWNvbnN0iAEBEpQBCgJsdBgCIAEoBkJ/gvgY",
            "ewp5CgpmaXhlZDY0Lmx0GmshaGFzKHJ1bGVzLmd0ZSkgJiYgIWhhcyhydWxl",
            "cy5ndCkgJiYgdGhpcyA+PSBydWxlcy5sdD8gJ3ZhbHVlIG11c3QgYmUgbGVz",
            "cyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmx0XSkgOiAnJ0gBUgJsdIgBARKn",
            "AQoDbHRlGAMgASgGQo8BgvgYigEKhwEKC2ZpeGVkNjQubHRlGnghaGFzKHJ1",
            "bGVzLmd0ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0",
            "ZT8gJ3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5m",
            "b3JtYXQoW3J1bGVzLmx0ZV0pIDogJydIAlIDbHRliAEBEqkHCgJndBgEIAEo",
            "BkKTB4L4GI4HCnwKCmZpeGVkNjQuZ3QabiFoYXMocnVsZXMubHQpICYmICFo",
            "YXMocnVsZXMubHRlKSAmJiB0aGlzIDw9IHJ1bGVzLmd0PyAndmFsdWUgbXVz",
            "dCBiZSBncmVhdGVyIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RdKSA6ICcn",
            "CrUBCg1maXhlZDY0Lmd0X2x0GqMBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5s",
            "dCA+PSBydWxlcy5ndCAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDw9",
            "IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFu",
            "ZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkg",
            "OiAnJwq9AQoXZml4ZWQ2NC5ndF9sdF9leGNsdXNpdmUaoQFoYXMocnVsZXMu",
            "bHQpICYmIHJ1bGVzLmx0IDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0IDw9IHRo",
            "aXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0",
            "ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3Qs",
            "IHJ1bGVzLmx0XSkgOiAnJwrFAQoOZml4ZWQ2NC5ndF9sdGUasgFoYXMocnVs",
            "ZXMubHRlKSAmJiBydWxlcy5sdGUgPj0gcnVsZXMuZ3QgJiYgKHRoaXMgPiBy",
            "dWxlcy5sdGUgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJl",
            "IGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdGVdKSA6ICcnCs0BChhmaXhl",
            "ZDY0Lmd0X2x0ZV9leGNsdXNpdmUasAFoYXMocnVsZXMubHRlKSAmJiBydWxl",
            "cy5sdGUgPCBydWxlcy5ndCAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlz",
            "IDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVz",
            "IG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5n",
            "dCwgcnVsZXMubHRlXSkgOiAnJ0gDUgJndIgBARL2BwoDZ3RlGAUgASgGQt4H",
            "gvgY2QcKigEKC2ZpeGVkNjQuZ3RlGnshaGFzKHJ1bGVzLmx0KSAmJiAhaGFz",
            "KHJ1bGVzLmx0ZSkgJiYgdGhpcyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVlIG11c3Qg",
            "YmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVz",
            "Lmd0ZV0pIDogJycKxAEKDmZpeGVkNjQuZ3RlX2x0GrEBaGFzKHJ1bGVzLmx0",
            "KSAmJiBydWxlcy5sdCA+PSBydWxlcy5ndGUgJiYgKHRoaXMgPj0gcnVsZXMu",
            "bHQgfHwgdGhpcyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0",
            "ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBhbmQgbGVzcyB0aGFuICVzJy5mb3Jt",
            "YXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRdKSA6ICcnCswBChhmaXhlZDY0Lmd0",
            "ZV9sdF9leGNsdXNpdmUarwFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0IDwg",
            "cnVsZXMuZ3RlICYmIChydWxlcy5sdCA8PSB0aGlzICYmIHRoaXMgPCBydWxl",
            "cy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwg",
            "dG8gJXMgb3IgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwgcnVs",
            "ZXMubHRdKSA6ICcnCtQBCg9maXhlZDY0Lmd0ZV9sdGUawAFoYXMocnVsZXMu",
            "bHRlKSAmJiBydWxlcy5sdGUgPj0gcnVsZXMuZ3RlICYmICh0aGlzID4gcnVs",
            "ZXMubHRlIHx8IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBiZSBn",
            "cmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiBvciBl",
            "cXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDog",
            "JycK3AEKGWZpeGVkNjQuZ3RlX2x0ZV9leGNsdXNpdmUavgFoYXMocnVsZXMu",
            "bHRlKSAmJiBydWxlcy5sdGUgPCBydWxlcy5ndGUgJiYgKHJ1bGVzLmx0ZSA8",
            "IHRoaXMgJiYgdGhpcyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdy",
            "ZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBvciBsZXNzIHRoYW4gb3IgZXF1",
            "YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxlcy5sdGVdKSA6ICcn",
            "SARSA2d0ZYgBARJ8CgJpbhgGIAMoBkJsgvgYaApmCgpmaXhlZDY0LmluGlgh",
            "KHRoaXMgaW4gZHluKHJ1bGVzKVsnaW4nXSkgPyAndmFsdWUgbXVzdCBiZSBp",
            "biBsaXN0ICVzJy5mb3JtYXQoW2R5bihydWxlcylbJ2luJ11dKSA6ICcnUgJp",
            "bhKAAQoGbm90X2luGAcgAygGQmmC+BhlCmMKDmZpeGVkNjQubm90X2luGlF0",
            "aGlzIGluIHJ1bGVzLm5vdF9pbiA/ICd2YWx1ZSBtdXN0IG5vdCBiZSBpbiBs",
            "aXN0ICVzJy5mb3JtYXQoW3J1bGVzLm5vdF9pbl0pIDogJydSBW5vdEluQggK",
            "Bl9jb25zdEIFCgNfbHRCBgoEX2x0ZUIFCgNfZ3RCBgoEX2d0ZSKoFQoNU0Zp",
            "eGVkMzJSdWxlcxJ5CgVjb25zdBgBIAEoD0JegvgYWgpYCg5zZml4ZWQzMi5j",
            "b25zdBpGdGhpcyAhPSBydWxlcy5jb25zdCA/ICd2YWx1ZSBtdXN0IGVxdWFs",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmNvbnN0XSkgOiAnJ0gAUgVjb25zdIgBARKW",
            "AQoCbHQYAiABKA9CgAGC+Bh8CnoKC3NmaXhlZDMyLmx0GmshaGFzKHJ1bGVz",
            "Lmd0ZSkgJiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+PSBydWxlcy5sdD8g",
            "J3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmx0",
            "XSkgOiAnJ0gBUgJsdIgBARKoAQoDbHRlGAMgASgPQpABgvgYiwEKiAEKDHNm",
            "aXhlZDMyLmx0ZRp4IWhhcyhydWxlcy5ndGUpICYmICFoYXMocnVsZXMuZ3Qp",
            "ICYmIHRoaXMgPiBydWxlcy5sdGU/ICd2YWx1ZSBtdXN0IGJlIGxlc3MgdGhh",
            "biBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5sdGVdKSA6ICcnSAJS",
            "A2x0ZYgBARKuBwoCZ3QYBCABKA9CmAeC+BiTBwp9CgtzZml4ZWQzMi5ndBpu",
            "IWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYmIHRoaXMgPD0g",
            "cnVsZXMuZ3Q/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcycuZm9y",
            "bWF0KFtydWxlcy5ndF0pIDogJycKtgEKDnNmaXhlZDMyLmd0X2x0GqMBaGFz",
            "KHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA+PSBydWxlcy5ndCAmJiAodGhpcyA+",
            "PSBydWxlcy5sdCB8fCB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3Qg",
            "YmUgZ3JlYXRlciB0aGFuICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChb",
            "cnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwq+AQoYc2ZpeGVkMzIuZ3RfbHRf",
            "ZXhjbHVzaXZlGqEBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVz",
            "Lmd0ICYmIChydWxlcy5sdCA8PSB0aGlzICYmIHRoaXMgPD0gcnVsZXMuZ3Qp",
            "PyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMgb3IgbGVzcyB0aGFu",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdF0pIDogJycKxgEKD3Nm",
            "aXhlZDMyLmd0X2x0ZRqyAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA+",
            "PSBydWxlcy5ndCAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlzIDw9IHJ1",
            "bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFuZCBs",
            "ZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1",
            "bGVzLmx0ZV0pIDogJycKzgEKGXNmaXhlZDMyLmd0X2x0ZV9leGNsdXNpdmUa",
            "sAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPCBydWxlcy5ndCAmJiAo",
            "cnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIG9yIGxlc3MgdGhhbiBvciBlcXVh",
            "bCB0byAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRlXSkgOiAnJ0gD",
            "UgJndIgBARL7BwoDZ3RlGAUgASgPQuMHgvgY3gcKiwEKDHNmaXhlZDMyLmd0",
            "ZRp7IWhhcyhydWxlcy5sdCkgJiYgIWhhcyhydWxlcy5sdGUpICYmIHRoaXMg",
            "PCBydWxlcy5ndGU/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBl",
            "cXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndGVdKSA6ICcnCsUBCg9zZml4",
            "ZWQzMi5ndGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1",
            "bGVzLmd0ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVsZXMu",
            "Z3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRv",
            "ICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxl",
            "cy5sdF0pIDogJycKzQEKGXNmaXhlZDMyLmd0ZV9sdF9leGNsdXNpdmUarwFo",
            "YXMocnVsZXMubHQpICYmIHJ1bGVzLmx0IDwgcnVsZXMuZ3RlICYmIChydWxl",
            "cy5sdCA8PSB0aGlzICYmIHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVz",
            "dCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgb3IgbGVzcyB0aGFu",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRdKSA6ICcnCtUBChBz",
            "Zml4ZWQzMi5ndGVfbHRlGsABaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRl",
            "ID49IHJ1bGVzLmd0ZSAmJiAodGhpcyA+IHJ1bGVzLmx0ZSB8fCB0aGlzIDwg",
            "cnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVx",
            "dWFsIHRvICVzIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1h",
            "dChbcnVsZXMuZ3RlLCBydWxlcy5sdGVdKSA6ICcnCt0BChpzZml4ZWQzMi5n",
            "dGVfbHRlX2V4Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0",
            "ZSA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwg",
            "cnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVx",
            "dWFsIHRvICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0",
            "KFtydWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEn0KAmlu",
            "GAYgAygPQm2C+BhpCmcKC3NmaXhlZDMyLmluGlghKHRoaXMgaW4gZHluKHJ1",
            "bGVzKVsnaW4nXSkgPyAndmFsdWUgbXVzdCBiZSBpbiBsaXN0ICVzJy5mb3Jt",
            "YXQoW2R5bihydWxlcylbJ2luJ11dKSA6ICcnUgJpbhKBAQoGbm90X2luGAcg",
            "AygPQmqC+BhmCmQKD3NmaXhlZDMyLm5vdF9pbhpRdGhpcyBpbiBydWxlcy5u",
            "b3RfaW4gPyAndmFsdWUgbXVzdCBub3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0",
            "KFtydWxlcy5ub3RfaW5dKSA6ICcnUgVub3RJbkIICgZfY29uc3RCBQoDX2x0",
            "QgYKBF9sdGVCBQoDX2d0QgYKBF9ndGUiqBUKDVNGaXhlZDY0UnVsZXMSeQoF",
            "Y29uc3QYASABKBBCXoL4GFoKWAoOc2ZpeGVkNjQuY29uc3QaRnRoaXMgIT0g",
            "cnVsZXMuY29uc3QgPyAndmFsdWUgbXVzdCBlcXVhbCAlcycuZm9ybWF0KFty",
            "dWxlcy5jb25zdF0pIDogJydIAFIFY29uc3SIAQESlgEKAmx0GAIgASgQQoAB",
            "gvgYfAp6CgtzZml4ZWQ2NC5sdBprIWhhcyhydWxlcy5ndGUpICYmICFoYXMo",
            "cnVsZXMuZ3QpICYmIHRoaXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBtdXN0IGJl",
            "IGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5sdF0pIDogJydIAVICbHSI",
            "AQESqAEKA2x0ZRgDIAEoEEKQAYL4GIsBCogBCgxzZml4ZWQ2NC5sdGUaeCFo",
            "YXMocnVsZXMuZ3RlKSAmJiAhaGFzKHJ1bGVzLmd0KSAmJiB0aGlzID4gcnVs",
            "ZXMubHRlPyAndmFsdWUgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8g",
            "JXMnLmZvcm1hdChbcnVsZXMubHRlXSkgOiAnJ0gCUgNsdGWIAQESrgcKAmd0",
            "GAQgASgQQpgHgvgYkwcKfQoLc2ZpeGVkNjQuZ3QabiFoYXMocnVsZXMubHQp",
            "ICYmICFoYXMocnVsZXMubHRlKSAmJiB0aGlzIDw9IHJ1bGVzLmd0PyAndmFs",
            "dWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3Rd",
            "KSA6ICcnCrYBCg5zZml4ZWQ2NC5ndF9sdBqjAWhhcyhydWxlcy5sdCkgJiYg",
            "cnVsZXMubHQgPj0gcnVsZXMuZ3QgJiYgKHRoaXMgPj0gcnVsZXMubHQgfHwg",
            "dGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhh",
            "biAlcyBhbmQgbGVzcyB0aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxl",
            "cy5sdF0pIDogJycKvgEKGHNmaXhlZDY0Lmd0X2x0X2V4Y2x1c2l2ZRqhAWhh",
            "cyhydWxlcy5sdCkgJiYgcnVsZXMubHQgPCBydWxlcy5ndCAmJiAocnVsZXMu",
            "bHQgPD0gdGhpcyAmJiB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVlIG11c3Qg",
            "YmUgZ3JlYXRlciB0aGFuICVzIG9yIGxlc3MgdGhhbiAlcycuZm9ybWF0KFty",
            "dWxlcy5ndCwgcnVsZXMubHRdKSA6ICcnCsYBCg9zZml4ZWQ2NC5ndF9sdGUa",
            "sgFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPj0gcnVsZXMuZ3QgJiYg",
            "KHRoaXMgPiBydWxlcy5sdGUgfHwgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1",
            "ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBhbmQgbGVzcyB0aGFuIG9yIGVx",
            "dWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdGVdKSA6ICcn",
            "Cs4BChlzZml4ZWQ2NC5ndF9sdGVfZXhjbHVzaXZlGrABaGFzKHJ1bGVzLmx0",
            "ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMuZ3QgJiYgKHJ1bGVzLmx0ZSA8IHRo",
            "aXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0",
            "ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1h",
            "dChbcnVsZXMuZ3QsIHJ1bGVzLmx0ZV0pIDogJydIA1ICZ3SIAQES+wcKA2d0",
            "ZRgFIAEoEELjB4L4GN4HCosBCgxzZml4ZWQ2NC5ndGUaeyFoYXMocnVsZXMu",
            "bHQpICYmICFoYXMocnVsZXMubHRlKSAmJiB0aGlzIDwgcnVsZXMuZ3RlPyAn",
            "dmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZv",
            "cm1hdChbcnVsZXMuZ3RlXSkgOiAnJwrFAQoPc2ZpeGVkNjQuZ3RlX2x0GrEB",
            "aGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA+PSBydWxlcy5ndGUgJiYgKHRo",
            "aXMgPj0gcnVsZXMubHQgfHwgdGhpcyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBt",
            "dXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBhbmQgbGVzcyB0",
            "aGFuICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMubHRdKSA6ICcnCs0B",
            "ChlzZml4ZWQ2NC5ndGVfbHRfZXhjbHVzaXZlGq8BaGFzKHJ1bGVzLmx0KSAm",
            "JiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHQgPD0gdGhpcyAm",
            "JiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0",
            "aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhhbiAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrVAQoQc2ZpeGVkNjQuZ3RlX2x0",
            "ZRrAAWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA+PSBydWxlcy5ndGUg",
            "JiYgKHRoaXMgPiBydWxlcy5sdGUgfHwgdGhpcyA8IHJ1bGVzLmd0ZSk/ICd2",
            "YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBhbmQg",
            "bGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwg",
            "cnVsZXMubHRlXSkgOiAnJwrdAQoac2ZpeGVkNjQuZ3RlX2x0ZV9leGNsdXNp",
            "dmUavgFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPCBydWxlcy5ndGUg",
            "JiYgKHJ1bGVzLmx0ZSA8IHRoaXMgJiYgdGhpcyA8IHJ1bGVzLmd0ZSk/ICd2",
            "YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcyBvciBs",
            "ZXNzIHRoYW4gb3IgZXF1YWwgdG8gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBy",
            "dWxlcy5sdGVdKSA6ICcnSARSA2d0ZYgBARJ9CgJpbhgGIAMoEEJtgvgYaQpn",
            "CgtzZml4ZWQ2NC5pbhpYISh0aGlzIGluIGR5bihydWxlcylbJ2luJ10pID8g",
            "J3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtkeW4ocnVsZXMp",
            "WydpbiddXSkgOiAnJ1ICaW4SgQEKBm5vdF9pbhgHIAMoEEJqgvgYZgpkCg9z",
            "Zml4ZWQ2NC5ub3RfaW4aUXRoaXMgaW4gcnVsZXMubm90X2luID8gJ3ZhbHVl",
            "IG11c3Qgbm90IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbcnVsZXMubm90X2lu",
            "XSkgOiAnJ1IFbm90SW5CCAoGX2NvbnN0QgUKA19sdEIGCgRfbHRlQgUKA19n",
            "dEIGCgRfZ3RlIowBCglCb29sUnVsZXMSdQoFY29uc3QYASABKAhCWoL4GFYK",
            "VAoKYm9vbC5jb25zdBpGdGhpcyAhPSBydWxlcy5jb25zdCA/ICd2YWx1ZSBt",
            "dXN0IGVxdWFsICVzJy5mb3JtYXQoW3J1bGVzLmNvbnN0XSkgOiAnJ0gAUgVj",
            "b25zdIgBAUIICgZfY29uc3Qi1B4KC1N0cmluZ1J1bGVzEnkKBWNvbnN0GAEg",
            "ASgJQl6C+BhaClgKDHN0cmluZy5jb25zdBpIdGhpcyAhPSBydWxlcy5jb25z",
            "dCA/ICd2YWx1ZSBtdXN0IGVxdWFsIGAlc2AnLmZvcm1hdChbcnVsZXMuY29u",
            "c3RdKSA6ICcnSAFSBWNvbnN0iAEBEokBCgNsZW4YEyABKARCcoL4GG4KbAoK",
            "c3RyaW5nLmxlbhpedWludCh0aGlzLnNpemUoKSkgIT0gcnVsZXMubGVuID8g",
            "J3ZhbHVlIGxlbmd0aCBtdXN0IGJlICVzIGNoYXJhY3RlcnMnLmZvcm1hdChb",
            "cnVsZXMubGVuXSkgOiAnJ0gCUgNsZW6IAQESpwEKB21pbl9sZW4YAiABKARC",
            "iAGC+BiDAQqAAQoOc3RyaW5nLm1pbl9sZW4abnVpbnQodGhpcy5zaXplKCkp",
            "IDwgcnVsZXMubWluX2xlbiA/ICd2YWx1ZSBsZW5ndGggbXVzdCBiZSBhdCBs",
            "ZWFzdCAlcyBjaGFyYWN0ZXJzJy5mb3JtYXQoW3J1bGVzLm1pbl9sZW5dKSA6",
            "ICcnSANSBm1pbkxlbogBARKlAQoHbWF4X2xlbhgDIAEoBEKGAYL4GIEBCn8K",
            "DnN0cmluZy5tYXhfbGVuGm11aW50KHRoaXMuc2l6ZSgpKSA+IHJ1bGVzLm1h",
            "eF9sZW4gPyAndmFsdWUgbGVuZ3RoIG11c3QgYmUgYXQgbW9zdCAlcyBjaGFy",
            "YWN0ZXJzJy5mb3JtYXQoW3J1bGVzLm1heF9sZW5dKSA6ICcnSARSBm1heExl",
            "bogBARKrAQoJbGVuX2J5dGVzGBQgASgEQogBgvgYgwEKgAEKEHN0cmluZy5s",
            "ZW5fYnl0ZXMabHVpbnQoYnl0ZXModGhpcykuc2l6ZSgpKSAhPSBydWxlcy5s",
            "ZW5fYnl0ZXMgPyAndmFsdWUgbGVuZ3RoIG11c3QgYmUgJXMgYnl0ZXMnLmZv",
            "cm1hdChbcnVsZXMubGVuX2J5dGVzXSkgOiAnJ0gFUghsZW5CeXRlc4gBARKz",
            "AQoJbWluX2J5dGVzGAQgASgEQpABgvgYiwEKiAEKEHN0cmluZy5taW5fYnl0",
            "ZXMadHVpbnQoYnl0ZXModGhpcykuc2l6ZSgpKSA8IHJ1bGVzLm1pbl9ieXRl",
            "cyA/ICd2YWx1ZSBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAlcyBieXRlcycu",
            "Zm9ybWF0KFtydWxlcy5taW5fYnl0ZXNdKSA6ICcnSAZSCG1pbkJ5dGVziAEB",
            "ErIBCgltYXhfYnl0ZXMYBSABKARCjwGC+BiKAQqHAQoQc3RyaW5nLm1heF9i",
            "eXRlcxpzdWludChieXRlcyh0aGlzKS5zaXplKCkpID4gcnVsZXMubWF4X2J5",
            "dGVzID8gJ3ZhbHVlIGxlbmd0aCBtdXN0IGJlIGF0IG1vc3QgJXMgYnl0ZXMn",
            "LmZvcm1hdChbcnVsZXMubWF4X2J5dGVzXSkgOiAnJ0gHUghtYXhCeXRlc4gB",
            "ARKcAQoHcGF0dGVybhgGIAEoCUJ9gvgYeQp3Cg5zdHJpbmcucGF0dGVybhpl",
            "IXRoaXMubWF0Y2hlcyhydWxlcy5wYXR0ZXJuKSA/ICd2YWx1ZSBkb2VzIG5v",
            "dCBtYXRjaCByZWdleCBwYXR0ZXJuIGAlc2AnLmZvcm1hdChbcnVsZXMucGF0",
            "dGVybl0pIDogJydICFIHcGF0dGVybogBARKSAQoGcHJlZml4GAcgASgJQnWC",
            "+BhxCm8KDXN0cmluZy5wcmVmaXgaXiF0aGlzLnN0YXJ0c1dpdGgocnVsZXMu",
            "cHJlZml4KSA/ICd2YWx1ZSBkb2VzIG5vdCBoYXZlIHByZWZpeCBgJXNgJy5m",
            "b3JtYXQoW3J1bGVzLnByZWZpeF0pIDogJydICVIGcHJlZml4iAEBEpABCgZz",
            "dWZmaXgYCCABKAlCc4L4GG8KbQoNc3RyaW5nLnN1ZmZpeBpcIXRoaXMuZW5k",
            "c1dpdGgocnVsZXMuc3VmZml4KSA/ICd2YWx1ZSBkb2VzIG5vdCBoYXZlIHN1",
            "ZmZpeCBgJXNgJy5mb3JtYXQoW3J1bGVzLnN1ZmZpeF0pIDogJydIClIGc3Vm",
            "Zml4iAEBEqABCghjb250YWlucxgJIAEoCUJ/gvgYewp5Cg9zdHJpbmcuY29u",
            "dGFpbnMaZiF0aGlzLmNvbnRhaW5zKHJ1bGVzLmNvbnRhaW5zKSA/ICd2YWx1",
            "ZSBkb2VzIG5vdCBjb250YWluIHN1YnN0cmluZyBgJXNgJy5mb3JtYXQoW3J1",
            "bGVzLmNvbnRhaW5zXSkgOiAnJ0gLUghjb250YWluc4gBARKrAQoMbm90X2Nv",
            "bnRhaW5zGBcgASgJQoIBgvgYfgp8ChNzdHJpbmcubm90X2NvbnRhaW5zGmV0",
            "aGlzLmNvbnRhaW5zKHJ1bGVzLm5vdF9jb250YWlucykgPyAndmFsdWUgY29u",
            "dGFpbnMgc3Vic3RyaW5nIGAlc2AnLmZvcm1hdChbcnVsZXMubm90X2NvbnRh",
            "aW5zXSkgOiAnJ0gMUgtub3RDb250YWluc4gBARJ7CgJpbhgKIAMoCUJrgvgY",
            "ZwplCglzdHJpbmcuaW4aWCEodGhpcyBpbiBkeW4ocnVsZXMpWydpbiddKSA/",
            "ICd2YWx1ZSBtdXN0IGJlIGluIGxpc3QgJXMnLmZvcm1hdChbZHluKHJ1bGVz",
            "KVsnaW4nXV0pIDogJydSAmluEn8KBm5vdF9pbhgLIAMoCUJogvgYZApiCg1z",
            "dHJpbmcubm90X2luGlF0aGlzIGluIHJ1bGVzLm5vdF9pbiA/ICd2YWx1ZSBt",
            "dXN0IG5vdCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW3J1bGVzLm5vdF9pbl0p",
            "IDogJydSBW5vdEluEmEKBWVtYWlsGAwgASgIQkmC+BhFCkMKDHN0cmluZy5l",
            "bWFpbBIjdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGVtYWlsIGFkZHJlc3MaDnRo",
            "aXMuaXNFbWFpbCgpSABSBWVtYWlsEmgKCGhvc3RuYW1lGA0gASgIQkqC+BhG",
            "CkQKD3N0cmluZy5ob3N0bmFtZRIedmFsdWUgbXVzdCBiZSBhIHZhbGlkIGhv",
            "c3RuYW1lGhF0aGlzLmlzSG9zdG5hbWUoKUgAUghob3N0bmFtZRJSCgJpcBgO",
            "IAEoCEJAgvgYPAo6CglzdHJpbmcuaXASIHZhbHVlIG11c3QgYmUgYSB2YWxp",
            "ZCBJUCBhZGRyZXNzGgt0aGlzLmlzSXAoKUgAUgJpcBJbCgRpcHY0GA8gASgI",
            "QkWC+BhBCj8KC3N0cmluZy5pcHY0EiJ2YWx1ZSBtdXN0IGJlIGEgdmFsaWQg",
            "SVB2NCBhZGRyZXNzGgx0aGlzLmlzSXAoNClIAFIEaXB2NBJbCgRpcHY2GBAg",
            "ASgIQkWC+BhBCj8KC3N0cmluZy5pcHY2EiJ2YWx1ZSBtdXN0IGJlIGEgdmFs",
            "aWQgSVB2NiBhZGRyZXNzGgx0aGlzLmlzSXAoNilIAFIEaXB2NhJPCgN1cmkY",
            "ESABKAhCO4L4GDcKNQoKc3RyaW5nLnVyaRIZdmFsdWUgbXVzdCBiZSBhIHZh",
            "bGlkIFVSSRoMdGhpcy5pc1VyaSgpSABSA3VyaRJdCgd1cmlfcmVmGBIgASgI",
            "QkKC+Bg+CjwKDnN0cmluZy51cmlfcmVmEhl2YWx1ZSBtdXN0IGJlIGEgdmFs",
            "aWQgVVJJGg90aGlzLmlzVXJpUmVmKClIAFIGdXJpUmVmEoMBCgdhZGRyZXNz",
            "GBUgASgIQmeC+BhjCmEKDnN0cmluZy5hZGRyZXNzEi12YWx1ZSBtdXN0IGJl",
            "IGEgdmFsaWQgaG9zdG5hbWUsIG9yIGlwIGFkZHJlc3MaIHRoaXMuaXNIb3N0",
            "bmFtZSgpIHx8IHRoaXMuaXNJcCgpSABSB2FkZHJlc3MSsQEKBHV1aWQYFiAB",
            "KAhCmgGC+BiVAQqSAQoLc3RyaW5nLnV1aWQaggEhdGhpcy5tYXRjaGVzKCde",
            "WzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17NH0t",
            "WzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17MTJ9JCcpID8gJ3ZhbHVlIG11",
            "c3QgYmUgYSB2YWxpZCBVVUlEJyA6ICcnSABSBHV1aWQSrQQKEHdlbGxfa25v",
            "d25fcmVnZXgYGCABKA4yGC5idWYudmFsaWRhdGUuS25vd25SZWdleELmA4L4",
            "GOEDCusBCiNzdHJpbmcud2VsbF9rbm93bl9yZWdleC5oZWFkZXJfbmFtZRrD",
            "AXJ1bGVzLndlbGxfa25vd25fcmVnZXggPT0gMSAmJiAhdGhpcy5tYXRjaGVz",
            "KCFoYXMocnVsZXMuc3RyaWN0KSB8fCBydWxlcy5zdHJpY3QgPydeOj9bMC05",
            "YS16QS1aISMkJSZcJyorLS5eX3x+XHg2MF0rJCcgOideW15cdTAwMDBcdTAw",
            "MEFcdTAwMERdKyQnKSA/ICd2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSFRUUCBo",
            "ZWFkZXIgbmFtZScgOiAnJwrwAQokc3RyaW5nLndlbGxfa25vd25fcmVnZXgu",
            "aGVhZGVyX3ZhbHVlGscBcnVsZXMud2VsbF9rbm93bl9yZWdleCA9PSAyICYm",
            "ICF0aGlzLm1hdGNoZXMoIWhhcyhydWxlcy5zdHJpY3QpIHx8IHJ1bGVzLnN0",
            "cmljdCA/J15bXlx1MDAwMC1cdTAwMDhcdTAwMEEtXHUwMDFGXHUwMDdGXSok",
            "JyA6J15bXlx1MDAwMFx1MDAwQVx1MDAwRF0qJCcpID8gJ3ZhbHVlIG11c3Qg",
            "YmUgYSB2YWxpZCBIVFRQIGhlYWRlciB2YWx1ZScgOiAnJ0gAUg53ZWxsS25v",
            "d25SZWdleBIbCgZzdHJpY3QYGSABKAhIDVIGc3RyaWN0iAEBQgwKCndlbGxf",
            "a25vd25CCAoGX2NvbnN0QgYKBF9sZW5CCgoIX21pbl9sZW5CCgoIX21heF9s",
            "ZW5CDAoKX2xlbl9ieXRlc0IMCgpfbWluX2J5dGVzQgwKCl9tYXhfYnl0ZXNC",
            "CgoIX3BhdHRlcm5CCQoHX3ByZWZpeEIJCgdfc3VmZml4QgsKCV9jb250YWlu",
            "c0IPCg1fbm90X2NvbnRhaW5zQgkKB19zdHJpY3Qi6Q4KCkJ5dGVzUnVsZXMS",
            "cwoFY29uc3QYASABKAxCWIL4GFQKUgoLYnl0ZXMuY29uc3QaQ3RoaXMgIT0g",
            "cnVsZXMuY29uc3QgPyAndmFsdWUgbXVzdCBiZSAleCcuZm9ybWF0KFtydWxl",
            "cy5jb25zdF0pIDogJydIAVIFY29uc3SIAQESgwEKA2xlbhgNIAEoBEJsgvgY",
            "aApmCglieXRlcy5sZW4aWXVpbnQodGhpcy5zaXplKCkpICE9IHJ1bGVzLmxl",
            "biA/ICd2YWx1ZSBsZW5ndGggbXVzdCBiZSAlcyBieXRlcycuZm9ybWF0KFty",
            "dWxlcy5sZW5dKSA6ICcnSAJSA2xlbogBARKfAQoHbWluX2xlbhgCIAEoBEKA",
            "AYL4GHwKegoNYnl0ZXMubWluX2xlbhppdWludCh0aGlzLnNpemUoKSkgPCBy",
            "dWxlcy5taW5fbGVuID8gJ3ZhbHVlIGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0",
            "ICVzIGJ5dGVzJy5mb3JtYXQoW3J1bGVzLm1pbl9sZW5dKSA6ICcnSANSBm1p",
            "bkxlbogBARKWAQoHbWF4X2xlbhgDIAEoBEJ4gvgYdApyCg1ieXRlcy5tYXhf",
            "bGVuGmF1aW50KHRoaXMuc2l6ZSgpKSA+IHJ1bGVzLm1heF9sZW4gPyAndmFs",
            "dWUgbXVzdCBiZSBhdCBtb3N0ICVzIGJ5dGVzJy5mb3JtYXQoW3J1bGVzLm1h",
            "eF9sZW5dKSA6ICcnSARSBm1heExlbogBARKgAQoHcGF0dGVybhgEIAEoCUKA",
            "AYL4GHwKegoNYnl0ZXMucGF0dGVybhppIXN0cmluZyh0aGlzKS5tYXRjaGVz",
            "KHJ1bGVzLnBhdHRlcm4pID8gJ3ZhbHVlIG11c3QgbWF0Y2ggcmVnZXggcGF0",
            "dGVybiBgJXNgJy5mb3JtYXQoW3J1bGVzLnBhdHRlcm5dKSA6ICcnSAVSB3Bh",
            "dHRlcm6IAQESjwEKBnByZWZpeBgFIAEoDEJygvgYbgpsCgxieXRlcy5wcmVm",
            "aXgaXCF0aGlzLnN0YXJ0c1dpdGgocnVsZXMucHJlZml4KSA/ICd2YWx1ZSBk",
            "b2VzIG5vdCBoYXZlIHByZWZpeCAleCcuZm9ybWF0KFtydWxlcy5wcmVmaXhd",
            "KSA6ICcnSAZSBnByZWZpeIgBARKNAQoGc3VmZml4GAYgASgMQnCC+BhsCmoK",
            "DGJ5dGVzLnN1ZmZpeBpaIXRoaXMuZW5kc1dpdGgocnVsZXMuc3VmZml4KSA/",
            "ICd2YWx1ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpeCAleCcuZm9ybWF0KFtydWxl",
            "cy5zdWZmaXhdKSA6ICcnSAdSBnN1ZmZpeIgBARKTAQoIY29udGFpbnMYByAB",
            "KAxCcoL4GG4KbAoOYnl0ZXMuY29udGFpbnMaWiF0aGlzLmNvbnRhaW5zKHJ1",
            "bGVzLmNvbnRhaW5zKSA/ICd2YWx1ZSBkb2VzIG5vdCBjb250YWluICV4Jy5m",
            "b3JtYXQoW3J1bGVzLmNvbnRhaW5zXSkgOiAnJ0gIUghjb250YWluc4gBARKc",
            "AQoCaW4YCCADKAxCiwGC+BiGAQqDAQoIYnl0ZXMuaW4ad2R5bihydWxlcylb",
            "J2luJ10uc2l6ZSgpID4gMCAmJiAhKHRoaXMgaW4gZHluKHJ1bGVzKVsnaW4n",
            "XSkgPyAndmFsdWUgbXVzdCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW2R5bihy",
            "dWxlcylbJ2luJ11dKSA6ICcnUgJpbhJ+CgZub3RfaW4YCSADKAxCZ4L4GGMK",
            "YQoMYnl0ZXMubm90X2luGlF0aGlzIGluIHJ1bGVzLm5vdF9pbiA/ICd2YWx1",
            "ZSBtdXN0IG5vdCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW3J1bGVzLm5vdF9p",
            "bl0pIDogJydSBW5vdEluEnMKAmlwGAogASgIQmGC+BhdClsKCGJ5dGVzLmlw",
            "Gk90aGlzLnNpemUoKSAhPSA0ICYmIHRoaXMuc2l6ZSgpICE9IDE2ID8gJ3Zh",
            "bHVlIG11c3QgYmUgYSB2YWxpZCBJUCBhZGRyZXNzJyA6ICcnSABSAmlwEmYK",
            "BGlwdjQYCyABKAhCUIL4GEwKSgoKYnl0ZXMuaXB2NBo8dGhpcy5zaXplKCkg",
            "IT0gNCA/ICd2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSVB2NCBhZGRyZXNzJyA6",
            "ICcnSABSBGlwdjQSZwoEaXB2NhgMIAEoCEJRgvgYTQpLCgpieXRlcy5pcHY2",
            "Gj10aGlzLnNpemUoKSAhPSAxNiA/ICd2YWx1ZSBtdXN0IGJlIGEgdmFsaWQg",
            "SVB2NiBhZGRyZXNzJyA6ICcnSABSBGlwdjZCDAoKd2VsbF9rbm93bkIICgZf",
            "Y29uc3RCBgoEX2xlbkIKCghfbWluX2xlbkIKCghfbWF4X2xlbkIKCghfcGF0",
            "dGVybkIJCgdfcHJlZml4QgkKB19zdWZmaXhCCwoJX2NvbnRhaW5zIr8DCglF",
            "bnVtUnVsZXMSdQoFY29uc3QYASABKAVCWoL4GFYKVAoKZW51bS5jb25zdBpG",
            "dGhpcyAhPSBydWxlcy5jb25zdCA/ICd2YWx1ZSBtdXN0IGVxdWFsICVzJy5m",
            "b3JtYXQoW3J1bGVzLmNvbnN0XSkgOiAnJ0gAUgVjb25zdIgBARImCgxkZWZp",
            "bmVkX29ubHkYAiABKAhIAVILZGVmaW5lZE9ubHmIAQESeQoCaW4YAyADKAVC",
            "aYL4GGUKYwoHZW51bS5pbhpYISh0aGlzIGluIGR5bihydWxlcylbJ2luJ10p",
            "ID8gJ3ZhbHVlIG11c3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtkeW4ocnVs",
            "ZXMpWydpbiddXSkgOiAnJ1ICaW4SfQoGbm90X2luGAQgAygFQmaC+BhiCmAK",
            "C2VudW0ubm90X2luGlF0aGlzIGluIHJ1bGVzLm5vdF9pbiA/ICd2YWx1ZSBt",
            "dXN0IG5vdCBiZSBpbiBsaXN0ICVzJy5mb3JtYXQoW3J1bGVzLm5vdF9pbl0p",
            "IDogJydSBW5vdEluQggKBl9jb25zdEIPCg1fZGVmaW5lZF9vbmx5ItAECg1S",
            "ZXBlYXRlZFJ1bGVzEq4BCgltaW5faXRlbXMYASABKARCiwGC+BiGAQqDAQoS",
            "cmVwZWF0ZWQubWluX2l0ZW1zGm11aW50KHRoaXMuc2l6ZSgpKSA8IHJ1bGVz",
            "Lm1pbl9pdGVtcyA/ICd2YWx1ZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJWQg",
            "aXRlbShzKScuZm9ybWF0KFtydWxlcy5taW5faXRlbXNdKSA6ICcnSABSCG1p",
            "bkl0ZW1ziAEBErIBCgltYXhfaXRlbXMYAiABKARCjwGC+BiKAQqHAQoScmVw",
            "ZWF0ZWQubWF4X2l0ZW1zGnF1aW50KHRoaXMuc2l6ZSgpKSA+IHJ1bGVzLm1h",
            "eF9pdGVtcyA/ICd2YWx1ZSBtdXN0IGNvbnRhaW4gbm8gbW9yZSB0aGFuICVz",
            "IGl0ZW0ocyknLmZvcm1hdChbcnVsZXMubWF4X2l0ZW1zXSkgOiAnJ0gBUght",
            "YXhJdGVtc4gBARJtCgZ1bmlxdWUYAyABKAhCUIL4GEwKSgoPcmVwZWF0ZWQu",
            "dW5pcXVlEihyZXBlYXRlZCB2YWx1ZSBtdXN0IGNvbnRhaW4gdW5pcXVlIGl0",
            "ZW1zGg10aGlzLnVuaXF1ZSgpSAJSBnVuaXF1ZYgBARI5CgVpdGVtcxgEIAEo",
            "CzIeLmJ1Zi52YWxpZGF0ZS5GaWVsZENvbnN0cmFpbnRzSANSBWl0ZW1ziAEB",
            "QgwKCl9taW5faXRlbXNCDAoKX21heF9pdGVtc0IJCgdfdW5pcXVlQggKBl9p",
            "dGVtcyLzAwoITWFwUnVsZXMSnwEKCW1pbl9wYWlycxgBIAEoBEJ9gvgYeQp3",
            "Cg1tYXAubWluX3BhaXJzGmZ1aW50KHRoaXMuc2l6ZSgpKSA8IHJ1bGVzLm1p",
            "bl9wYWlycyA/ICdtYXAgbXVzdCBiZSBhdCBsZWFzdCAlZCBlbnRyaWVzJy5m",
            "b3JtYXQoW3J1bGVzLm1pbl9wYWlyc10pIDogJydIAFIIbWluUGFpcnOIAQES",
            "ngEKCW1heF9wYWlycxgCIAEoBEJ8gvgYeAp2Cg1tYXAubWF4X3BhaXJzGmV1",
            "aW50KHRoaXMuc2l6ZSgpKSA+IHJ1bGVzLm1heF9wYWlycyA/ICdtYXAgbXVz",
            "dCBiZSBhdCBtb3N0ICVkIGVudHJpZXMnLmZvcm1hdChbcnVsZXMubWF4X3Bh",
            "aXJzXSkgOiAnJ0gBUghtYXhQYWlyc4gBARI3CgRrZXlzGAQgASgLMh4uYnVm",
            "LnZhbGlkYXRlLkZpZWxkQ29uc3RyYWludHNIAlIEa2V5c4gBARI7CgZ2YWx1",
            "ZXMYBSABKAsyHi5idWYudmFsaWRhdGUuRmllbGRDb25zdHJhaW50c0gDUgZ2",
            "YWx1ZXOIAQFCDAoKX21pbl9wYWlyc0IMCgpfbWF4X3BhaXJzQgcKBV9rZXlz",
            "QgkKB192YWx1ZXMiMQoIQW55UnVsZXMSDgoCaW4YAiADKAlSAmluEhUKBm5v",
            "dF9pbhgDIAMoCVIFbm90SW4i5xYKDUR1cmF0aW9uUnVsZXMSlAEKBWNvbnN0",
            "GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQl6C+BhaClgKDmR1",
            "cmF0aW9uLmNvbnN0GkZ0aGlzICE9IHJ1bGVzLmNvbnN0ID8gJ3ZhbHVlIG11",
            "c3QgZXF1YWwgJXMnLmZvcm1hdChbcnVsZXMuY29uc3RdKSA6ICcnSABSBWNv",
            "bnN0iAEBErEBCgJsdBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlv",
            "bkKAAYL4GHwKegoLZHVyYXRpb24ubHQaayFoYXMocnVsZXMuZ3RlKSAmJiAh",
            "aGFzKHJ1bGVzLmd0KSAmJiB0aGlzID49IHJ1bGVzLmx0PyAndmFsdWUgbXVz",
            "dCBiZSBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMubHRdKSA6ICcnSAFS",
            "Amx0iAEBEsMBCgNsdGUYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b25CkAGC+BiLAQqIAQoMZHVyYXRpb24ubHRlGnghaGFzKHJ1bGVzLmd0ZSkg",
            "JiYgIWhhcyhydWxlcy5ndCkgJiYgdGhpcyA+IHJ1bGVzLmx0ZT8gJ3ZhbHVl",
            "IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1",
            "bGVzLmx0ZV0pIDogJydIAlIDbHRliAEBEskHCgJndBgFIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbkKYB4L4GJMHCn0KC2R1cmF0aW9uLmd0Gm4h",
            "aGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhpcyA8PSBy",
            "dWxlcy5ndD8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzJy5mb3Jt",
            "YXQoW3J1bGVzLmd0XSkgOiAnJwq2AQoOZHVyYXRpb24uZ3RfbHQaowFoYXMo",
            "cnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1bGVzLmd0ICYmICh0aGlzID49",
            "IHJ1bGVzLmx0IHx8IHRoaXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBi",
            "ZSBncmVhdGVyIHRoYW4gJXMgYW5kIGxlc3MgdGhhbiAlcycuZm9ybWF0KFty",
            "dWxlcy5ndCwgcnVsZXMubHRdKSA6ICcnCr4BChhkdXJhdGlvbi5ndF9sdF9l",
            "eGNsdXNpdmUaoQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0IDwgcnVsZXMu",
            "Z3QgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhpcyA8PSBydWxlcy5ndCk/",
            "ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAlcyBvciBsZXNzIHRoYW4g",
            "JXMnLmZvcm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwrGAQoPZHVy",
            "YXRpb24uZ3RfbHRlGrIBaGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlID49",
            "IHJ1bGVzLmd0ICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPD0gcnVs",
            "ZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJXMgYW5kIGxl",
            "c3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVs",
            "ZXMubHRlXSkgOiAnJwrOAQoZZHVyYXRpb24uZ3RfbHRlX2V4Y2x1c2l2ZRqw",
            "AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8IHJ1bGVzLmd0ICYmIChy",
            "dWxlcy5sdGUgPCB0aGlzICYmIHRoaXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUg",
            "bXVzdCBiZSBncmVhdGVyIHRoYW4gJXMgb3IgbGVzcyB0aGFuIG9yIGVxdWFs",
            "IHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0LCBydWxlcy5sdGVdKSA6ICcnSANS",
            "Amd0iAEBEpYICgNndGUYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b25C4weC+BjeBwqLAQoMZHVyYXRpb24uZ3RlGnshaGFzKHJ1bGVzLmx0KSAm",
            "JiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhpcyA8IHJ1bGVzLmd0ZT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQo",
            "W3J1bGVzLmd0ZV0pIDogJycKxQEKD2R1cmF0aW9uLmd0ZV9sdBqxAWhhcyhy",
            "dWxlcy5sdCkgJiYgcnVsZXMubHQgPj0gcnVsZXMuZ3RlICYmICh0aGlzID49",
            "IHJ1bGVzLmx0IHx8IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUgbXVzdCBi",
            "ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgYW5kIGxlc3MgdGhhbiAl",
            "cycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrNAQoZZHVy",
            "YXRpb24uZ3RlX2x0X2V4Y2x1c2l2ZRqvAWhhcyhydWxlcy5sdCkgJiYgcnVs",
            "ZXMubHQgPCBydWxlcy5ndGUgJiYgKHJ1bGVzLmx0IDw9IHRoaXMgJiYgdGhp",
            "cyA8IHJ1bGVzLmd0ZSk/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBv",
            "ciBlcXVhbCB0byAlcyBvciBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMu",
            "Z3RlLCBydWxlcy5sdF0pIDogJycK1QEKEGR1cmF0aW9uLmd0ZV9sdGUawAFo",
            "YXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPj0gcnVsZXMuZ3RlICYmICh0",
            "aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUg",
            "bXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgYW5kIGxlc3Mg",
            "dGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVz",
            "Lmx0ZV0pIDogJycK3QEKGmR1cmF0aW9uLmd0ZV9sdGVfZXhjbHVzaXZlGr4B",
            "aGFzKHJ1bGVzLmx0ZSkgJiYgcnVsZXMubHRlIDwgcnVsZXMuZ3RlICYmIChy",
            "dWxlcy5sdGUgPCB0aGlzICYmIHRoaXMgPCBydWxlcy5ndGUpPyAndmFsdWUg",
            "bXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMgb3IgbGVzcyB0",
            "aGFuIG9yIGVxdWFsIHRvICVzJy5mb3JtYXQoW3J1bGVzLmd0ZSwgcnVsZXMu",
            "bHRlXSkgOiAnJ0gEUgNndGWIAQESmAEKAmluGAcgAygLMhkuZ29vZ2xlLnBy",
            "b3RvYnVmLkR1cmF0aW9uQm2C+BhpCmcKC2R1cmF0aW9uLmluGlghKHRoaXMg",
            "aW4gZHluKHJ1bGVzKVsnaW4nXSkgPyAndmFsdWUgbXVzdCBiZSBpbiBsaXN0",
            "ICVzJy5mb3JtYXQoW2R5bihydWxlcylbJ2luJ11dKSA6ICcnUgJpbhKcAQoG",
            "bm90X2luGAggAygLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQmqC+Bhm",
            "CmQKD2R1cmF0aW9uLm5vdF9pbhpRdGhpcyBpbiBydWxlcy5ub3RfaW4gPyAn",
            "dmFsdWUgbXVzdCBub3QgYmUgaW4gbGlzdCAlcycuZm9ybWF0KFtydWxlcy5u",
            "b3RfaW5dKSA6ICcnUgVub3RJbkIICgZfY29uc3RCBQoDX2x0QgYKBF9sdGVC",
            "BQoDX2d0QgYKBF9ndGUi+xcKDlRpbWVzdGFtcFJ1bGVzEpYBCgVjb25zdBgC",
            "IAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCX4L4GFsKWQoPdGlt",
            "ZXN0YW1wLmNvbnN0GkZ0aGlzICE9IHJ1bGVzLmNvbnN0ID8gJ3ZhbHVlIG11",
            "c3QgZXF1YWwgJXMnLmZvcm1hdChbcnVsZXMuY29uc3RdKSA6ICcnSABSBWNv",
            "bnN0iAEBErMBCgJsdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3Rh",
            "bXBCgQGC+Bh9CnsKDHRpbWVzdGFtcC5sdBprIWhhcyhydWxlcy5ndGUpICYm",
            "ICFoYXMocnVsZXMuZ3QpICYmIHRoaXMgPj0gcnVsZXMubHQ/ICd2YWx1ZSBt",
            "dXN0IGJlIGxlc3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5sdF0pIDogJydI",
            "AVICbHSIAQESxQEKA2x0ZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXBCkQGC+BiMAQqJAQoNdGltZXN0YW1wLmx0ZRp4IWhhcyhydWxlcy5n",
            "dGUpICYmICFoYXMocnVsZXMuZ3QpICYmIHRoaXMgPiBydWxlcy5sdGU/ICd2",
            "YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0",
            "KFtydWxlcy5sdGVdKSA6ICcnSAJSA2x0ZYgBARLPBwoCZ3QYBSABKAsyGi5n",
            "b29nbGUucHJvdG9idWYuVGltZXN0YW1wQp0HgvgYmAcKfgoMdGltZXN0YW1w",
            "Lmd0Gm4haGFzKHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhp",
            "cyA8PSBydWxlcy5ndD8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVz",
            "Jy5mb3JtYXQoW3J1bGVzLmd0XSkgOiAnJwq3AQoPdGltZXN0YW1wLmd0X2x0",
            "GqMBaGFzKHJ1bGVzLmx0KSAmJiBydWxlcy5sdCA+PSBydWxlcy5ndCAmJiAo",
            "dGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDw9IHJ1bGVzLmd0KT8gJ3ZhbHVl",
            "IG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIGFuZCBsZXNzIHRoYW4gJXMnLmZv",
            "cm1hdChbcnVsZXMuZ3QsIHJ1bGVzLmx0XSkgOiAnJwq/AQoZdGltZXN0YW1w",
            "Lmd0X2x0X2V4Y2x1c2l2ZRqhAWhhcyhydWxlcy5sdCkgJiYgcnVsZXMubHQg",
            "PCBydWxlcy5ndCAmJiAocnVsZXMubHQgPD0gdGhpcyAmJiB0aGlzIDw9IHJ1",
            "bGVzLmd0KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIG9yIGxl",
            "c3MgdGhhbiAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRdKSA6ICcn",
            "CscBChB0aW1lc3RhbXAuZ3RfbHRlGrIBaGFzKHJ1bGVzLmx0ZSkgJiYgcnVs",
            "ZXMubHRlID49IHJ1bGVzLmd0ICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRo",
            "aXMgPD0gcnVsZXMuZ3QpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4g",
            "JXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxl",
            "cy5ndCwgcnVsZXMubHRlXSkgOiAnJwrPAQoadGltZXN0YW1wLmd0X2x0ZV9l",
            "eGNsdXNpdmUasAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPCBydWxl",
            "cy5ndCAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDw9IHJ1bGVzLmd0",
            "KT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuICVzIG9yIGxlc3MgdGhh",
            "biBvciBlcXVhbCB0byAlcycuZm9ybWF0KFtydWxlcy5ndCwgcnVsZXMubHRl",
            "XSkgOiAnJ0gDUgJndIgBARKcCAoDZ3RlGAYgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLlRpbWVzdGFtcELoB4L4GOMHCowBCg10aW1lc3RhbXAuZ3RlGnshaGFz",
            "KHJ1bGVzLmx0KSAmJiAhaGFzKHJ1bGVzLmx0ZSkgJiYgdGhpcyA8IHJ1bGVz",
            "Lmd0ZT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRv",
            "ICVzJy5mb3JtYXQoW3J1bGVzLmd0ZV0pIDogJycKxgEKEHRpbWVzdGFtcC5n",
            "dGVfbHQasQFoYXMocnVsZXMubHQpICYmIHJ1bGVzLmx0ID49IHJ1bGVzLmd0",
            "ZSAmJiAodGhpcyA+PSBydWxlcy5sdCB8fCB0aGlzIDwgcnVsZXMuZ3RlKT8g",
            "J3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIGFu",
            "ZCBsZXNzIHRoYW4gJXMnLmZvcm1hdChbcnVsZXMuZ3RlLCBydWxlcy5sdF0p",
            "IDogJycKzgEKGnRpbWVzdGFtcC5ndGVfbHRfZXhjbHVzaXZlGq8BaGFzKHJ1",
            "bGVzLmx0KSAmJiBydWxlcy5sdCA8IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHQg",
            "PD0gdGhpcyAmJiB0aGlzIDwgcnVsZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUg",
            "Z3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzIG9yIGxlc3MgdGhhbiAlcycu",
            "Zm9ybWF0KFtydWxlcy5ndGUsIHJ1bGVzLmx0XSkgOiAnJwrWAQoRdGltZXN0",
            "YW1wLmd0ZV9sdGUawAFoYXMocnVsZXMubHRlKSAmJiBydWxlcy5sdGUgPj0g",
            "cnVsZXMuZ3RlICYmICh0aGlzID4gcnVsZXMubHRlIHx8IHRoaXMgPCBydWxl",
            "cy5ndGUpPyAndmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwg",
            "dG8gJXMgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJycK3gEKG3RpbWVzdGFtcC5ndGVf",
            "bHRlX2V4Y2x1c2l2ZRq+AWhhcyhydWxlcy5sdGUpICYmIHJ1bGVzLmx0ZSA8",
            "IHJ1bGVzLmd0ZSAmJiAocnVsZXMubHRlIDwgdGhpcyAmJiB0aGlzIDwgcnVs",
            "ZXMuZ3RlKT8gJ3ZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFs",
            "IHRvICVzIG9yIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlcycuZm9ybWF0KFty",
            "dWxlcy5ndGUsIHJ1bGVzLmx0ZV0pIDogJydIBFIDZ3RliAEBEmUKBmx0X25v",
            "dxgHIAEoCEJJgvgYRQpDChB0aW1lc3RhbXAubHRfbm93Gi90aGlzID4gbm93",
            "ID8gJ3ZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG5vdycgOiAnJ0gFUgVsdE5v",
            "d4gBARJoCgZndF9ub3cYCCABKAhCTIL4GEgKRgoQdGltZXN0YW1wLmd0X25v",
            "dxoydGhpcyA8IG5vdyA/ICd2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBu",
            "b3cnIDogJydIBlIFZ3ROb3eIAQESxgEKBndpdGhpbhgJIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbkKNAYL4GIgBCoUBChB0aW1lc3RhbXAud2l0",
            "aGluGnF0aGlzIDwgbm93LXJ1bGVzLndpdGhpbiB8fCB0aGlzID4gbm93K3J1",
            "bGVzLndpdGhpbiA/ICd2YWx1ZSBtdXN0IGJlIHdpdGhpbiAlcyBvZiBub3cn",
            "LmZvcm1hdChbcnVsZXMud2l0aGluXSkgOiAnJ0gHUgZ3aXRoaW6IAQFCCAoG",
            "X2NvbnN0QgUKA19sdEIGCgRfbHRlQgUKA19ndEIGCgRfZ3RlQgkKB19sdF9u",
            "b3dCCQoHX2d0X25vd0IJCgdfd2l0aGluKm4KCktub3duUmVnZXgSGwoXS05P",
            "V05fUkVHRVhfVU5TUEVDSUZJRUQQABIgChxLTk9XTl9SRUdFWF9IVFRQX0hF",
            "QURFUl9OQU1FEAESIQodS05PV05fUkVHRVhfSFRUUF9IRUFERVJfVkFMVUUQ",
            "AjpgCgdtZXNzYWdlEh8uZ29vZ2xlLnByb3RvYnVmLk1lc3NhZ2VPcHRpb25z",
            "GP+OAyABKAsyIC5idWYudmFsaWRhdGUuTWVzc2FnZUNvbnN0cmFpbnRzUgdt",
            "ZXNzYWdliAEBOlgKBW9uZW9mEh0uZ29vZ2xlLnByb3RvYnVmLk9uZW9mT3B0",
            "aW9ucxj/jgMgASgLMh4uYnVmLnZhbGlkYXRlLk9uZW9mQ29uc3RyYWludHNS",
            "BW9uZW9miAEBOlgKBWZpZWxkEh0uZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0",
            "aW9ucxj/jgMgASgLMh4uYnVmLnZhbGlkYXRlLkZpZWxkQ29uc3RyYWludHNS",
            "BWZpZWxkiAEBQklaR2J1Zi5idWlsZC9nZW4vZ28vYnVmYnVpbGQvcHJvdG92",
            "YWxpZGF0ZS9wcm90b2NvbGJ1ZmZlcnMvZ28vYnVmL3ZhbGlkYXRlYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Buf.Validate.ExpressionReflection.Descriptor, global::Buf.Validate.Priv.PrivateReflection.Descriptor, global::Google.Protobuf.Reflection.DescriptorReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Buf.Validate.KnownRegex), }, new pb::Extension[] { ValidateExtensions.Message, ValidateExtensions.Oneof, ValidateExtensions.Field }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.MessageConstraints), global::Buf.Validate.MessageConstraints.Parser, new[]{ "Disabled", "Cel" }, new[]{ "Disabled" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.OneofConstraints), global::Buf.Validate.OneofConstraints.Parser, new[]{ "Required" }, new[]{ "Required" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.FieldConstraints), global::Buf.Validate.FieldConstraints.Parser, new[]{ "Cel", "Skipped", "Required", "IgnoreEmpty", "Float", "Double", "Int32", "Int64", "Uint32", "Uint64", "Sint32", "Sint64", "Fixed32", "Fixed64", "Sfixed32", "Sfixed64", "Bool", "String", "Bytes", "Enum", "Repeated", "Map", "Any", "Duration", "Timestamp" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.FloatRules), global::Buf.Validate.FloatRules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.DoubleRules), global::Buf.Validate.DoubleRules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.Int32Rules), global::Buf.Validate.Int32Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.Int64Rules), global::Buf.Validate.Int64Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.UInt32Rules), global::Buf.Validate.UInt32Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.UInt64Rules), global::Buf.Validate.UInt64Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.SInt32Rules), global::Buf.Validate.SInt32Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.SInt64Rules), global::Buf.Validate.SInt64Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.Fixed32Rules), global::Buf.Validate.Fixed32Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.Fixed64Rules), global::Buf.Validate.Fixed64Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.SFixed32Rules), global::Buf.Validate.SFixed32Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.SFixed64Rules), global::Buf.Validate.SFixed64Rules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.BoolRules), global::Buf.Validate.BoolRules.Parser, new[]{ "Const" }, new[]{ "Const" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.StringRules), global::Buf.Validate.StringRules.Parser, new[]{ "Const", "Len", "MinLen", "MaxLen", "LenBytes", "MinBytes", "MaxBytes", "Pattern", "Prefix", "Suffix", "Contains", "NotContains", "In", "NotIn", "Email", "Hostname", "Ip", "Ipv4", "Ipv6", "Uri", "UriRef", "Address", "Uuid", "WellKnownRegex", "Strict" }, new[]{ "WellKnown", "Const", "Len", "MinLen", "MaxLen", "LenBytes", "MinBytes", "MaxBytes", "Pattern", "Prefix", "Suffix", "Contains", "NotContains", "Strict" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.BytesRules), global::Buf.Validate.BytesRules.Parser, new[]{ "Const", "Len", "MinLen", "MaxLen", "Pattern", "Prefix", "Suffix", "Contains", "In", "NotIn", "Ip", "Ipv4", "Ipv6" }, new[]{ "WellKnown", "Const", "Len", "MinLen", "MaxLen", "Pattern", "Prefix", "Suffix", "Contains" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.EnumRules), global::Buf.Validate.EnumRules.Parser, new[]{ "Const", "DefinedOnly", "In", "NotIn" }, new[]{ "Const", "DefinedOnly" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.RepeatedRules), global::Buf.Validate.RepeatedRules.Parser, new[]{ "MinItems", "MaxItems", "Unique", "Items" }, new[]{ "MinItems", "MaxItems", "Unique", "Items" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.MapRules), global::Buf.Validate.MapRules.Parser, new[]{ "MinPairs", "MaxPairs", "Keys", "Values" }, new[]{ "MinPairs", "MaxPairs", "Keys", "Values" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.AnyRules), global::Buf.Validate.AnyRules.Parser, new[]{ "In", "NotIn" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.DurationRules), global::Buf.Validate.DurationRules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "In", "NotIn" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Buf.Validate.TimestampRules), global::Buf.Validate.TimestampRules.Parser, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "LtNow", "GtNow", "Within" }, new[]{ "Const", "Lt", "Lte", "Gt", "Gte", "LtNow", "GtNow", "Within" }, null, null, null)
          }));
    }
    #endregion

  }
  /// <summary>Holder for extension identifiers generated from the top level of buf/validate/validate.proto</summary>
  public static partial class ValidateExtensions {
    /// <summary>
    /// Rules specify the validations to be performed on this message. By default,
    /// no validation is performed against a message.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::Buf.Validate.MessageConstraints> Message =
      new pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::Buf.Validate.MessageConstraints>(51071, pb::FieldCodec.ForMessage(408570, global::Buf.Validate.MessageConstraints.Parser));
    /// <summary>
    /// Rules specify the validations to be performed on this oneof. By default,
    /// no validation is performed against a oneof.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Buf.Validate.OneofConstraints> Oneof =
      new pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Buf.Validate.OneofConstraints>(51071, pb::FieldCodec.ForMessage(408570, global::Buf.Validate.OneofConstraints.Parser));
    /// <summary>
    /// Rules specify the validations to be performed on this field. By default,
    /// no validation is performed against a field.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Buf.Validate.FieldConstraints> Field =
      new pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Buf.Validate.FieldConstraints>(51071, pb::FieldCodec.ForMessage(408570, global::Buf.Validate.FieldConstraints.Parser));
  }

  #region Enums
  /// <summary>
  /// WellKnownRegex contain some well-known patterns.
  /// </summary>
  public enum KnownRegex {
    [pbr::OriginalName("KNOWN_REGEX_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2).
    /// </summary>
    [pbr::OriginalName("KNOWN_REGEX_HTTP_HEADER_NAME")] HttpHeaderName = 1,
    /// <summary>
    /// HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4).
    /// </summary>
    [pbr::OriginalName("KNOWN_REGEX_HTTP_HEADER_VALUE")] HttpHeaderValue = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// MessageConstraints represents validation rules that are applied to the entire message.
  /// It includes disabling options and a list of Constraint messages representing Common Expression Language (CEL) validation rules.
  /// </summary>
  public sealed partial class MessageConstraints : pb::IMessage<MessageConstraints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MessageConstraints> _parser = new pb::MessageParser<MessageConstraints>(() => new MessageConstraints());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MessageConstraints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MessageConstraints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MessageConstraints(MessageConstraints other) : this() {
      _hasBits0 = other._hasBits0;
      disabled_ = other.disabled_;
      cel_ = other.cel_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MessageConstraints Clone() {
      return new MessageConstraints(this);
    }

    /// <summary>Field number for the "disabled" field.</summary>
    public const int DisabledFieldNumber = 1;
    private readonly static bool DisabledDefaultValue = false;

    private bool disabled_;
    /// <summary>
    /// disabled is a boolean flag that, when set to true, nullifies any validation rules for this message.
    /// This includes any fields within the message that would otherwise support validation.
    ///
    /// ```proto
    /// message MyMessage {
    ///   // validation will be bypassed for this message
    ///   option (buf.validate.message).disabled = true;
    /// }
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Disabled {
      get { if ((_hasBits0 & 1) != 0) { return disabled_; } else { return DisabledDefaultValue; } }
      set {
        _hasBits0 |= 1;
        disabled_ = value;
      }
    }
    /// <summary>Gets whether the "disabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDisabled {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "disabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDisabled() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "cel" field.</summary>
    public const int CelFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Buf.Validate.Constraint> _repeated_cel_codec
        = pb::FieldCodec.ForMessage(26, global::Buf.Validate.Constraint.Parser);
    private readonly pbc::RepeatedField<global::Buf.Validate.Constraint> cel_ = new pbc::RepeatedField<global::Buf.Validate.Constraint>();
    /// <summary>
    /// cel is a repeated field of type Constraint. Each Constraint specifies a validation rule to be applied to this message.
    /// These constraints are written in Common Expression Language (CEL) syntax. For more information on
    /// CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
    ///
    ///```proto
    ///message MyMessage {
    ///  // The field `foo` must be greater than 42.
    ///  option (buf.validate.message).cel = {
    ///    id: "my_message.value",
    ///    message: "value must be greater than 42",
    ///    expression: "this.foo > 42",
    ///  };
    ///  optional int32 foo = 1;
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Buf.Validate.Constraint> Cel {
      get { return cel_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MessageConstraints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MessageConstraints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Disabled != other.Disabled) return false;
      if(!cel_.Equals(other.cel_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDisabled) hash ^= Disabled.GetHashCode();
      hash ^= cel_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDisabled) {
        output.WriteRawTag(8);
        output.WriteBool(Disabled);
      }
      cel_.WriteTo(output, _repeated_cel_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDisabled) {
        output.WriteRawTag(8);
        output.WriteBool(Disabled);
      }
      cel_.WriteTo(ref output, _repeated_cel_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDisabled) {
        size += 1 + 1;
      }
      size += cel_.CalculateSize(_repeated_cel_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MessageConstraints other) {
      if (other == null) {
        return;
      }
      if (other.HasDisabled) {
        Disabled = other.Disabled;
      }
      cel_.Add(other.cel_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Disabled = input.ReadBool();
            break;
          }
          case 26: {
            cel_.AddEntriesFrom(input, _repeated_cel_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Disabled = input.ReadBool();
            break;
          }
          case 26: {
            cel_.AddEntriesFrom(ref input, _repeated_cel_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The `OneofConstraints` message type enables you to manage constraints for
  /// oneof fields in your protobuf messages. Use the `required` constraint to ensure
  /// that exactly one of the fields within a oneof is set; validation will fail
  /// if none of the fields in the oneof are set:
  /// </summary>
  public sealed partial class OneofConstraints : pb::IMessage<OneofConstraints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OneofConstraints> _parser = new pb::MessageParser<OneofConstraints>(() => new OneofConstraints());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OneofConstraints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OneofConstraints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OneofConstraints(OneofConstraints other) : this() {
      _hasBits0 = other._hasBits0;
      required_ = other.required_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OneofConstraints Clone() {
      return new OneofConstraints(this);
    }

    /// <summary>Field number for the "required" field.</summary>
    public const int RequiredFieldNumber = 1;
    private readonly static bool RequiredDefaultValue = false;

    private bool required_;
    /// <summary>
    ///`required` is an optional boolean attribute that ensures that
    ///exactly one of the field options in a oneof is set; validation fails if
    ///no fields in the oneof are set.
    ///
    ///```proto
    ///message MyMessage {
    ///  oneof value {
    ///    // The field `a` or `b` must be set.
    ///    option [(buf.validate.oneof).required = true]
    ///    optional string a = 1;
    ///    optional string b = 2;
    ///  }
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Required {
      get { if ((_hasBits0 & 1) != 0) { return required_; } else { return RequiredDefaultValue; } }
      set {
        _hasBits0 |= 1;
        required_ = value;
      }
    }
    /// <summary>Gets whether the "required" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRequired {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "required" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRequired() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OneofConstraints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OneofConstraints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Required != other.Required) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequired) hash ^= Required.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRequired) {
        output.WriteRawTag(8);
        output.WriteBool(Required);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRequired) {
        output.WriteRawTag(8);
        output.WriteBool(Required);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRequired) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OneofConstraints other) {
      if (other == null) {
        return;
      }
      if (other.HasRequired) {
        Required = other.Required;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Required = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Required = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// FieldRules encapsulates the rules for each type of field. Depending on the
  /// field, the correct set should be used to ensure proper validations.
  /// </summary>
  public sealed partial class FieldConstraints : pb::IMessage<FieldConstraints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FieldConstraints> _parser = new pb::MessageParser<FieldConstraints>(() => new FieldConstraints());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FieldConstraints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FieldConstraints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FieldConstraints(FieldConstraints other) : this() {
      cel_ = other.cel_.Clone();
      skipped_ = other.skipped_;
      required_ = other.required_;
      ignoreEmpty_ = other.ignoreEmpty_;
      switch (other.TypeCase) {
        case TypeOneofCase.Float:
          Float = other.Float.Clone();
          break;
        case TypeOneofCase.Double:
          Double = other.Double.Clone();
          break;
        case TypeOneofCase.Int32:
          Int32 = other.Int32.Clone();
          break;
        case TypeOneofCase.Int64:
          Int64 = other.Int64.Clone();
          break;
        case TypeOneofCase.Uint32:
          Uint32 = other.Uint32.Clone();
          break;
        case TypeOneofCase.Uint64:
          Uint64 = other.Uint64.Clone();
          break;
        case TypeOneofCase.Sint32:
          Sint32 = other.Sint32.Clone();
          break;
        case TypeOneofCase.Sint64:
          Sint64 = other.Sint64.Clone();
          break;
        case TypeOneofCase.Fixed32:
          Fixed32 = other.Fixed32.Clone();
          break;
        case TypeOneofCase.Fixed64:
          Fixed64 = other.Fixed64.Clone();
          break;
        case TypeOneofCase.Sfixed32:
          Sfixed32 = other.Sfixed32.Clone();
          break;
        case TypeOneofCase.Sfixed64:
          Sfixed64 = other.Sfixed64.Clone();
          break;
        case TypeOneofCase.Bool:
          Bool = other.Bool.Clone();
          break;
        case TypeOneofCase.String:
          String = other.String.Clone();
          break;
        case TypeOneofCase.Bytes:
          Bytes = other.Bytes.Clone();
          break;
        case TypeOneofCase.Enum:
          Enum = other.Enum.Clone();
          break;
        case TypeOneofCase.Repeated:
          Repeated = other.Repeated.Clone();
          break;
        case TypeOneofCase.Map:
          Map = other.Map.Clone();
          break;
        case TypeOneofCase.Any:
          Any = other.Any.Clone();
          break;
        case TypeOneofCase.Duration:
          Duration = other.Duration.Clone();
          break;
        case TypeOneofCase.Timestamp:
          Timestamp = other.Timestamp.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FieldConstraints Clone() {
      return new FieldConstraints(this);
    }

    /// <summary>Field number for the "cel" field.</summary>
    public const int CelFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Buf.Validate.Constraint> _repeated_cel_codec
        = pb::FieldCodec.ForMessage(186, global::Buf.Validate.Constraint.Parser);
    private readonly pbc::RepeatedField<global::Buf.Validate.Constraint> cel_ = new pbc::RepeatedField<global::Buf.Validate.Constraint>();
    /// <summary>
    /// `Constraint` is a repeated field used to represent a textual expression
    /// in the Common Expression Language (CEL) syntax. For more information on
    /// CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).
    ///
    ///```proto
    ///message MyMessage {
    ///  // The field `value` must be greater than 42.
    ///  optional int32 value = 1 [(buf.validate.field).cel = {
    ///    id: "my_message.value",
    ///    message: "value must be greater than 42",
    ///    expression: "this > 42",
    ///  }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Buf.Validate.Constraint> Cel {
      get { return cel_; }
    }

    /// <summary>Field number for the "skipped" field.</summary>
    public const int SkippedFieldNumber = 24;
    private bool skipped_;
    /// <summary>
    ///`skipped` is an optional boolean attribute that specifies that the
    ///validation rules of this field should not be evaluated. If skipped is set to
    ///true, any validation rules set for the field will be ignored.
    ///
    ///```proto
    ///message MyMessage {
    ///  // The field `value` must not be set.
    ///  optional MyOtherMessage value = 1 [(buf.validate.field).skipped = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Skipped {
      get { return skipped_; }
      set {
        skipped_ = value;
      }
    }

    /// <summary>Field number for the "required" field.</summary>
    public const int RequiredFieldNumber = 25;
    private bool required_;
    /// <summary>
    ///`required` is an optional boolean attribute that specifies that
    ///this field must be set. If required is set to true, the field value must
    ///not be empty; otherwise, an error message will be generated.
    ///
    ///```proto
    ///message MyMessage {
    ///  // The field `value` must be set.
    ///  optional MyOtherMessage value = 1 [(buf.validate.field).required = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Required {
      get { return required_; }
      set {
        required_ = value;
      }
    }

    /// <summary>Field number for the "ignore_empty" field.</summary>
    public const int IgnoreEmptyFieldNumber = 26;
    private bool ignoreEmpty_;
    /// <summary>
    ///`ignore_empty` specifies that the validation rules of this field should be
    ///evaluated only if the field isn't empty. If the field is empty, no validation
    ///rules are applied.
    ///
    ///```proto
    ///message MyRepeated {
    ///  // The field `value` validation rules should be evaluated only if the field isn't empty.
    ///  repeated string value = 1 [(buf.validate.field).ignore_empty = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IgnoreEmpty {
      get { return ignoreEmpty_; }
      set {
        ignoreEmpty_ = value;
      }
    }

    /// <summary>Field number for the "float" field.</summary>
    public const int FloatFieldNumber = 1;
    /// <summary>
    /// Scalar Field Types
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.FloatRules Float {
      get { return typeCase_ == TypeOneofCase.Float ? (global::Buf.Validate.FloatRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Float;
      }
    }

    /// <summary>Field number for the "double" field.</summary>
    public const int DoubleFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.DoubleRules Double {
      get { return typeCase_ == TypeOneofCase.Double ? (global::Buf.Validate.DoubleRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Double;
      }
    }

    /// <summary>Field number for the "int32" field.</summary>
    public const int Int32FieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.Int32Rules Int32 {
      get { return typeCase_ == TypeOneofCase.Int32 ? (global::Buf.Validate.Int32Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Int32;
      }
    }

    /// <summary>Field number for the "int64" field.</summary>
    public const int Int64FieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.Int64Rules Int64 {
      get { return typeCase_ == TypeOneofCase.Int64 ? (global::Buf.Validate.Int64Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Int64;
      }
    }

    /// <summary>Field number for the "uint32" field.</summary>
    public const int Uint32FieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.UInt32Rules Uint32 {
      get { return typeCase_ == TypeOneofCase.Uint32 ? (global::Buf.Validate.UInt32Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Uint32;
      }
    }

    /// <summary>Field number for the "uint64" field.</summary>
    public const int Uint64FieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.UInt64Rules Uint64 {
      get { return typeCase_ == TypeOneofCase.Uint64 ? (global::Buf.Validate.UInt64Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Uint64;
      }
    }

    /// <summary>Field number for the "sint32" field.</summary>
    public const int Sint32FieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.SInt32Rules Sint32 {
      get { return typeCase_ == TypeOneofCase.Sint32 ? (global::Buf.Validate.SInt32Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Sint32;
      }
    }

    /// <summary>Field number for the "sint64" field.</summary>
    public const int Sint64FieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.SInt64Rules Sint64 {
      get { return typeCase_ == TypeOneofCase.Sint64 ? (global::Buf.Validate.SInt64Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Sint64;
      }
    }

    /// <summary>Field number for the "fixed32" field.</summary>
    public const int Fixed32FieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.Fixed32Rules Fixed32 {
      get { return typeCase_ == TypeOneofCase.Fixed32 ? (global::Buf.Validate.Fixed32Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Fixed32;
      }
    }

    /// <summary>Field number for the "fixed64" field.</summary>
    public const int Fixed64FieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.Fixed64Rules Fixed64 {
      get { return typeCase_ == TypeOneofCase.Fixed64 ? (global::Buf.Validate.Fixed64Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Fixed64;
      }
    }

    /// <summary>Field number for the "sfixed32" field.</summary>
    public const int Sfixed32FieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.SFixed32Rules Sfixed32 {
      get { return typeCase_ == TypeOneofCase.Sfixed32 ? (global::Buf.Validate.SFixed32Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Sfixed32;
      }
    }

    /// <summary>Field number for the "sfixed64" field.</summary>
    public const int Sfixed64FieldNumber = 12;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.SFixed64Rules Sfixed64 {
      get { return typeCase_ == TypeOneofCase.Sfixed64 ? (global::Buf.Validate.SFixed64Rules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Sfixed64;
      }
    }

    /// <summary>Field number for the "bool" field.</summary>
    public const int BoolFieldNumber = 13;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.BoolRules Bool {
      get { return typeCase_ == TypeOneofCase.Bool ? (global::Buf.Validate.BoolRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Bool;
      }
    }

    /// <summary>Field number for the "string" field.</summary>
    public const int StringFieldNumber = 14;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.StringRules String {
      get { return typeCase_ == TypeOneofCase.String ? (global::Buf.Validate.StringRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.String;
      }
    }

    /// <summary>Field number for the "bytes" field.</summary>
    public const int BytesFieldNumber = 15;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.BytesRules Bytes {
      get { return typeCase_ == TypeOneofCase.Bytes ? (global::Buf.Validate.BytesRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Bytes;
      }
    }

    /// <summary>Field number for the "enum" field.</summary>
    public const int EnumFieldNumber = 16;
    /// <summary>
    /// Complex Field Types
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.EnumRules Enum {
      get { return typeCase_ == TypeOneofCase.Enum ? (global::Buf.Validate.EnumRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Enum;
      }
    }

    /// <summary>Field number for the "repeated" field.</summary>
    public const int RepeatedFieldNumber = 18;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.RepeatedRules Repeated {
      get { return typeCase_ == TypeOneofCase.Repeated ? (global::Buf.Validate.RepeatedRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Repeated;
      }
    }

    /// <summary>Field number for the "map" field.</summary>
    public const int MapFieldNumber = 19;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.MapRules Map {
      get { return typeCase_ == TypeOneofCase.Map ? (global::Buf.Validate.MapRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Map;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 20;
    /// <summary>
    /// Well-Known Field Types
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.AnyRules Any {
      get { return typeCase_ == TypeOneofCase.Any ? (global::Buf.Validate.AnyRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Any;
      }
    }

    /// <summary>Field number for the "duration" field.</summary>
    public const int DurationFieldNumber = 21;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.DurationRules Duration {
      get { return typeCase_ == TypeOneofCase.Duration ? (global::Buf.Validate.DurationRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Duration;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 22;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.TimestampRules Timestamp {
      get { return typeCase_ == TypeOneofCase.Timestamp ? (global::Buf.Validate.TimestampRules) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Timestamp;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Float = 1,
      Double = 2,
      Int32 = 3,
      Int64 = 4,
      Uint32 = 5,
      Uint64 = 6,
      Sint32 = 7,
      Sint64 = 8,
      Fixed32 = 9,
      Fixed64 = 10,
      Sfixed32 = 11,
      Sfixed64 = 12,
      Bool = 13,
      String = 14,
      Bytes = 15,
      Enum = 16,
      Repeated = 18,
      Map = 19,
      Any = 20,
      Duration = 21,
      Timestamp = 22,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FieldConstraints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FieldConstraints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!cel_.Equals(other.cel_)) return false;
      if (Skipped != other.Skipped) return false;
      if (Required != other.Required) return false;
      if (IgnoreEmpty != other.IgnoreEmpty) return false;
      if (!object.Equals(Float, other.Float)) return false;
      if (!object.Equals(Double, other.Double)) return false;
      if (!object.Equals(Int32, other.Int32)) return false;
      if (!object.Equals(Int64, other.Int64)) return false;
      if (!object.Equals(Uint32, other.Uint32)) return false;
      if (!object.Equals(Uint64, other.Uint64)) return false;
      if (!object.Equals(Sint32, other.Sint32)) return false;
      if (!object.Equals(Sint64, other.Sint64)) return false;
      if (!object.Equals(Fixed32, other.Fixed32)) return false;
      if (!object.Equals(Fixed64, other.Fixed64)) return false;
      if (!object.Equals(Sfixed32, other.Sfixed32)) return false;
      if (!object.Equals(Sfixed64, other.Sfixed64)) return false;
      if (!object.Equals(Bool, other.Bool)) return false;
      if (!object.Equals(String, other.String)) return false;
      if (!object.Equals(Bytes, other.Bytes)) return false;
      if (!object.Equals(Enum, other.Enum)) return false;
      if (!object.Equals(Repeated, other.Repeated)) return false;
      if (!object.Equals(Map, other.Map)) return false;
      if (!object.Equals(Any, other.Any)) return false;
      if (!object.Equals(Duration, other.Duration)) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= cel_.GetHashCode();
      if (Skipped != false) hash ^= Skipped.GetHashCode();
      if (Required != false) hash ^= Required.GetHashCode();
      if (IgnoreEmpty != false) hash ^= IgnoreEmpty.GetHashCode();
      if (typeCase_ == TypeOneofCase.Float) hash ^= Float.GetHashCode();
      if (typeCase_ == TypeOneofCase.Double) hash ^= Double.GetHashCode();
      if (typeCase_ == TypeOneofCase.Int32) hash ^= Int32.GetHashCode();
      if (typeCase_ == TypeOneofCase.Int64) hash ^= Int64.GetHashCode();
      if (typeCase_ == TypeOneofCase.Uint32) hash ^= Uint32.GetHashCode();
      if (typeCase_ == TypeOneofCase.Uint64) hash ^= Uint64.GetHashCode();
      if (typeCase_ == TypeOneofCase.Sint32) hash ^= Sint32.GetHashCode();
      if (typeCase_ == TypeOneofCase.Sint64) hash ^= Sint64.GetHashCode();
      if (typeCase_ == TypeOneofCase.Fixed32) hash ^= Fixed32.GetHashCode();
      if (typeCase_ == TypeOneofCase.Fixed64) hash ^= Fixed64.GetHashCode();
      if (typeCase_ == TypeOneofCase.Sfixed32) hash ^= Sfixed32.GetHashCode();
      if (typeCase_ == TypeOneofCase.Sfixed64) hash ^= Sfixed64.GetHashCode();
      if (typeCase_ == TypeOneofCase.Bool) hash ^= Bool.GetHashCode();
      if (typeCase_ == TypeOneofCase.String) hash ^= String.GetHashCode();
      if (typeCase_ == TypeOneofCase.Bytes) hash ^= Bytes.GetHashCode();
      if (typeCase_ == TypeOneofCase.Enum) hash ^= Enum.GetHashCode();
      if (typeCase_ == TypeOneofCase.Repeated) hash ^= Repeated.GetHashCode();
      if (typeCase_ == TypeOneofCase.Map) hash ^= Map.GetHashCode();
      if (typeCase_ == TypeOneofCase.Any) hash ^= Any.GetHashCode();
      if (typeCase_ == TypeOneofCase.Duration) hash ^= Duration.GetHashCode();
      if (typeCase_ == TypeOneofCase.Timestamp) hash ^= Timestamp.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (typeCase_ == TypeOneofCase.Float) {
        output.WriteRawTag(10);
        output.WriteMessage(Float);
      }
      if (typeCase_ == TypeOneofCase.Double) {
        output.WriteRawTag(18);
        output.WriteMessage(Double);
      }
      if (typeCase_ == TypeOneofCase.Int32) {
        output.WriteRawTag(26);
        output.WriteMessage(Int32);
      }
      if (typeCase_ == TypeOneofCase.Int64) {
        output.WriteRawTag(34);
        output.WriteMessage(Int64);
      }
      if (typeCase_ == TypeOneofCase.Uint32) {
        output.WriteRawTag(42);
        output.WriteMessage(Uint32);
      }
      if (typeCase_ == TypeOneofCase.Uint64) {
        output.WriteRawTag(50);
        output.WriteMessage(Uint64);
      }
      if (typeCase_ == TypeOneofCase.Sint32) {
        output.WriteRawTag(58);
        output.WriteMessage(Sint32);
      }
      if (typeCase_ == TypeOneofCase.Sint64) {
        output.WriteRawTag(66);
        output.WriteMessage(Sint64);
      }
      if (typeCase_ == TypeOneofCase.Fixed32) {
        output.WriteRawTag(74);
        output.WriteMessage(Fixed32);
      }
      if (typeCase_ == TypeOneofCase.Fixed64) {
        output.WriteRawTag(82);
        output.WriteMessage(Fixed64);
      }
      if (typeCase_ == TypeOneofCase.Sfixed32) {
        output.WriteRawTag(90);
        output.WriteMessage(Sfixed32);
      }
      if (typeCase_ == TypeOneofCase.Sfixed64) {
        output.WriteRawTag(98);
        output.WriteMessage(Sfixed64);
      }
      if (typeCase_ == TypeOneofCase.Bool) {
        output.WriteRawTag(106);
        output.WriteMessage(Bool);
      }
      if (typeCase_ == TypeOneofCase.String) {
        output.WriteRawTag(114);
        output.WriteMessage(String);
      }
      if (typeCase_ == TypeOneofCase.Bytes) {
        output.WriteRawTag(122);
        output.WriteMessage(Bytes);
      }
      if (typeCase_ == TypeOneofCase.Enum) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(Enum);
      }
      if (typeCase_ == TypeOneofCase.Repeated) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Repeated);
      }
      if (typeCase_ == TypeOneofCase.Map) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(Map);
      }
      if (typeCase_ == TypeOneofCase.Any) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Any);
      }
      if (typeCase_ == TypeOneofCase.Duration) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Duration);
      }
      if (typeCase_ == TypeOneofCase.Timestamp) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(Timestamp);
      }
      cel_.WriteTo(output, _repeated_cel_codec);
      if (Skipped != false) {
        output.WriteRawTag(192, 1);
        output.WriteBool(Skipped);
      }
      if (Required != false) {
        output.WriteRawTag(200, 1);
        output.WriteBool(Required);
      }
      if (IgnoreEmpty != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(IgnoreEmpty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (typeCase_ == TypeOneofCase.Float) {
        output.WriteRawTag(10);
        output.WriteMessage(Float);
      }
      if (typeCase_ == TypeOneofCase.Double) {
        output.WriteRawTag(18);
        output.WriteMessage(Double);
      }
      if (typeCase_ == TypeOneofCase.Int32) {
        output.WriteRawTag(26);
        output.WriteMessage(Int32);
      }
      if (typeCase_ == TypeOneofCase.Int64) {
        output.WriteRawTag(34);
        output.WriteMessage(Int64);
      }
      if (typeCase_ == TypeOneofCase.Uint32) {
        output.WriteRawTag(42);
        output.WriteMessage(Uint32);
      }
      if (typeCase_ == TypeOneofCase.Uint64) {
        output.WriteRawTag(50);
        output.WriteMessage(Uint64);
      }
      if (typeCase_ == TypeOneofCase.Sint32) {
        output.WriteRawTag(58);
        output.WriteMessage(Sint32);
      }
      if (typeCase_ == TypeOneofCase.Sint64) {
        output.WriteRawTag(66);
        output.WriteMessage(Sint64);
      }
      if (typeCase_ == TypeOneofCase.Fixed32) {
        output.WriteRawTag(74);
        output.WriteMessage(Fixed32);
      }
      if (typeCase_ == TypeOneofCase.Fixed64) {
        output.WriteRawTag(82);
        output.WriteMessage(Fixed64);
      }
      if (typeCase_ == TypeOneofCase.Sfixed32) {
        output.WriteRawTag(90);
        output.WriteMessage(Sfixed32);
      }
      if (typeCase_ == TypeOneofCase.Sfixed64) {
        output.WriteRawTag(98);
        output.WriteMessage(Sfixed64);
      }
      if (typeCase_ == TypeOneofCase.Bool) {
        output.WriteRawTag(106);
        output.WriteMessage(Bool);
      }
      if (typeCase_ == TypeOneofCase.String) {
        output.WriteRawTag(114);
        output.WriteMessage(String);
      }
      if (typeCase_ == TypeOneofCase.Bytes) {
        output.WriteRawTag(122);
        output.WriteMessage(Bytes);
      }
      if (typeCase_ == TypeOneofCase.Enum) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(Enum);
      }
      if (typeCase_ == TypeOneofCase.Repeated) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Repeated);
      }
      if (typeCase_ == TypeOneofCase.Map) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(Map);
      }
      if (typeCase_ == TypeOneofCase.Any) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Any);
      }
      if (typeCase_ == TypeOneofCase.Duration) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Duration);
      }
      if (typeCase_ == TypeOneofCase.Timestamp) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(Timestamp);
      }
      cel_.WriteTo(ref output, _repeated_cel_codec);
      if (Skipped != false) {
        output.WriteRawTag(192, 1);
        output.WriteBool(Skipped);
      }
      if (Required != false) {
        output.WriteRawTag(200, 1);
        output.WriteBool(Required);
      }
      if (IgnoreEmpty != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(IgnoreEmpty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += cel_.CalculateSize(_repeated_cel_codec);
      if (Skipped != false) {
        size += 2 + 1;
      }
      if (Required != false) {
        size += 2 + 1;
      }
      if (IgnoreEmpty != false) {
        size += 2 + 1;
      }
      if (typeCase_ == TypeOneofCase.Float) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Float);
      }
      if (typeCase_ == TypeOneofCase.Double) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Double);
      }
      if (typeCase_ == TypeOneofCase.Int32) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Int32);
      }
      if (typeCase_ == TypeOneofCase.Int64) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Int64);
      }
      if (typeCase_ == TypeOneofCase.Uint32) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Uint32);
      }
      if (typeCase_ == TypeOneofCase.Uint64) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Uint64);
      }
      if (typeCase_ == TypeOneofCase.Sint32) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sint32);
      }
      if (typeCase_ == TypeOneofCase.Sint64) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sint64);
      }
      if (typeCase_ == TypeOneofCase.Fixed32) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fixed32);
      }
      if (typeCase_ == TypeOneofCase.Fixed64) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fixed64);
      }
      if (typeCase_ == TypeOneofCase.Sfixed32) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sfixed32);
      }
      if (typeCase_ == TypeOneofCase.Sfixed64) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sfixed64);
      }
      if (typeCase_ == TypeOneofCase.Bool) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Bool);
      }
      if (typeCase_ == TypeOneofCase.String) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(String);
      }
      if (typeCase_ == TypeOneofCase.Bytes) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Bytes);
      }
      if (typeCase_ == TypeOneofCase.Enum) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Enum);
      }
      if (typeCase_ == TypeOneofCase.Repeated) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Repeated);
      }
      if (typeCase_ == TypeOneofCase.Map) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Map);
      }
      if (typeCase_ == TypeOneofCase.Any) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Any);
      }
      if (typeCase_ == TypeOneofCase.Duration) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Duration);
      }
      if (typeCase_ == TypeOneofCase.Timestamp) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FieldConstraints other) {
      if (other == null) {
        return;
      }
      cel_.Add(other.cel_);
      if (other.Skipped != false) {
        Skipped = other.Skipped;
      }
      if (other.Required != false) {
        Required = other.Required;
      }
      if (other.IgnoreEmpty != false) {
        IgnoreEmpty = other.IgnoreEmpty;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Float:
          if (Float == null) {
            Float = new global::Buf.Validate.FloatRules();
          }
          Float.MergeFrom(other.Float);
          break;
        case TypeOneofCase.Double:
          if (Double == null) {
            Double = new global::Buf.Validate.DoubleRules();
          }
          Double.MergeFrom(other.Double);
          break;
        case TypeOneofCase.Int32:
          if (Int32 == null) {
            Int32 = new global::Buf.Validate.Int32Rules();
          }
          Int32.MergeFrom(other.Int32);
          break;
        case TypeOneofCase.Int64:
          if (Int64 == null) {
            Int64 = new global::Buf.Validate.Int64Rules();
          }
          Int64.MergeFrom(other.Int64);
          break;
        case TypeOneofCase.Uint32:
          if (Uint32 == null) {
            Uint32 = new global::Buf.Validate.UInt32Rules();
          }
          Uint32.MergeFrom(other.Uint32);
          break;
        case TypeOneofCase.Uint64:
          if (Uint64 == null) {
            Uint64 = new global::Buf.Validate.UInt64Rules();
          }
          Uint64.MergeFrom(other.Uint64);
          break;
        case TypeOneofCase.Sint32:
          if (Sint32 == null) {
            Sint32 = new global::Buf.Validate.SInt32Rules();
          }
          Sint32.MergeFrom(other.Sint32);
          break;
        case TypeOneofCase.Sint64:
          if (Sint64 == null) {
            Sint64 = new global::Buf.Validate.SInt64Rules();
          }
          Sint64.MergeFrom(other.Sint64);
          break;
        case TypeOneofCase.Fixed32:
          if (Fixed32 == null) {
            Fixed32 = new global::Buf.Validate.Fixed32Rules();
          }
          Fixed32.MergeFrom(other.Fixed32);
          break;
        case TypeOneofCase.Fixed64:
          if (Fixed64 == null) {
            Fixed64 = new global::Buf.Validate.Fixed64Rules();
          }
          Fixed64.MergeFrom(other.Fixed64);
          break;
        case TypeOneofCase.Sfixed32:
          if (Sfixed32 == null) {
            Sfixed32 = new global::Buf.Validate.SFixed32Rules();
          }
          Sfixed32.MergeFrom(other.Sfixed32);
          break;
        case TypeOneofCase.Sfixed64:
          if (Sfixed64 == null) {
            Sfixed64 = new global::Buf.Validate.SFixed64Rules();
          }
          Sfixed64.MergeFrom(other.Sfixed64);
          break;
        case TypeOneofCase.Bool:
          if (Bool == null) {
            Bool = new global::Buf.Validate.BoolRules();
          }
          Bool.MergeFrom(other.Bool);
          break;
        case TypeOneofCase.String:
          if (String == null) {
            String = new global::Buf.Validate.StringRules();
          }
          String.MergeFrom(other.String);
          break;
        case TypeOneofCase.Bytes:
          if (Bytes == null) {
            Bytes = new global::Buf.Validate.BytesRules();
          }
          Bytes.MergeFrom(other.Bytes);
          break;
        case TypeOneofCase.Enum:
          if (Enum == null) {
            Enum = new global::Buf.Validate.EnumRules();
          }
          Enum.MergeFrom(other.Enum);
          break;
        case TypeOneofCase.Repeated:
          if (Repeated == null) {
            Repeated = new global::Buf.Validate.RepeatedRules();
          }
          Repeated.MergeFrom(other.Repeated);
          break;
        case TypeOneofCase.Map:
          if (Map == null) {
            Map = new global::Buf.Validate.MapRules();
          }
          Map.MergeFrom(other.Map);
          break;
        case TypeOneofCase.Any:
          if (Any == null) {
            Any = new global::Buf.Validate.AnyRules();
          }
          Any.MergeFrom(other.Any);
          break;
        case TypeOneofCase.Duration:
          if (Duration == null) {
            Duration = new global::Buf.Validate.DurationRules();
          }
          Duration.MergeFrom(other.Duration);
          break;
        case TypeOneofCase.Timestamp:
          if (Timestamp == null) {
            Timestamp = new global::Buf.Validate.TimestampRules();
          }
          Timestamp.MergeFrom(other.Timestamp);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Buf.Validate.FloatRules subBuilder = new global::Buf.Validate.FloatRules();
            if (typeCase_ == TypeOneofCase.Float) {
              subBuilder.MergeFrom(Float);
            }
            input.ReadMessage(subBuilder);
            Float = subBuilder;
            break;
          }
          case 18: {
            global::Buf.Validate.DoubleRules subBuilder = new global::Buf.Validate.DoubleRules();
            if (typeCase_ == TypeOneofCase.Double) {
              subBuilder.MergeFrom(Double);
            }
            input.ReadMessage(subBuilder);
            Double = subBuilder;
            break;
          }
          case 26: {
            global::Buf.Validate.Int32Rules subBuilder = new global::Buf.Validate.Int32Rules();
            if (typeCase_ == TypeOneofCase.Int32) {
              subBuilder.MergeFrom(Int32);
            }
            input.ReadMessage(subBuilder);
            Int32 = subBuilder;
            break;
          }
          case 34: {
            global::Buf.Validate.Int64Rules subBuilder = new global::Buf.Validate.Int64Rules();
            if (typeCase_ == TypeOneofCase.Int64) {
              subBuilder.MergeFrom(Int64);
            }
            input.ReadMessage(subBuilder);
            Int64 = subBuilder;
            break;
          }
          case 42: {
            global::Buf.Validate.UInt32Rules subBuilder = new global::Buf.Validate.UInt32Rules();
            if (typeCase_ == TypeOneofCase.Uint32) {
              subBuilder.MergeFrom(Uint32);
            }
            input.ReadMessage(subBuilder);
            Uint32 = subBuilder;
            break;
          }
          case 50: {
            global::Buf.Validate.UInt64Rules subBuilder = new global::Buf.Validate.UInt64Rules();
            if (typeCase_ == TypeOneofCase.Uint64) {
              subBuilder.MergeFrom(Uint64);
            }
            input.ReadMessage(subBuilder);
            Uint64 = subBuilder;
            break;
          }
          case 58: {
            global::Buf.Validate.SInt32Rules subBuilder = new global::Buf.Validate.SInt32Rules();
            if (typeCase_ == TypeOneofCase.Sint32) {
              subBuilder.MergeFrom(Sint32);
            }
            input.ReadMessage(subBuilder);
            Sint32 = subBuilder;
            break;
          }
          case 66: {
            global::Buf.Validate.SInt64Rules subBuilder = new global::Buf.Validate.SInt64Rules();
            if (typeCase_ == TypeOneofCase.Sint64) {
              subBuilder.MergeFrom(Sint64);
            }
            input.ReadMessage(subBuilder);
            Sint64 = subBuilder;
            break;
          }
          case 74: {
            global::Buf.Validate.Fixed32Rules subBuilder = new global::Buf.Validate.Fixed32Rules();
            if (typeCase_ == TypeOneofCase.Fixed32) {
              subBuilder.MergeFrom(Fixed32);
            }
            input.ReadMessage(subBuilder);
            Fixed32 = subBuilder;
            break;
          }
          case 82: {
            global::Buf.Validate.Fixed64Rules subBuilder = new global::Buf.Validate.Fixed64Rules();
            if (typeCase_ == TypeOneofCase.Fixed64) {
              subBuilder.MergeFrom(Fixed64);
            }
            input.ReadMessage(subBuilder);
            Fixed64 = subBuilder;
            break;
          }
          case 90: {
            global::Buf.Validate.SFixed32Rules subBuilder = new global::Buf.Validate.SFixed32Rules();
            if (typeCase_ == TypeOneofCase.Sfixed32) {
              subBuilder.MergeFrom(Sfixed32);
            }
            input.ReadMessage(subBuilder);
            Sfixed32 = subBuilder;
            break;
          }
          case 98: {
            global::Buf.Validate.SFixed64Rules subBuilder = new global::Buf.Validate.SFixed64Rules();
            if (typeCase_ == TypeOneofCase.Sfixed64) {
              subBuilder.MergeFrom(Sfixed64);
            }
            input.ReadMessage(subBuilder);
            Sfixed64 = subBuilder;
            break;
          }
          case 106: {
            global::Buf.Validate.BoolRules subBuilder = new global::Buf.Validate.BoolRules();
            if (typeCase_ == TypeOneofCase.Bool) {
              subBuilder.MergeFrom(Bool);
            }
            input.ReadMessage(subBuilder);
            Bool = subBuilder;
            break;
          }
          case 114: {
            global::Buf.Validate.StringRules subBuilder = new global::Buf.Validate.StringRules();
            if (typeCase_ == TypeOneofCase.String) {
              subBuilder.MergeFrom(String);
            }
            input.ReadMessage(subBuilder);
            String = subBuilder;
            break;
          }
          case 122: {
            global::Buf.Validate.BytesRules subBuilder = new global::Buf.Validate.BytesRules();
            if (typeCase_ == TypeOneofCase.Bytes) {
              subBuilder.MergeFrom(Bytes);
            }
            input.ReadMessage(subBuilder);
            Bytes = subBuilder;
            break;
          }
          case 130: {
            global::Buf.Validate.EnumRules subBuilder = new global::Buf.Validate.EnumRules();
            if (typeCase_ == TypeOneofCase.Enum) {
              subBuilder.MergeFrom(Enum);
            }
            input.ReadMessage(subBuilder);
            Enum = subBuilder;
            break;
          }
          case 146: {
            global::Buf.Validate.RepeatedRules subBuilder = new global::Buf.Validate.RepeatedRules();
            if (typeCase_ == TypeOneofCase.Repeated) {
              subBuilder.MergeFrom(Repeated);
            }
            input.ReadMessage(subBuilder);
            Repeated = subBuilder;
            break;
          }
          case 154: {
            global::Buf.Validate.MapRules subBuilder = new global::Buf.Validate.MapRules();
            if (typeCase_ == TypeOneofCase.Map) {
              subBuilder.MergeFrom(Map);
            }
            input.ReadMessage(subBuilder);
            Map = subBuilder;
            break;
          }
          case 162: {
            global::Buf.Validate.AnyRules subBuilder = new global::Buf.Validate.AnyRules();
            if (typeCase_ == TypeOneofCase.Any) {
              subBuilder.MergeFrom(Any);
            }
            input.ReadMessage(subBuilder);
            Any = subBuilder;
            break;
          }
          case 170: {
            global::Buf.Validate.DurationRules subBuilder = new global::Buf.Validate.DurationRules();
            if (typeCase_ == TypeOneofCase.Duration) {
              subBuilder.MergeFrom(Duration);
            }
            input.ReadMessage(subBuilder);
            Duration = subBuilder;
            break;
          }
          case 178: {
            global::Buf.Validate.TimestampRules subBuilder = new global::Buf.Validate.TimestampRules();
            if (typeCase_ == TypeOneofCase.Timestamp) {
              subBuilder.MergeFrom(Timestamp);
            }
            input.ReadMessage(subBuilder);
            Timestamp = subBuilder;
            break;
          }
          case 186: {
            cel_.AddEntriesFrom(input, _repeated_cel_codec);
            break;
          }
          case 192: {
            Skipped = input.ReadBool();
            break;
          }
          case 200: {
            Required = input.ReadBool();
            break;
          }
          case 208: {
            IgnoreEmpty = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Buf.Validate.FloatRules subBuilder = new global::Buf.Validate.FloatRules();
            if (typeCase_ == TypeOneofCase.Float) {
              subBuilder.MergeFrom(Float);
            }
            input.ReadMessage(subBuilder);
            Float = subBuilder;
            break;
          }
          case 18: {
            global::Buf.Validate.DoubleRules subBuilder = new global::Buf.Validate.DoubleRules();
            if (typeCase_ == TypeOneofCase.Double) {
              subBuilder.MergeFrom(Double);
            }
            input.ReadMessage(subBuilder);
            Double = subBuilder;
            break;
          }
          case 26: {
            global::Buf.Validate.Int32Rules subBuilder = new global::Buf.Validate.Int32Rules();
            if (typeCase_ == TypeOneofCase.Int32) {
              subBuilder.MergeFrom(Int32);
            }
            input.ReadMessage(subBuilder);
            Int32 = subBuilder;
            break;
          }
          case 34: {
            global::Buf.Validate.Int64Rules subBuilder = new global::Buf.Validate.Int64Rules();
            if (typeCase_ == TypeOneofCase.Int64) {
              subBuilder.MergeFrom(Int64);
            }
            input.ReadMessage(subBuilder);
            Int64 = subBuilder;
            break;
          }
          case 42: {
            global::Buf.Validate.UInt32Rules subBuilder = new global::Buf.Validate.UInt32Rules();
            if (typeCase_ == TypeOneofCase.Uint32) {
              subBuilder.MergeFrom(Uint32);
            }
            input.ReadMessage(subBuilder);
            Uint32 = subBuilder;
            break;
          }
          case 50: {
            global::Buf.Validate.UInt64Rules subBuilder = new global::Buf.Validate.UInt64Rules();
            if (typeCase_ == TypeOneofCase.Uint64) {
              subBuilder.MergeFrom(Uint64);
            }
            input.ReadMessage(subBuilder);
            Uint64 = subBuilder;
            break;
          }
          case 58: {
            global::Buf.Validate.SInt32Rules subBuilder = new global::Buf.Validate.SInt32Rules();
            if (typeCase_ == TypeOneofCase.Sint32) {
              subBuilder.MergeFrom(Sint32);
            }
            input.ReadMessage(subBuilder);
            Sint32 = subBuilder;
            break;
          }
          case 66: {
            global::Buf.Validate.SInt64Rules subBuilder = new global::Buf.Validate.SInt64Rules();
            if (typeCase_ == TypeOneofCase.Sint64) {
              subBuilder.MergeFrom(Sint64);
            }
            input.ReadMessage(subBuilder);
            Sint64 = subBuilder;
            break;
          }
          case 74: {
            global::Buf.Validate.Fixed32Rules subBuilder = new global::Buf.Validate.Fixed32Rules();
            if (typeCase_ == TypeOneofCase.Fixed32) {
              subBuilder.MergeFrom(Fixed32);
            }
            input.ReadMessage(subBuilder);
            Fixed32 = subBuilder;
            break;
          }
          case 82: {
            global::Buf.Validate.Fixed64Rules subBuilder = new global::Buf.Validate.Fixed64Rules();
            if (typeCase_ == TypeOneofCase.Fixed64) {
              subBuilder.MergeFrom(Fixed64);
            }
            input.ReadMessage(subBuilder);
            Fixed64 = subBuilder;
            break;
          }
          case 90: {
            global::Buf.Validate.SFixed32Rules subBuilder = new global::Buf.Validate.SFixed32Rules();
            if (typeCase_ == TypeOneofCase.Sfixed32) {
              subBuilder.MergeFrom(Sfixed32);
            }
            input.ReadMessage(subBuilder);
            Sfixed32 = subBuilder;
            break;
          }
          case 98: {
            global::Buf.Validate.SFixed64Rules subBuilder = new global::Buf.Validate.SFixed64Rules();
            if (typeCase_ == TypeOneofCase.Sfixed64) {
              subBuilder.MergeFrom(Sfixed64);
            }
            input.ReadMessage(subBuilder);
            Sfixed64 = subBuilder;
            break;
          }
          case 106: {
            global::Buf.Validate.BoolRules subBuilder = new global::Buf.Validate.BoolRules();
            if (typeCase_ == TypeOneofCase.Bool) {
              subBuilder.MergeFrom(Bool);
            }
            input.ReadMessage(subBuilder);
            Bool = subBuilder;
            break;
          }
          case 114: {
            global::Buf.Validate.StringRules subBuilder = new global::Buf.Validate.StringRules();
            if (typeCase_ == TypeOneofCase.String) {
              subBuilder.MergeFrom(String);
            }
            input.ReadMessage(subBuilder);
            String = subBuilder;
            break;
          }
          case 122: {
            global::Buf.Validate.BytesRules subBuilder = new global::Buf.Validate.BytesRules();
            if (typeCase_ == TypeOneofCase.Bytes) {
              subBuilder.MergeFrom(Bytes);
            }
            input.ReadMessage(subBuilder);
            Bytes = subBuilder;
            break;
          }
          case 130: {
            global::Buf.Validate.EnumRules subBuilder = new global::Buf.Validate.EnumRules();
            if (typeCase_ == TypeOneofCase.Enum) {
              subBuilder.MergeFrom(Enum);
            }
            input.ReadMessage(subBuilder);
            Enum = subBuilder;
            break;
          }
          case 146: {
            global::Buf.Validate.RepeatedRules subBuilder = new global::Buf.Validate.RepeatedRules();
            if (typeCase_ == TypeOneofCase.Repeated) {
              subBuilder.MergeFrom(Repeated);
            }
            input.ReadMessage(subBuilder);
            Repeated = subBuilder;
            break;
          }
          case 154: {
            global::Buf.Validate.MapRules subBuilder = new global::Buf.Validate.MapRules();
            if (typeCase_ == TypeOneofCase.Map) {
              subBuilder.MergeFrom(Map);
            }
            input.ReadMessage(subBuilder);
            Map = subBuilder;
            break;
          }
          case 162: {
            global::Buf.Validate.AnyRules subBuilder = new global::Buf.Validate.AnyRules();
            if (typeCase_ == TypeOneofCase.Any) {
              subBuilder.MergeFrom(Any);
            }
            input.ReadMessage(subBuilder);
            Any = subBuilder;
            break;
          }
          case 170: {
            global::Buf.Validate.DurationRules subBuilder = new global::Buf.Validate.DurationRules();
            if (typeCase_ == TypeOneofCase.Duration) {
              subBuilder.MergeFrom(Duration);
            }
            input.ReadMessage(subBuilder);
            Duration = subBuilder;
            break;
          }
          case 178: {
            global::Buf.Validate.TimestampRules subBuilder = new global::Buf.Validate.TimestampRules();
            if (typeCase_ == TypeOneofCase.Timestamp) {
              subBuilder.MergeFrom(Timestamp);
            }
            input.ReadMessage(subBuilder);
            Timestamp = subBuilder;
            break;
          }
          case 186: {
            cel_.AddEntriesFrom(ref input, _repeated_cel_codec);
            break;
          }
          case 192: {
            Skipped = input.ReadBool();
            break;
          }
          case 200: {
            Required = input.ReadBool();
            break;
          }
          case 208: {
            IgnoreEmpty = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// FloatRules describes the constraints applied to `float` values. These
  /// rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
  /// </summary>
  public sealed partial class FloatRules : pb::IMessage<FloatRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FloatRules> _parser = new pb::MessageParser<FloatRules>(() => new FloatRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FloatRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FloatRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FloatRules(FloatRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FloatRules Clone() {
      return new FloatRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static float ConstDefaultValue = 0F;

    private float const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must equal 42.0
    ///   float value = 1 [(buf.validate.field).float.const = 42.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static float LtDefaultValue = 0F;

    private float lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must be less than 10.0
    ///   float value = 1 [(buf.validate.field).float.lt = 10.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static float LteDefaultValue = 0F;

    private float lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must be less than or equal to 10.0
    ///   float value = 1 [(buf.validate.field).float.lte = 10.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static float GtDefaultValue = 0F;

    private float gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must be greater than 5.0 [float.gt]
    ///  float value = 1 [(buf.validate.field).float.gt = 5.0];
    ///
    ///  // value must be greater than 5 and less than 10.0 [float.gt_lt]
    ///  float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
    ///
    ///  // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
    ///  float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static float GteDefaultValue = 0F;

    private float gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must be greater than or equal to 5.0 [float.gte]
    ///  float value = 1 [(buf.validate.field).float.gte = 5.0];
    ///
    ///  // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
    ///  float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
    ///
    ///  // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
    ///  float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<float> _repeated_in_codec
        = pb::FieldCodec.ForFloat(50);
    private readonly pbc::RepeatedField<float> in_ = new pbc::RepeatedField<float>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must be in list [1.0, 2.0, 3.0]
    ///  repeated float value = 1 (buf.validate.field).float = { in: [1.0, 2.0, 3.0] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_notIn_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> notIn_ = new pbc::RepeatedField<float>();
    /// <summary>
    ///`in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyFloat {
    ///  // value must not be in list [1.0, 2.0, 3.0]
    ///  repeated float value = 1 (buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FloatRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FloatRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Const, other.Const)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Lt, other.Lt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Lte, other.Lte)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Gt, other.Gt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Gte, other.Gte)) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Const);
      if (HasLt) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Lt);
      if (HasLte) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Lte);
      if (HasGt) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Gt);
      if (HasGte) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Gte);
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteFloat(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteFloat(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteFloat(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteFloat(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteFloat(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteFloat(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteFloat(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteFloat(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteFloat(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteFloat(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 4;
      }
      if (HasLt) {
        size += 1 + 4;
      }
      if (HasLte) {
        size += 1 + 4;
      }
      if (HasGt) {
        size += 1 + 4;
      }
      if (HasGte) {
        size += 1 + 4;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FloatRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Const = input.ReadFloat();
            break;
          }
          case 21: {
            Lt = input.ReadFloat();
            break;
          }
          case 29: {
            Lte = input.ReadFloat();
            break;
          }
          case 37: {
            Gt = input.ReadFloat();
            break;
          }
          case 45: {
            Gte = input.ReadFloat();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Const = input.ReadFloat();
            break;
          }
          case 21: {
            Lt = input.ReadFloat();
            break;
          }
          case 29: {
            Lte = input.ReadFloat();
            break;
          }
          case 37: {
            Gt = input.ReadFloat();
            break;
          }
          case 45: {
            Gte = input.ReadFloat();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// DoubleRules describes the constraints applied to `double` values. These
  /// rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
  /// </summary>
  public sealed partial class DoubleRules : pb::IMessage<DoubleRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DoubleRules> _parser = new pb::MessageParser<DoubleRules>(() => new DoubleRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DoubleRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DoubleRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DoubleRules(DoubleRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DoubleRules Clone() {
      return new DoubleRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static double ConstDefaultValue = 0D;

    private double const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must equal 42.0
    ///   double value = 1 [(buf.validate.field).double.const = 42.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static double LtDefaultValue = 0D;

    private double lt_;
    /// <summary>
    /// `lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must be less than 10.0
    ///   double value = 1 [(buf.validate.field).double.lt = 10.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static double LteDefaultValue = 0D;

    private double lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified value
    /// (field &lt;= value). If the field value is greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must be less than or equal to 10.0
    ///   double value = 1 [(buf.validate.field).double.lte = 10.0];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static double GtDefaultValue = 0D;

    private double gt_;
    /// <summary>
    /// `gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
    /// the range is reversed, and the field value must be outside the specified
    /// range. If the field value doesn't meet the required conditions, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must be greater than 5.0 [double.gt]
    ///  double value = 1 [(buf.validate.field).double.gt = 5.0];
    ///
    ///  // value must be greater than 5 and less than 10.0 [double.gt_lt]
    ///  double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
    ///
    ///  // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
    ///  double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static double GteDefaultValue = 0D;

    private double gte_;
    /// <summary>
    /// `gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must be greater than or equal to 5.0 [double.gte]
    ///  double value = 1 [(buf.validate.field).double.gte = 5.0];
    ///
    ///  // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
    ///  double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
    ///
    ///  // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
    ///  double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<double> _repeated_in_codec
        = pb::FieldCodec.ForDouble(50);
    private readonly pbc::RepeatedField<double> in_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must be in list [1.0, 2.0, 3.0]
    ///  repeated double value = 1 (buf.validate.field).double = { in: [1.0, 2.0, 3.0] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<double> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<double> _repeated_notIn_codec
        = pb::FieldCodec.ForDouble(58);
    private readonly pbc::RepeatedField<double> notIn_ = new pbc::RepeatedField<double>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyDouble {
    ///  // value must not be in list [1.0, 2.0, 3.0]
    ///  repeated double value = 1 (buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<double> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DoubleRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DoubleRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Const, other.Const)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Lt, other.Lt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Lte, other.Lte)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Gt, other.Gt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Gte, other.Gte)) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Const);
      if (HasLt) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Lt);
      if (HasLte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Lte);
      if (HasGt) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Gt);
      if (HasGte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Gte);
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteDouble(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteDouble(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteDouble(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteDouble(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteDouble(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteDouble(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteDouble(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteDouble(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteDouble(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteDouble(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 8;
      }
      if (HasLt) {
        size += 1 + 8;
      }
      if (HasLte) {
        size += 1 + 8;
      }
      if (HasGt) {
        size += 1 + 8;
      }
      if (HasGte) {
        size += 1 + 8;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DoubleRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Const = input.ReadDouble();
            break;
          }
          case 17: {
            Lt = input.ReadDouble();
            break;
          }
          case 25: {
            Lte = input.ReadDouble();
            break;
          }
          case 33: {
            Gt = input.ReadDouble();
            break;
          }
          case 41: {
            Gte = input.ReadDouble();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            Const = input.ReadDouble();
            break;
          }
          case 17: {
            Lt = input.ReadDouble();
            break;
          }
          case 25: {
            Lte = input.ReadDouble();
            break;
          }
          case 33: {
            Gt = input.ReadDouble();
            break;
          }
          case 41: {
            Gte = input.ReadDouble();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Int32Rules describes the constraints applied to `int32` values. These
  /// rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
  /// </summary>
  public sealed partial class Int32Rules : pb::IMessage<Int32Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Int32Rules> _parser = new pb::MessageParser<Int32Rules>(() => new Int32Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Int32Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Rules(Int32Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int32Rules Clone() {
      return new Int32Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static int ConstDefaultValue = 0;

    private int const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must equal 42
    ///   int32 value = 1 [(buf.validate.field).int32.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static int LtDefaultValue = 0;

    private int lt_;
    /// <summary>
    /// `lt` requires the field value to be less than the specified value (field
    /// &lt; value). If the field value is equal to or greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must be less than 10
    ///   int32 value = 1 [(buf.validate.field).int32.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static int LteDefaultValue = 0;

    private int lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must be less than or equal to 10
    ///   int32 value = 1 [(buf.validate.field).int32.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static int GtDefaultValue = 0;

    private int gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must be greater than 5 [int32.gt]
    ///  int32 value = 1 [(buf.validate.field).int32.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [int32.gt_lt]
    ///  int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
    ///  int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static int GteDefaultValue = 0;

    private int gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified value
    /// (exclusive). If the value of `gte` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must be greater than or equal to 5 [int32.gte]
    ///  int32 value = 1 [(buf.validate.field).int32.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
    ///  int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
    ///  int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<int> _repeated_in_codec
        = pb::FieldCodec.ForInt32(50);
    private readonly pbc::RepeatedField<int> in_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated int32 value = 1 (buf.validate.field).int32 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<int> _repeated_notIn_codec
        = pb::FieldCodec.ForInt32(58);
    private readonly pbc::RepeatedField<int> notIn_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error message
    /// is generated.
    ///
    ///```proto
    ///message MyInt32 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated int32 value = 1 (buf.validate.field).int32 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Int32Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Int32Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteInt32(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteInt32(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Int32Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadInt32();
            break;
          }
          case 16: {
            Lt = input.ReadInt32();
            break;
          }
          case 24: {
            Lte = input.ReadInt32();
            break;
          }
          case 32: {
            Gt = input.ReadInt32();
            break;
          }
          case 40: {
            Gte = input.ReadInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadInt32();
            break;
          }
          case 16: {
            Lt = input.ReadInt32();
            break;
          }
          case 24: {
            Lte = input.ReadInt32();
            break;
          }
          case 32: {
            Gt = input.ReadInt32();
            break;
          }
          case 40: {
            Gte = input.ReadInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Int64Rules describes the constraints applied to `int64` values. These
  /// rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
  /// </summary>
  public sealed partial class Int64Rules : pb::IMessage<Int64Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Int64Rules> _parser = new pb::MessageParser<Int64Rules>(() => new Int64Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Int64Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int64Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int64Rules(Int64Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Int64Rules Clone() {
      return new Int64Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static long ConstDefaultValue = 0L;

    private long const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must equal 42
    ///   int64 value = 1 [(buf.validate.field).int64.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static long LtDefaultValue = 0L;

    private long lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must be less than 10
    ///   int64 value = 1 [(buf.validate.field).int64.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static long LteDefaultValue = 0L;

    private long lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must be less than or equal to 10
    ///   int64 value = 1 [(buf.validate.field).int64.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static long GtDefaultValue = 0L;

    private long gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must be greater than 5 [int64.gt]
    ///  int64 value = 1 [(buf.validate.field).int64.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [int64.gt_lt]
    ///  int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
    ///  int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static long GteDefaultValue = 0L;

    private long gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must be greater than or equal to 5 [int64.gte]
    ///  int64 value = 1 [(buf.validate.field).int64.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
    ///  int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
    ///  int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<long> _repeated_in_codec
        = pb::FieldCodec.ForInt64(50);
    private readonly pbc::RepeatedField<long> in_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated int64 value = 1 (buf.validate.field).int64 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_notIn_codec
        = pb::FieldCodec.ForInt64(58);
    private readonly pbc::RepeatedField<long> notIn_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyInt64 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated int64 value = 1 (buf.validate.field).int64 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Int64Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Int64Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteInt64(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteInt64(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Int64Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadInt64();
            break;
          }
          case 16: {
            Lt = input.ReadInt64();
            break;
          }
          case 24: {
            Lte = input.ReadInt64();
            break;
          }
          case 32: {
            Gt = input.ReadInt64();
            break;
          }
          case 40: {
            Gte = input.ReadInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadInt64();
            break;
          }
          case 16: {
            Lt = input.ReadInt64();
            break;
          }
          case 24: {
            Lte = input.ReadInt64();
            break;
          }
          case 32: {
            Gt = input.ReadInt64();
            break;
          }
          case 40: {
            Gte = input.ReadInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UInt32Rules describes the constraints applied to `uint32` values. These
  /// rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
  /// </summary>
  public sealed partial class UInt32Rules : pb::IMessage<UInt32Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UInt32Rules> _parser = new pb::MessageParser<UInt32Rules>(() => new UInt32Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UInt32Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt32Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt32Rules(UInt32Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt32Rules Clone() {
      return new UInt32Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static uint ConstDefaultValue = 0;

    private uint const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must equal 42
    ///   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static uint LtDefaultValue = 0;

    private uint lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must be less than 10
    ///   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static uint LteDefaultValue = 0;

    private uint lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must be less than or equal to 10
    ///   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static uint GtDefaultValue = 0;

    private uint gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must be greater than 5 [uint32.gt]
    ///  uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [uint32.gt_lt]
    ///  uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
    ///  uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static uint GteDefaultValue = 0;

    private uint gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must be greater than or equal to 5 [uint32.gte]
    ///  uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
    ///  uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
    ///  uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<uint> _repeated_in_codec
        = pb::FieldCodec.ForUInt32(50);
    private readonly pbc::RepeatedField<uint> in_ = new pbc::RepeatedField<uint>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated uint32 value = 1 (buf.validate.field).uint32 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<uint> _repeated_notIn_codec
        = pb::FieldCodec.ForUInt32(58);
    private readonly pbc::RepeatedField<uint> notIn_ = new pbc::RepeatedField<uint>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyUInt32 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated uint32 value = 1 (buf.validate.field).uint32 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UInt32Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UInt32Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteUInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteUInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteUInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteUInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteUInt32(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteUInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteUInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteUInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteUInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteUInt32(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UInt32Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadUInt32();
            break;
          }
          case 16: {
            Lt = input.ReadUInt32();
            break;
          }
          case 24: {
            Lte = input.ReadUInt32();
            break;
          }
          case 32: {
            Gt = input.ReadUInt32();
            break;
          }
          case 40: {
            Gte = input.ReadUInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadUInt32();
            break;
          }
          case 16: {
            Lt = input.ReadUInt32();
            break;
          }
          case 24: {
            Lte = input.ReadUInt32();
            break;
          }
          case 32: {
            Gt = input.ReadUInt32();
            break;
          }
          case 40: {
            Gte = input.ReadUInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// UInt64Rules describes the constraints applied to `uint64` values. These
  /// rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
  /// </summary>
  public sealed partial class UInt64Rules : pb::IMessage<UInt64Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UInt64Rules> _parser = new pb::MessageParser<UInt64Rules>(() => new UInt64Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UInt64Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt64Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt64Rules(UInt64Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UInt64Rules Clone() {
      return new UInt64Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static ulong ConstDefaultValue = 0UL;

    private ulong const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must equal 42
    ///   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static ulong LtDefaultValue = 0UL;

    private ulong lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must be less than 10
    ///   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static ulong LteDefaultValue = 0UL;

    private ulong lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must be less than or equal to 10
    ///   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static ulong GtDefaultValue = 0UL;

    private ulong gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must be greater than 5 [uint64.gt]
    ///  uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [uint64.gt_lt]
    ///  uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
    ///  uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static ulong GteDefaultValue = 0UL;

    private ulong gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must be greater than or equal to 5 [uint64.gte]
    ///  uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
    ///  uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
    ///  uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<ulong> _repeated_in_codec
        = pb::FieldCodec.ForUInt64(50);
    private readonly pbc::RepeatedField<ulong> in_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated uint64 value = 1 (buf.validate.field).uint64 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<ulong> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<ulong> _repeated_notIn_codec
        = pb::FieldCodec.ForUInt64(58);
    private readonly pbc::RepeatedField<ulong> notIn_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyUInt64 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated uint64 value = 1 (buf.validate.field).uint64 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<ulong> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UInt64Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UInt64Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteUInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteUInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteUInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteUInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteUInt64(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteUInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteUInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteUInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteUInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteUInt64(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UInt64Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadUInt64();
            break;
          }
          case 16: {
            Lt = input.ReadUInt64();
            break;
          }
          case 24: {
            Lte = input.ReadUInt64();
            break;
          }
          case 32: {
            Gt = input.ReadUInt64();
            break;
          }
          case 40: {
            Gte = input.ReadUInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadUInt64();
            break;
          }
          case 16: {
            Lt = input.ReadUInt64();
            break;
          }
          case 24: {
            Lte = input.ReadUInt64();
            break;
          }
          case 32: {
            Gt = input.ReadUInt64();
            break;
          }
          case 40: {
            Gte = input.ReadUInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SInt32Rules describes the constraints applied to `sint32` values.
  /// </summary>
  public sealed partial class SInt32Rules : pb::IMessage<SInt32Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SInt32Rules> _parser = new pb::MessageParser<SInt32Rules>(() => new SInt32Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SInt32Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt32Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt32Rules(SInt32Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt32Rules Clone() {
      return new SInt32Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static int ConstDefaultValue = 0;

    private int const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must equal 42
    ///   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static int LtDefaultValue = 0;

    private int lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field
    /// &lt; value). If the field value is equal to or greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must be less than 10
    ///   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static int LteDefaultValue = 0;

    private int lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must be less than or equal to 10
    ///   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static int GtDefaultValue = 0;

    private int gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must be greater than 5 [sint32.gt]
    ///  sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [sint32.gt_lt]
    ///  sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
    ///  sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static int GteDefaultValue = 0;

    private int gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must be greater than or equal to 5 [sint32.gte]
    ///  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
    ///  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
    ///  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<int> _repeated_in_codec
        = pb::FieldCodec.ForSInt32(50);
    private readonly pbc::RepeatedField<int> in_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated sint32 value = 1 (buf.validate.field).sint32 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<int> _repeated_notIn_codec
        = pb::FieldCodec.ForSInt32(58);
    private readonly pbc::RepeatedField<int> notIn_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MySInt32 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated sint32 value = 1 (buf.validate.field).sint32 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SInt32Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SInt32Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteSInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteSInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteSInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteSInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteSInt32(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteSInt32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteSInt32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteSInt32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteSInt32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteSInt32(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SInt32Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadSInt32();
            break;
          }
          case 16: {
            Lt = input.ReadSInt32();
            break;
          }
          case 24: {
            Lte = input.ReadSInt32();
            break;
          }
          case 32: {
            Gt = input.ReadSInt32();
            break;
          }
          case 40: {
            Gte = input.ReadSInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadSInt32();
            break;
          }
          case 16: {
            Lt = input.ReadSInt32();
            break;
          }
          case 24: {
            Lte = input.ReadSInt32();
            break;
          }
          case 32: {
            Gt = input.ReadSInt32();
            break;
          }
          case 40: {
            Gte = input.ReadSInt32();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SInt64Rules describes the constraints applied to `sint64` values.
  /// </summary>
  public sealed partial class SInt64Rules : pb::IMessage<SInt64Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SInt64Rules> _parser = new pb::MessageParser<SInt64Rules>(() => new SInt64Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SInt64Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt64Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt64Rules(SInt64Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SInt64Rules Clone() {
      return new SInt64Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static long ConstDefaultValue = 0L;

    private long const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must equal 42
    ///   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static long LtDefaultValue = 0L;

    private long lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field
    /// &lt; value). If the field value is equal to or greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must be less than 10
    ///   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static long LteDefaultValue = 0L;

    private long lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must be less than or equal to 10
    ///   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static long GtDefaultValue = 0L;

    private long gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must be greater than 5 [sint64.gt]
    ///  sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [sint64.gt_lt]
    ///  sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
    ///  sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static long GteDefaultValue = 0L;

    private long gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must be greater than or equal to 5 [sint64.gte]
    ///  sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
    ///  sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
    ///  sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<long> _repeated_in_codec
        = pb::FieldCodec.ForSInt64(50);
    private readonly pbc::RepeatedField<long> in_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated sint64 value = 1 (buf.validate.field).sint64 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_notIn_codec
        = pb::FieldCodec.ForSInt64(58);
    private readonly pbc::RepeatedField<long> notIn_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MySInt64 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated sint64 value = 1 (buf.validate.field).sint64 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SInt64Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SInt64Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteSInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteSInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteSInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteSInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteSInt64(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteSInt64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(16);
        output.WriteSInt64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(24);
        output.WriteSInt64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(32);
        output.WriteSInt64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(40);
        output.WriteSInt64(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Const);
      }
      if (HasLt) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Lt);
      }
      if (HasLte) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Lte);
      }
      if (HasGt) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Gt);
      }
      if (HasGte) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SInt64Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadSInt64();
            break;
          }
          case 16: {
            Lt = input.ReadSInt64();
            break;
          }
          case 24: {
            Lte = input.ReadSInt64();
            break;
          }
          case 32: {
            Gt = input.ReadSInt64();
            break;
          }
          case 40: {
            Gte = input.ReadSInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadSInt64();
            break;
          }
          case 16: {
            Lt = input.ReadSInt64();
            break;
          }
          case 24: {
            Lte = input.ReadSInt64();
            break;
          }
          case 32: {
            Gt = input.ReadSInt64();
            break;
          }
          case 40: {
            Gte = input.ReadSInt64();
            break;
          }
          case 50:
          case 48: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 56: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Fixed32Rules describes the constraints applied to `fixed32` values.
  /// </summary>
  public sealed partial class Fixed32Rules : pb::IMessage<Fixed32Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Fixed32Rules> _parser = new pb::MessageParser<Fixed32Rules>(() => new Fixed32Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Fixed32Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed32Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed32Rules(Fixed32Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed32Rules Clone() {
      return new Fixed32Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static uint ConstDefaultValue = 0;

    private uint const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value.
    /// If the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must equal 42
    ///   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static uint LtDefaultValue = 0;

    private uint lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must be less than 10
    ///   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static uint LteDefaultValue = 0;

    private uint lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must be less than or equal to 10
    ///   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static uint GtDefaultValue = 0;

    private uint gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must be greater than 5 [fixed32.gt]
    ///  fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [fixed32.gt_lt]
    ///  fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
    ///  fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static uint GteDefaultValue = 0;

    private uint gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must be greater than or equal to 5 [fixed32.gte]
    ///  fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
    ///  fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
    ///  fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<uint> _repeated_in_codec
        = pb::FieldCodec.ForFixed32(50);
    private readonly pbc::RepeatedField<uint> in_ = new pbc::RepeatedField<uint>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated fixed32 value = 1 (buf.validate.field).fixed32 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<uint> _repeated_notIn_codec
        = pb::FieldCodec.ForFixed32(58);
    private readonly pbc::RepeatedField<uint> notIn_ = new pbc::RepeatedField<uint>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyFixed32 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated fixed32 value = 1 (buf.validate.field).fixed32 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Fixed32Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Fixed32Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteFixed32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteFixed32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteFixed32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteFixed32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteFixed32(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteFixed32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteFixed32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteFixed32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteFixed32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteFixed32(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 4;
      }
      if (HasLt) {
        size += 1 + 4;
      }
      if (HasLte) {
        size += 1 + 4;
      }
      if (HasGt) {
        size += 1 + 4;
      }
      if (HasGte) {
        size += 1 + 4;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Fixed32Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Const = input.ReadFixed32();
            break;
          }
          case 21: {
            Lt = input.ReadFixed32();
            break;
          }
          case 29: {
            Lte = input.ReadFixed32();
            break;
          }
          case 37: {
            Gt = input.ReadFixed32();
            break;
          }
          case 45: {
            Gte = input.ReadFixed32();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Const = input.ReadFixed32();
            break;
          }
          case 21: {
            Lt = input.ReadFixed32();
            break;
          }
          case 29: {
            Lte = input.ReadFixed32();
            break;
          }
          case 37: {
            Gt = input.ReadFixed32();
            break;
          }
          case 45: {
            Gte = input.ReadFixed32();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Fixed64Rules describes the constraints applied to `fixed64` values.
  /// </summary>
  public sealed partial class Fixed64Rules : pb::IMessage<Fixed64Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Fixed64Rules> _parser = new pb::MessageParser<Fixed64Rules>(() => new Fixed64Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Fixed64Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed64Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed64Rules(Fixed64Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fixed64Rules Clone() {
      return new Fixed64Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static ulong ConstDefaultValue = 0UL;

    private ulong const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must equal 42
    ///   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static ulong LtDefaultValue = 0UL;

    private ulong lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must be less than 10
    ///   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static ulong LteDefaultValue = 0UL;

    private ulong lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must be less than or equal to 10
    ///   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static ulong GtDefaultValue = 0UL;

    private ulong gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must be greater than 5 [fixed64.gt]
    ///  fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [fixed64.gt_lt]
    ///  fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
    ///  fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static ulong GteDefaultValue = 0UL;

    private ulong gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must be greater than or equal to 5 [fixed64.gte]
    ///  fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
    ///  fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
    ///  fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<ulong> _repeated_in_codec
        = pb::FieldCodec.ForFixed64(50);
    private readonly pbc::RepeatedField<ulong> in_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated fixed64 value = 1 (buf.validate.field).fixed64 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<ulong> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<ulong> _repeated_notIn_codec
        = pb::FieldCodec.ForFixed64(58);
    private readonly pbc::RepeatedField<ulong> notIn_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MyFixed64 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated fixed64 value = 1 (buf.validate.field).fixed64 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<ulong> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Fixed64Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Fixed64Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteFixed64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteFixed64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteFixed64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteFixed64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteFixed64(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteFixed64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteFixed64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteFixed64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteFixed64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteFixed64(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 8;
      }
      if (HasLt) {
        size += 1 + 8;
      }
      if (HasLte) {
        size += 1 + 8;
      }
      if (HasGt) {
        size += 1 + 8;
      }
      if (HasGte) {
        size += 1 + 8;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Fixed64Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Const = input.ReadFixed64();
            break;
          }
          case 17: {
            Lt = input.ReadFixed64();
            break;
          }
          case 25: {
            Lte = input.ReadFixed64();
            break;
          }
          case 33: {
            Gt = input.ReadFixed64();
            break;
          }
          case 41: {
            Gte = input.ReadFixed64();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            Const = input.ReadFixed64();
            break;
          }
          case 17: {
            Lt = input.ReadFixed64();
            break;
          }
          case 25: {
            Lte = input.ReadFixed64();
            break;
          }
          case 33: {
            Gt = input.ReadFixed64();
            break;
          }
          case 41: {
            Gte = input.ReadFixed64();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SFixed32Rules describes the constraints applied to `fixed32` values.
  /// </summary>
  public sealed partial class SFixed32Rules : pb::IMessage<SFixed32Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SFixed32Rules> _parser = new pb::MessageParser<SFixed32Rules>(() => new SFixed32Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SFixed32Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed32Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed32Rules(SFixed32Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed32Rules Clone() {
      return new SFixed32Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static int ConstDefaultValue = 0;

    private int const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must equal 42
    ///   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static int LtDefaultValue = 0;

    private int lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must be less than 10
    ///   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static int LteDefaultValue = 0;

    private int lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must be less than or equal to 10
    ///   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static int GtDefaultValue = 0;

    private int gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must be greater than 5 [sfixed32.gt]
    ///  sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
    ///  sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
    ///  sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static int GteDefaultValue = 0;

    private int gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must be greater than or equal to 5 [sfixed32.gte]
    ///  sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
    ///  sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
    ///  sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<int> _repeated_in_codec
        = pb::FieldCodec.ForSFixed32(50);
    private readonly pbc::RepeatedField<int> in_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<int> _repeated_notIn_codec
        = pb::FieldCodec.ForSFixed32(58);
    private readonly pbc::RepeatedField<int> notIn_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MySFixed32 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SFixed32Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SFixed32Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteSFixed32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteSFixed32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteSFixed32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteSFixed32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteSFixed32(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(13);
        output.WriteSFixed32(Const);
      }
      if (HasLt) {
        output.WriteRawTag(21);
        output.WriteSFixed32(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(29);
        output.WriteSFixed32(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(37);
        output.WriteSFixed32(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(45);
        output.WriteSFixed32(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 4;
      }
      if (HasLt) {
        size += 1 + 4;
      }
      if (HasLte) {
        size += 1 + 4;
      }
      if (HasGt) {
        size += 1 + 4;
      }
      if (HasGte) {
        size += 1 + 4;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SFixed32Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Const = input.ReadSFixed32();
            break;
          }
          case 21: {
            Lt = input.ReadSFixed32();
            break;
          }
          case 29: {
            Lte = input.ReadSFixed32();
            break;
          }
          case 37: {
            Gt = input.ReadSFixed32();
            break;
          }
          case 45: {
            Gte = input.ReadSFixed32();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Const = input.ReadSFixed32();
            break;
          }
          case 21: {
            Lt = input.ReadSFixed32();
            break;
          }
          case 29: {
            Lte = input.ReadSFixed32();
            break;
          }
          case 37: {
            Gt = input.ReadSFixed32();
            break;
          }
          case 45: {
            Gte = input.ReadSFixed32();
            break;
          }
          case 50:
          case 53: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 61: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SFixed64Rules describes the constraints applied to `fixed64` values.
  /// </summary>
  public sealed partial class SFixed64Rules : pb::IMessage<SFixed64Rules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SFixed64Rules> _parser = new pb::MessageParser<SFixed64Rules>(() => new SFixed64Rules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SFixed64Rules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed64Rules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed64Rules(SFixed64Rules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      lt_ = other.lt_;
      lte_ = other.lte_;
      gt_ = other.gt_;
      gte_ = other.gte_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SFixed64Rules Clone() {
      return new SFixed64Rules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static long ConstDefaultValue = 0L;

    private long const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must equal 42
    ///   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 2;
    private readonly static long LtDefaultValue = 0L;

    private long lt_;
    /// <summary>
    ///`lt` requires the field value to be less than the specified value (field &lt;
    /// value). If the field value is equal to or greater than the specified value,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must be less than 10
    ///   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lt {
      get { if ((_hasBits0 & 2) != 0) { return lt_; } else { return LtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        lt_ = value;
      }
    }
    /// <summary>Gets whether the "lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 3;
    private readonly static long LteDefaultValue = 0L;

    private long lte_;
    /// <summary>
    ///`lte` requires the field value to be less than or equal to the specified
    /// value (field &lt;= value). If the field value is greater than the specified
    /// value, an error message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must be less than or equal to 10
    ///   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Lte {
      get { if ((_hasBits0 & 4) != 0) { return lte_; } else { return LteDefaultValue; } }
      set {
        _hasBits0 |= 4;
        lte_ = value;
      }
    }
    /// <summary>Gets whether the "lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLte {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLte() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 4;
    private readonly static long GtDefaultValue = 0L;

    private long gt_;
    /// <summary>
    ///`gt` requires the field value to be greater than the specified value
    /// (exclusive). If the value of `gt` is larger than a specified `lt` or
    /// `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must be greater than 5 [sfixed64.gt]
    ///  sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
    ///
    ///  // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
    ///  sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
    ///
    ///  // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
    ///  sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gt {
      get { if ((_hasBits0 & 8) != 0) { return gt_; } else { return GtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        gt_ = value;
      }
    }
    /// <summary>Gets whether the "gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 5;
    private readonly static long GteDefaultValue = 0L;

    private long gte_;
    /// <summary>
    ///`gte` requires the field value to be greater than or equal to the specified
    /// value (exclusive). If the value of `gte` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must be greater than or equal to 5 [sfixed64.gte]
    ///  sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
    ///
    ///  // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
    ///  sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
    ///
    ///  // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
    ///  sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gte {
      get { if ((_hasBits0 & 16) != 0) { return gte_; } else { return GteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        gte_ = value;
      }
    }
    /// <summary>Gets whether the "gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 6;
    private static readonly pb::FieldCodec<long> _repeated_in_codec
        = pb::FieldCodec.ForSFixed64(50);
    private readonly pbc::RepeatedField<long> in_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must be in list [1, 2, 3]
    ///  repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_notIn_codec
        = pb::FieldCodec.ForSFixed64(58);
    private readonly pbc::RepeatedField<long> notIn_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///`not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    ///```proto
    ///message MySFixed64 {
    ///  // value must not be in list [1, 2, 3]
    ///  repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { not_in: [1, 2, 3] };
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SFixed64Rules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SFixed64Rules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Lt != other.Lt) return false;
      if (Lte != other.Lte) return false;
      if (Gt != other.Gt) return false;
      if (Gte != other.Gte) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLt) hash ^= Lt.GetHashCode();
      if (HasLte) hash ^= Lte.GetHashCode();
      if (HasGt) hash ^= Gt.GetHashCode();
      if (HasGte) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteSFixed64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteSFixed64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteSFixed64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteSFixed64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteSFixed64(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(9);
        output.WriteSFixed64(Const);
      }
      if (HasLt) {
        output.WriteRawTag(17);
        output.WriteSFixed64(Lt);
      }
      if (HasLte) {
        output.WriteRawTag(25);
        output.WriteSFixed64(Lte);
      }
      if (HasGt) {
        output.WriteRawTag(33);
        output.WriteSFixed64(Gt);
      }
      if (HasGte) {
        output.WriteRawTag(41);
        output.WriteSFixed64(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 8;
      }
      if (HasLt) {
        size += 1 + 8;
      }
      if (HasLte) {
        size += 1 + 8;
      }
      if (HasGt) {
        size += 1 + 8;
      }
      if (HasGte) {
        size += 1 + 8;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SFixed64Rules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLt) {
        Lt = other.Lt;
      }
      if (other.HasLte) {
        Lte = other.Lte;
      }
      if (other.HasGt) {
        Gt = other.Gt;
      }
      if (other.HasGte) {
        Gte = other.Gte;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Const = input.ReadSFixed64();
            break;
          }
          case 17: {
            Lt = input.ReadSFixed64();
            break;
          }
          case 25: {
            Lte = input.ReadSFixed64();
            break;
          }
          case 33: {
            Gt = input.ReadSFixed64();
            break;
          }
          case 41: {
            Gte = input.ReadSFixed64();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            Const = input.ReadSFixed64();
            break;
          }
          case 17: {
            Lt = input.ReadSFixed64();
            break;
          }
          case 25: {
            Lte = input.ReadSFixed64();
            break;
          }
          case 33: {
            Gt = input.ReadSFixed64();
            break;
          }
          case 41: {
            Gte = input.ReadSFixed64();
            break;
          }
          case 50:
          case 49: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 58:
          case 57: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// BoolRules describes the constraints applied to `bool` values. These rules
  /// may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
  /// </summary>
  public sealed partial class BoolRules : pb::IMessage<BoolRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BoolRules> _parser = new pb::MessageParser<BoolRules>(() => new BoolRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BoolRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BoolRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BoolRules(BoolRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BoolRules Clone() {
      return new BoolRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static bool ConstDefaultValue = false;

    private bool const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified boolean value.
    ///If the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyBool {
    ///  // value must equal true
    ///   bool value = 1 [(buf.validate.field).bool.const = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BoolRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BoolRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteBool(Const);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteBool(Const);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BoolRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// StringRules describes the constraints applied to `string` values These
  /// rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
  /// </summary>
  public sealed partial class StringRules : pb::IMessage<StringRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StringRules> _parser = new pb::MessageParser<StringRules>(() => new StringRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StringRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StringRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StringRules(StringRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      len_ = other.len_;
      minLen_ = other.minLen_;
      maxLen_ = other.maxLen_;
      lenBytes_ = other.lenBytes_;
      minBytes_ = other.minBytes_;
      maxBytes_ = other.maxBytes_;
      pattern_ = other.pattern_;
      prefix_ = other.prefix_;
      suffix_ = other.suffix_;
      contains_ = other.contains_;
      notContains_ = other.notContains_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      strict_ = other.strict_;
      switch (other.WellKnownCase) {
        case WellKnownOneofCase.Email:
          Email = other.Email;
          break;
        case WellKnownOneofCase.Hostname:
          Hostname = other.Hostname;
          break;
        case WellKnownOneofCase.Ip:
          Ip = other.Ip;
          break;
        case WellKnownOneofCase.Ipv4:
          Ipv4 = other.Ipv4;
          break;
        case WellKnownOneofCase.Ipv6:
          Ipv6 = other.Ipv6;
          break;
        case WellKnownOneofCase.Uri:
          Uri = other.Uri;
          break;
        case WellKnownOneofCase.UriRef:
          UriRef = other.UriRef;
          break;
        case WellKnownOneofCase.Address:
          Address = other.Address;
          break;
        case WellKnownOneofCase.Uuid:
          Uuid = other.Uuid;
          break;
        case WellKnownOneofCase.WellKnownRegex:
          WellKnownRegex = other.WellKnownRegex;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StringRules Clone() {
      return new StringRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static string ConstDefaultValue = "";

    private string const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified value. If
    ///the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must equal `hello`
    ///   string value = 1 [(buf.validate.field).string.const = "hello"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Const {
      get { return const_ ?? ConstDefaultValue; }
      set {
        const_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return const_ != null; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      const_ = null;
    }

    /// <summary>Field number for the "len" field.</summary>
    public const int LenFieldNumber = 19;
    private readonly static ulong LenDefaultValue = 0UL;

    private ulong len_;
    /// <summary>
    ///`len` dictates that the field value must have the specified
    ///number of characters (Unicode code points), which may differ from the number
    ///of bytes in the string. If the field value does not meet the specified
    ///length, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be 5 characters
    ///   string value = 1 [(buf.validate.field).string.len = 5];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Len {
      get { if ((_hasBits0 & 16) != 0) { return len_; } else { return LenDefaultValue; } }
      set {
        _hasBits0 |= 16;
        len_ = value;
      }
    }
    /// <summary>Gets whether the "len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLen {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLen() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "min_len" field.</summary>
    public const int MinLenFieldNumber = 2;
    private readonly static ulong MinLenDefaultValue = 0UL;

    private ulong minLen_;
    /// <summary>
    ///`min_len` specifies that the field value must have at least the specified
    ///number of characters (Unicode code points), which may differ from the number
    ///of bytes in the string. If the field value contains fewer characters, an error
    ///message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be at least 3 characters
    ///   string value = 1 [(buf.validate.field).string.min_len = 3];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MinLen {
      get { if ((_hasBits0 & 1) != 0) { return minLen_; } else { return MinLenDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minLen_ = value;
      }
    }
    /// <summary>Gets whether the "min_len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinLen {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min_len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinLen() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "max_len" field.</summary>
    public const int MaxLenFieldNumber = 3;
    private readonly static ulong MaxLenDefaultValue = 0UL;

    private ulong maxLen_;
    /// <summary>
    ///`max_len` specifies that the field value must have no more than the specified
    ///number of characters (Unicode code points), which may differ from the
    ///number of bytes in the string. If the field value contains more characters,
    ///an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be at most 10 characters
    ///   string value = 1 [(buf.validate.field).string.max_len = 10];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxLen {
      get { if ((_hasBits0 & 2) != 0) { return maxLen_; } else { return MaxLenDefaultValue; } }
      set {
        _hasBits0 |= 2;
        maxLen_ = value;
      }
    }
    /// <summary>Gets whether the "max_len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxLen {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max_len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxLen() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "len_bytes" field.</summary>
    public const int LenBytesFieldNumber = 20;
    private readonly static ulong LenBytesDefaultValue = 0UL;

    private ulong lenBytes_;
    /// <summary>
    ///`len_bytes` dictates that the field value must have the specified number of
    ///bytes. If the field value does not match the specified length in bytes,
    ///an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be 6 bytes
    ///   string value = 1 [(buf.validate.field).string.len_bytes = 6];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong LenBytes {
      get { if ((_hasBits0 & 32) != 0) { return lenBytes_; } else { return LenBytesDefaultValue; } }
      set {
        _hasBits0 |= 32;
        lenBytes_ = value;
      }
    }
    /// <summary>Gets whether the "len_bytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLenBytes {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "len_bytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLenBytes() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "min_bytes" field.</summary>
    public const int MinBytesFieldNumber = 4;
    private readonly static ulong MinBytesDefaultValue = 0UL;

    private ulong minBytes_;
    /// <summary>
    ///`min_bytes` specifies that the field value must have at least the specified
    ///number of bytes. If the field value contains fewer bytes, an error message
    ///will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be at least 4 bytes
    ///   string value = 1 [(buf.validate.field).string.min_bytes = 4];
    ///}
    ///
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MinBytes {
      get { if ((_hasBits0 & 4) != 0) { return minBytes_; } else { return MinBytesDefaultValue; } }
      set {
        _hasBits0 |= 4;
        minBytes_ = value;
      }
    }
    /// <summary>Gets whether the "min_bytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinBytes {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "min_bytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinBytes() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_bytes" field.</summary>
    public const int MaxBytesFieldNumber = 5;
    private readonly static ulong MaxBytesDefaultValue = 0UL;

    private ulong maxBytes_;
    /// <summary>
    ///`max_bytes` specifies that the field value must have no more than the
    ///specified number of bytes. If the field value contains more bytes, an
    ///error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value length must be at most 8 bytes
    ///   string value = 1 [(buf.validate.field).string.max_bytes = 8];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxBytes {
      get { if ((_hasBits0 & 8) != 0) { return maxBytes_; } else { return MaxBytesDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxBytes_ = value;
      }
    }
    /// <summary>Gets whether the "max_bytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxBytes {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_bytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxBytes() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "pattern" field.</summary>
    public const int PatternFieldNumber = 6;
    private readonly static string PatternDefaultValue = "";

    private string pattern_;
    /// <summary>
    ///`pattern` specifies that the field value must match the specified
    ///regular expression (RE2 syntax), with the expression provided without any
    ///delimiters. If the field value doesn't match the regular expression, an
    ///error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value does not match regex pattern `^[a-zA-Z]//$`
    ///   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Pattern {
      get { return pattern_ ?? PatternDefaultValue; }
      set {
        pattern_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pattern" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPattern {
      get { return pattern_ != null; }
    }
    /// <summary>Clears the value of the "pattern" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPattern() {
      pattern_ = null;
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 7;
    private readonly static string PrefixDefaultValue = "";

    private string prefix_;
    /// <summary>
    ///`prefix` specifies that the field value must have the
    ///specified substring at the beginning of the string. If the field value
    ///doesn't start with the specified prefix, an error message will be
    ///generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value does not have prefix `pre`
    ///   string value = 1 [(buf.validate.field).string.prefix = "pre"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Prefix {
      get { return prefix_ ?? PrefixDefaultValue; }
      set {
        prefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "prefix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrefix {
      get { return prefix_ != null; }
    }
    /// <summary>Clears the value of the "prefix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrefix() {
      prefix_ = null;
    }

    /// <summary>Field number for the "suffix" field.</summary>
    public const int SuffixFieldNumber = 8;
    private readonly static string SuffixDefaultValue = "";

    private string suffix_;
    /// <summary>
    ///`suffix` specifies that the field value must have the
    ///specified substring at the end of the string. If the field value doesn't
    ///end with the specified suffix, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value does not have suffix `post`
    ///   string value = 1 [(buf.validate.field).string.suffix = "post"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Suffix {
      get { return suffix_ ?? SuffixDefaultValue; }
      set {
        suffix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "suffix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSuffix {
      get { return suffix_ != null; }
    }
    /// <summary>Clears the value of the "suffix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSuffix() {
      suffix_ = null;
    }

    /// <summary>Field number for the "contains" field.</summary>
    public const int ContainsFieldNumber = 9;
    private readonly static string ContainsDefaultValue = "";

    private string contains_;
    /// <summary>
    ///`contains` specifies that the field value must have the
    ///specified substring anywhere in the string. If the field value doesn't
    ///contain the specified substring, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value does not contain substring `inside`.
    ///   string value = 1 [(buf.validate.field).string.contains = "inside"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Contains {
      get { return contains_ ?? ContainsDefaultValue; }
      set {
        contains_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contains" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContains {
      get { return contains_ != null; }
    }
    /// <summary>Clears the value of the "contains" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContains() {
      contains_ = null;
    }

    /// <summary>Field number for the "not_contains" field.</summary>
    public const int NotContainsFieldNumber = 23;
    private readonly static string NotContainsDefaultValue = "";

    private string notContains_;
    /// <summary>
    ///`not_contains` specifies that the field value must not have the
    ///specified substring anywhere in the string. If the field value contains
    ///the specified substring, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value contains substring `inside`.
    ///   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NotContains {
      get { return notContains_ ?? NotContainsDefaultValue; }
      set {
        notContains_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "not_contains" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNotContains {
      get { return notContains_ != null; }
    }
    /// <summary>Clears the value of the "not_contains" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNotContains() {
      notContains_ = null;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_in_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> in_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///`in` specifies that the field value must be equal to one of the specified
    ///values. If the field value isn't one of the specified values, an error
    ///message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be in list ["apple", "banana"]
    ///  repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_notIn_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> notIn_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///`not_in` specifies that the field value cannot be equal to any
    ///of the specified values. If the field value is one of the specified values,
    ///an error message will be generated.
    ///```proto
    ///message MyString {
    ///  // value must not be in list ["orange", "grape"]
    ///  repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> NotIn {
      get { return notIn_; }
    }

    /// <summary>Field number for the "email" field.</summary>
    public const int EmailFieldNumber = 12;
    /// <summary>
    ///`email` specifies that the field value must be a valid email address
    ///(addr-spec only) as defined by [RFC 5322](https://tools.ietf.org/html/rfc5322#section-3.4.1).
    ///If the field value isn't a valid email address, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid email address
    ///   string value = 1 [(buf.validate.field).string.email = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Email {
      get { return HasEmail ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Email;
      }
    }
    /// <summary>Gets whether the "email" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEmail {
      get { return wellKnownCase_ == WellKnownOneofCase.Email; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "email" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEmail() {
      if (HasEmail) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "hostname" field.</summary>
    public const int HostnameFieldNumber = 13;
    /// <summary>
    ///`hostname` specifies that the field value must be a valid
    ///hostname as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5). This constraint doesn't support
    ///internationalized domain names (IDNs). If the field value isn't a
    ///valid hostname, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid hostname
    ///   string value = 1 [(buf.validate.field).string.hostname = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Hostname {
      get { return HasHostname ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Hostname;
      }
    }
    /// <summary>Gets whether the "hostname" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostname {
      get { return wellKnownCase_ == WellKnownOneofCase.Hostname; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "hostname" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostname() {
      if (HasHostname) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 14;
    /// <summary>
    ///`ip` specifies that the field value must be a valid IP
    ///(v4 or v6) address, without surrounding square brackets for IPv6 addresses.
    ///If the field value isn't a valid IP address, an error message will be
    ///generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid IP address
    ///   string value = 1 [(buf.validate.field).string.ip = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ip {
      get { return HasIp ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ip;
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return wellKnownCase_ == WellKnownOneofCase.Ip; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ip" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      if (HasIp) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "ipv4" field.</summary>
    public const int Ipv4FieldNumber = 15;
    /// <summary>
    ///`ipv4` specifies that the field value must be a valid IPv4
    ///address. If the field value isn't a valid IPv4 address, an error message
    ///will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid IPv4 address
    ///   string value = 1 [(buf.validate.field).string.ipv4 = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ipv4 {
      get { return HasIpv4 ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ipv4;
      }
    }
    /// <summary>Gets whether the "ipv4" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv4 {
      get { return wellKnownCase_ == WellKnownOneofCase.Ipv4; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ipv4" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv4() {
      if (HasIpv4) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "ipv6" field.</summary>
    public const int Ipv6FieldNumber = 16;
    /// <summary>
    ///`ipv6` specifies that the field value must be a valid
    ///IPv6 address, without surrounding square brackets. If the field value is
    ///not a valid IPv6 address, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid IPv6 address
    ///   string value = 1 [(buf.validate.field).string.ipv6 = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ipv6 {
      get { return HasIpv6 ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ipv6;
      }
    }
    /// <summary>Gets whether the "ipv6" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv6 {
      get { return wellKnownCase_ == WellKnownOneofCase.Ipv6; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ipv6" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv6() {
      if (HasIpv6) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 17;
    /// <summary>
    ///`uri` specifies that the field value must be a valid,
    ///absolute URI as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3). If the field value isn't a valid,
    ///absolute URI, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid URI
    ///   string value = 1 [(buf.validate.field).string.uri = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Uri {
      get { return HasUri ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Uri;
      }
    }
    /// <summary>Gets whether the "uri" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUri {
      get { return wellKnownCase_ == WellKnownOneofCase.Uri; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "uri" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUri() {
      if (HasUri) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "uri_ref" field.</summary>
    public const int UriRefFieldNumber = 18;
    /// <summary>
    ///`uri_ref` specifies that the field value must be a valid URI
    ///as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) and may be either relative or absolute. If the
    ///field value isn't a valid URI, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid URI
    ///   string value = 1 [(buf.validate.field).string.uri_ref = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UriRef {
      get { return HasUriRef ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.UriRef;
      }
    }
    /// <summary>Gets whether the "uri_ref" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUriRef {
      get { return wellKnownCase_ == WellKnownOneofCase.UriRef; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "uri_ref" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUriRef() {
      if (HasUriRef) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 21;
    /// <summary>
    ///`address` specifies that the field value must be either a valid hostname
    ///as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5)
    ///(which doesn't support internationalized domain names or IDNs) or a valid
    ///IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
    ///message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid hostname, or ip address
    ///   string value = 1 [(buf.validate.field).string.address = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Address {
      get { return HasAddress ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Address;
      }
    }
    /// <summary>Gets whether the "address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAddress {
      get { return wellKnownCase_ == WellKnownOneofCase.Address; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "address" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAddress() {
      if (HasAddress) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "uuid" field.</summary>
    public const int UuidFieldNumber = 22;
    /// <summary>
    ///`uuid` specifies that the field value must be a valid UUID as defined by
    ///[RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2). If the
    ///field value isn't a valid UUID, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid UUID
    ///   string value = 1 [(buf.validate.field).string.uuid = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Uuid {
      get { return HasUuid ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Uuid;
      }
    }
    /// <summary>Gets whether the "uuid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUuid {
      get { return wellKnownCase_ == WellKnownOneofCase.Uuid; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "uuid" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUuid() {
      if (HasUuid) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "well_known_regex" field.</summary>
    public const int WellKnownRegexFieldNumber = 24;
    /// <summary>
    ///`well_known_regex` specifies a common well-known pattern
    ///defined as a regex. If the field value doesn't match the well-known
    ///regex, an error message will be generated.
    ///
    ///```proto
    ///message MyString {
    ///  // value must be a valid HTTP header value
    ///   string value = 1 [(buf.validate.field).string.well_known_regex = 2];
    ///}
    ///```
    ///
    ///#### KnownRegex
    ///
    ///`well_known_regex` contains some well-known patterns.
    ///
    ///| Name                          | Number | Description                               |
    ///|-------------------------------|--------|-------------------------------------------|
    ///| KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
    ///| KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2)  |
    ///| KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4) |
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.KnownRegex WellKnownRegex {
      get { return HasWellKnownRegex ? (global::Buf.Validate.KnownRegex) wellKnown_ : global::Buf.Validate.KnownRegex.Unspecified; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.WellKnownRegex;
      }
    }
    /// <summary>Gets whether the "well_known_regex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWellKnownRegex {
      get { return wellKnownCase_ == WellKnownOneofCase.WellKnownRegex; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "well_known_regex" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWellKnownRegex() {
      if (HasWellKnownRegex) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "strict" field.</summary>
    public const int StrictFieldNumber = 25;
    private readonly static bool StrictDefaultValue = false;

    private bool strict_;
    /// <summary>
    ///This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
    ///enable strict header validation. By default, this is true, and HTTP header
    ///validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser
    ///validations that only disallow `\r\n\0` characters, which can be used to
    ///bypass header matching rules.
    ///
    ///```proto
    ///message MyString {
    ///   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
    ///   string value = 1 [(buf.validate.field).string.strict = false];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Strict {
      get { if ((_hasBits0 & 64) != 0) { return strict_; } else { return StrictDefaultValue; } }
      set {
        _hasBits0 |= 64;
        strict_ = value;
      }
    }
    /// <summary>Gets whether the "strict" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStrict {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "strict" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStrict() {
      _hasBits0 &= ~64;
    }

    private object wellKnown_;
    /// <summary>Enum of possible cases for the "well_known" oneof.</summary>
    public enum WellKnownOneofCase {
      None = 0,
      Email = 12,
      Hostname = 13,
      Ip = 14,
      Ipv4 = 15,
      Ipv6 = 16,
      Uri = 17,
      UriRef = 18,
      Address = 21,
      Uuid = 22,
      WellKnownRegex = 24,
    }
    private WellKnownOneofCase wellKnownCase_ = WellKnownOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WellKnownOneofCase WellKnownCase {
      get { return wellKnownCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWellKnown() {
      wellKnownCase_ = WellKnownOneofCase.None;
      wellKnown_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StringRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StringRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Len != other.Len) return false;
      if (MinLen != other.MinLen) return false;
      if (MaxLen != other.MaxLen) return false;
      if (LenBytes != other.LenBytes) return false;
      if (MinBytes != other.MinBytes) return false;
      if (MaxBytes != other.MaxBytes) return false;
      if (Pattern != other.Pattern) return false;
      if (Prefix != other.Prefix) return false;
      if (Suffix != other.Suffix) return false;
      if (Contains != other.Contains) return false;
      if (NotContains != other.NotContains) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      if (Email != other.Email) return false;
      if (Hostname != other.Hostname) return false;
      if (Ip != other.Ip) return false;
      if (Ipv4 != other.Ipv4) return false;
      if (Ipv6 != other.Ipv6) return false;
      if (Uri != other.Uri) return false;
      if (UriRef != other.UriRef) return false;
      if (Address != other.Address) return false;
      if (Uuid != other.Uuid) return false;
      if (WellKnownRegex != other.WellKnownRegex) return false;
      if (Strict != other.Strict) return false;
      if (WellKnownCase != other.WellKnownCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLen) hash ^= Len.GetHashCode();
      if (HasMinLen) hash ^= MinLen.GetHashCode();
      if (HasMaxLen) hash ^= MaxLen.GetHashCode();
      if (HasLenBytes) hash ^= LenBytes.GetHashCode();
      if (HasMinBytes) hash ^= MinBytes.GetHashCode();
      if (HasMaxBytes) hash ^= MaxBytes.GetHashCode();
      if (HasPattern) hash ^= Pattern.GetHashCode();
      if (HasPrefix) hash ^= Prefix.GetHashCode();
      if (HasSuffix) hash ^= Suffix.GetHashCode();
      if (HasContains) hash ^= Contains.GetHashCode();
      if (HasNotContains) hash ^= NotContains.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (HasEmail) hash ^= Email.GetHashCode();
      if (HasHostname) hash ^= Hostname.GetHashCode();
      if (HasIp) hash ^= Ip.GetHashCode();
      if (HasIpv4) hash ^= Ipv4.GetHashCode();
      if (HasIpv6) hash ^= Ipv6.GetHashCode();
      if (HasUri) hash ^= Uri.GetHashCode();
      if (HasUriRef) hash ^= UriRef.GetHashCode();
      if (HasAddress) hash ^= Address.GetHashCode();
      if (HasUuid) hash ^= Uuid.GetHashCode();
      if (HasWellKnownRegex) hash ^= WellKnownRegex.GetHashCode();
      if (HasStrict) hash ^= Strict.GetHashCode();
      hash ^= (int) wellKnownCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(10);
        output.WriteString(Const);
      }
      if (HasMinLen) {
        output.WriteRawTag(16);
        output.WriteUInt64(MinLen);
      }
      if (HasMaxLen) {
        output.WriteRawTag(24);
        output.WriteUInt64(MaxLen);
      }
      if (HasMinBytes) {
        output.WriteRawTag(32);
        output.WriteUInt64(MinBytes);
      }
      if (HasMaxBytes) {
        output.WriteRawTag(40);
        output.WriteUInt64(MaxBytes);
      }
      if (HasPattern) {
        output.WriteRawTag(50);
        output.WriteString(Pattern);
      }
      if (HasPrefix) {
        output.WriteRawTag(58);
        output.WriteString(Prefix);
      }
      if (HasSuffix) {
        output.WriteRawTag(66);
        output.WriteString(Suffix);
      }
      if (HasContains) {
        output.WriteRawTag(74);
        output.WriteString(Contains);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (HasEmail) {
        output.WriteRawTag(96);
        output.WriteBool(Email);
      }
      if (HasHostname) {
        output.WriteRawTag(104);
        output.WriteBool(Hostname);
      }
      if (HasIp) {
        output.WriteRawTag(112);
        output.WriteBool(Ip);
      }
      if (HasIpv4) {
        output.WriteRawTag(120);
        output.WriteBool(Ipv4);
      }
      if (HasIpv6) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Ipv6);
      }
      if (HasUri) {
        output.WriteRawTag(136, 1);
        output.WriteBool(Uri);
      }
      if (HasUriRef) {
        output.WriteRawTag(144, 1);
        output.WriteBool(UriRef);
      }
      if (HasLen) {
        output.WriteRawTag(152, 1);
        output.WriteUInt64(Len);
      }
      if (HasLenBytes) {
        output.WriteRawTag(160, 1);
        output.WriteUInt64(LenBytes);
      }
      if (HasAddress) {
        output.WriteRawTag(168, 1);
        output.WriteBool(Address);
      }
      if (HasUuid) {
        output.WriteRawTag(176, 1);
        output.WriteBool(Uuid);
      }
      if (HasNotContains) {
        output.WriteRawTag(186, 1);
        output.WriteString(NotContains);
      }
      if (HasWellKnownRegex) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) WellKnownRegex);
      }
      if (HasStrict) {
        output.WriteRawTag(200, 1);
        output.WriteBool(Strict);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(10);
        output.WriteString(Const);
      }
      if (HasMinLen) {
        output.WriteRawTag(16);
        output.WriteUInt64(MinLen);
      }
      if (HasMaxLen) {
        output.WriteRawTag(24);
        output.WriteUInt64(MaxLen);
      }
      if (HasMinBytes) {
        output.WriteRawTag(32);
        output.WriteUInt64(MinBytes);
      }
      if (HasMaxBytes) {
        output.WriteRawTag(40);
        output.WriteUInt64(MaxBytes);
      }
      if (HasPattern) {
        output.WriteRawTag(50);
        output.WriteString(Pattern);
      }
      if (HasPrefix) {
        output.WriteRawTag(58);
        output.WriteString(Prefix);
      }
      if (HasSuffix) {
        output.WriteRawTag(66);
        output.WriteString(Suffix);
      }
      if (HasContains) {
        output.WriteRawTag(74);
        output.WriteString(Contains);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (HasEmail) {
        output.WriteRawTag(96);
        output.WriteBool(Email);
      }
      if (HasHostname) {
        output.WriteRawTag(104);
        output.WriteBool(Hostname);
      }
      if (HasIp) {
        output.WriteRawTag(112);
        output.WriteBool(Ip);
      }
      if (HasIpv4) {
        output.WriteRawTag(120);
        output.WriteBool(Ipv4);
      }
      if (HasIpv6) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Ipv6);
      }
      if (HasUri) {
        output.WriteRawTag(136, 1);
        output.WriteBool(Uri);
      }
      if (HasUriRef) {
        output.WriteRawTag(144, 1);
        output.WriteBool(UriRef);
      }
      if (HasLen) {
        output.WriteRawTag(152, 1);
        output.WriteUInt64(Len);
      }
      if (HasLenBytes) {
        output.WriteRawTag(160, 1);
        output.WriteUInt64(LenBytes);
      }
      if (HasAddress) {
        output.WriteRawTag(168, 1);
        output.WriteBool(Address);
      }
      if (HasUuid) {
        output.WriteRawTag(176, 1);
        output.WriteBool(Uuid);
      }
      if (HasNotContains) {
        output.WriteRawTag(186, 1);
        output.WriteString(NotContains);
      }
      if (HasWellKnownRegex) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) WellKnownRegex);
      }
      if (HasStrict) {
        output.WriteRawTag(200, 1);
        output.WriteBool(Strict);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Const);
      }
      if (HasLen) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(Len);
      }
      if (HasMinLen) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MinLen);
      }
      if (HasMaxLen) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxLen);
      }
      if (HasLenBytes) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(LenBytes);
      }
      if (HasMinBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MinBytes);
      }
      if (HasMaxBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxBytes);
      }
      if (HasPattern) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pattern);
      }
      if (HasPrefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
      }
      if (HasSuffix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Suffix);
      }
      if (HasContains) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Contains);
      }
      if (HasNotContains) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(NotContains);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (HasEmail) {
        size += 1 + 1;
      }
      if (HasHostname) {
        size += 1 + 1;
      }
      if (HasIp) {
        size += 1 + 1;
      }
      if (HasIpv4) {
        size += 1 + 1;
      }
      if (HasIpv6) {
        size += 2 + 1;
      }
      if (HasUri) {
        size += 2 + 1;
      }
      if (HasUriRef) {
        size += 2 + 1;
      }
      if (HasAddress) {
        size += 2 + 1;
      }
      if (HasUuid) {
        size += 2 + 1;
      }
      if (HasWellKnownRegex) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) WellKnownRegex);
      }
      if (HasStrict) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StringRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLen) {
        Len = other.Len;
      }
      if (other.HasMinLen) {
        MinLen = other.MinLen;
      }
      if (other.HasMaxLen) {
        MaxLen = other.MaxLen;
      }
      if (other.HasLenBytes) {
        LenBytes = other.LenBytes;
      }
      if (other.HasMinBytes) {
        MinBytes = other.MinBytes;
      }
      if (other.HasMaxBytes) {
        MaxBytes = other.MaxBytes;
      }
      if (other.HasPattern) {
        Pattern = other.Pattern;
      }
      if (other.HasPrefix) {
        Prefix = other.Prefix;
      }
      if (other.HasSuffix) {
        Suffix = other.Suffix;
      }
      if (other.HasContains) {
        Contains = other.Contains;
      }
      if (other.HasNotContains) {
        NotContains = other.NotContains;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      if (other.HasStrict) {
        Strict = other.Strict;
      }
      switch (other.WellKnownCase) {
        case WellKnownOneofCase.Email:
          Email = other.Email;
          break;
        case WellKnownOneofCase.Hostname:
          Hostname = other.Hostname;
          break;
        case WellKnownOneofCase.Ip:
          Ip = other.Ip;
          break;
        case WellKnownOneofCase.Ipv4:
          Ipv4 = other.Ipv4;
          break;
        case WellKnownOneofCase.Ipv6:
          Ipv6 = other.Ipv6;
          break;
        case WellKnownOneofCase.Uri:
          Uri = other.Uri;
          break;
        case WellKnownOneofCase.UriRef:
          UriRef = other.UriRef;
          break;
        case WellKnownOneofCase.Address:
          Address = other.Address;
          break;
        case WellKnownOneofCase.Uuid:
          Uuid = other.Uuid;
          break;
        case WellKnownOneofCase.WellKnownRegex:
          WellKnownRegex = other.WellKnownRegex;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Const = input.ReadString();
            break;
          }
          case 16: {
            MinLen = input.ReadUInt64();
            break;
          }
          case 24: {
            MaxLen = input.ReadUInt64();
            break;
          }
          case 32: {
            MinBytes = input.ReadUInt64();
            break;
          }
          case 40: {
            MaxBytes = input.ReadUInt64();
            break;
          }
          case 50: {
            Pattern = input.ReadString();
            break;
          }
          case 58: {
            Prefix = input.ReadString();
            break;
          }
          case 66: {
            Suffix = input.ReadString();
            break;
          }
          case 74: {
            Contains = input.ReadString();
            break;
          }
          case 82: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 90: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
          case 96: {
            Email = input.ReadBool();
            break;
          }
          case 104: {
            Hostname = input.ReadBool();
            break;
          }
          case 112: {
            Ip = input.ReadBool();
            break;
          }
          case 120: {
            Ipv4 = input.ReadBool();
            break;
          }
          case 128: {
            Ipv6 = input.ReadBool();
            break;
          }
          case 136: {
            Uri = input.ReadBool();
            break;
          }
          case 144: {
            UriRef = input.ReadBool();
            break;
          }
          case 152: {
            Len = input.ReadUInt64();
            break;
          }
          case 160: {
            LenBytes = input.ReadUInt64();
            break;
          }
          case 168: {
            Address = input.ReadBool();
            break;
          }
          case 176: {
            Uuid = input.ReadBool();
            break;
          }
          case 186: {
            NotContains = input.ReadString();
            break;
          }
          case 192: {
            wellKnown_ = input.ReadEnum();
            wellKnownCase_ = WellKnownOneofCase.WellKnownRegex;
            break;
          }
          case 200: {
            Strict = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Const = input.ReadString();
            break;
          }
          case 16: {
            MinLen = input.ReadUInt64();
            break;
          }
          case 24: {
            MaxLen = input.ReadUInt64();
            break;
          }
          case 32: {
            MinBytes = input.ReadUInt64();
            break;
          }
          case 40: {
            MaxBytes = input.ReadUInt64();
            break;
          }
          case 50: {
            Pattern = input.ReadString();
            break;
          }
          case 58: {
            Prefix = input.ReadString();
            break;
          }
          case 66: {
            Suffix = input.ReadString();
            break;
          }
          case 74: {
            Contains = input.ReadString();
            break;
          }
          case 82: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 90: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
          case 96: {
            Email = input.ReadBool();
            break;
          }
          case 104: {
            Hostname = input.ReadBool();
            break;
          }
          case 112: {
            Ip = input.ReadBool();
            break;
          }
          case 120: {
            Ipv4 = input.ReadBool();
            break;
          }
          case 128: {
            Ipv6 = input.ReadBool();
            break;
          }
          case 136: {
            Uri = input.ReadBool();
            break;
          }
          case 144: {
            UriRef = input.ReadBool();
            break;
          }
          case 152: {
            Len = input.ReadUInt64();
            break;
          }
          case 160: {
            LenBytes = input.ReadUInt64();
            break;
          }
          case 168: {
            Address = input.ReadBool();
            break;
          }
          case 176: {
            Uuid = input.ReadBool();
            break;
          }
          case 186: {
            NotContains = input.ReadString();
            break;
          }
          case 192: {
            wellKnown_ = input.ReadEnum();
            wellKnownCase_ = WellKnownOneofCase.WellKnownRegex;
            break;
          }
          case 200: {
            Strict = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// BytesRules describe the constraints applied to `bytes` values. These rules
  /// may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
  /// </summary>
  public sealed partial class BytesRules : pb::IMessage<BytesRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BytesRules> _parser = new pb::MessageParser<BytesRules>(() => new BytesRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BytesRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BytesRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BytesRules(BytesRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      len_ = other.len_;
      minLen_ = other.minLen_;
      maxLen_ = other.maxLen_;
      pattern_ = other.pattern_;
      prefix_ = other.prefix_;
      suffix_ = other.suffix_;
      contains_ = other.contains_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      switch (other.WellKnownCase) {
        case WellKnownOneofCase.Ip:
          Ip = other.Ip;
          break;
        case WellKnownOneofCase.Ipv4:
          Ipv4 = other.Ipv4;
          break;
        case WellKnownOneofCase.Ipv6:
          Ipv6 = other.Ipv6;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BytesRules Clone() {
      return new BytesRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static pb::ByteString ConstDefaultValue = pb::ByteString.Empty;

    private pb::ByteString const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified bytes
    ///value. If the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    ///  // value must be "\x01\x02\x03\x04"
    ///   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Const {
      get { return const_ ?? ConstDefaultValue; }
      set {
        const_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return const_ != null; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      const_ = null;
    }

    /// <summary>Field number for the "len" field.</summary>
    public const int LenFieldNumber = 13;
    private readonly static ulong LenDefaultValue = 0UL;

    private ulong len_;
    /// <summary>
    ///`len` requires the field value to have the specified length in bytes.
    ///If the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    ///      // value length must be 4 bytes.
    ///      optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Len {
      get { if ((_hasBits0 & 4) != 0) { return len_; } else { return LenDefaultValue; } }
      set {
        _hasBits0 |= 4;
        len_ = value;
      }
    }
    /// <summary>Gets whether the "len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLen {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLen() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "min_len" field.</summary>
    public const int MinLenFieldNumber = 2;
    private readonly static ulong MinLenDefaultValue = 0UL;

    private ulong minLen_;
    /// <summary>
    ///`min_len` requires the field value to have at least the specified minimum
    ///length in bytes.
    ///If the field value doesn't meet the requirement, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value length must be at least 2 bytes.
    /// optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MinLen {
      get { if ((_hasBits0 & 1) != 0) { return minLen_; } else { return MinLenDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minLen_ = value;
      }
    }
    /// <summary>Gets whether the "min_len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinLen {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min_len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinLen() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "max_len" field.</summary>
    public const int MaxLenFieldNumber = 3;
    private readonly static ulong MaxLenDefaultValue = 0UL;

    private ulong maxLen_;
    /// <summary>
    ///`max_len` requires the field value to have at most the specified maximum
    ///length in bytes.
    ///If the field value exceeds the requirement, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value must be at most 6 bytes.
    /// optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxLen {
      get { if ((_hasBits0 & 2) != 0) { return maxLen_; } else { return MaxLenDefaultValue; } }
      set {
        _hasBits0 |= 2;
        maxLen_ = value;
      }
    }
    /// <summary>Gets whether the "max_len" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxLen {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max_len" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxLen() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "pattern" field.</summary>
    public const int PatternFieldNumber = 4;
    private readonly static string PatternDefaultValue = "";

    private string pattern_;
    /// <summary>
    ///`pattern` requires the field value to match the specified regular
    ///expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
    ///The value of the field must be valid UTF-8 or validation will fail with a
    ///runtime error.
    ///If the field value doesn't match the pattern, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value must match regex pattern "^[a-zA-Z0-9]+$".
    /// optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Pattern {
      get { return pattern_ ?? PatternDefaultValue; }
      set {
        pattern_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pattern" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPattern {
      get { return pattern_ != null; }
    }
    /// <summary>Clears the value of the "pattern" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPattern() {
      pattern_ = null;
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 5;
    private readonly static pb::ByteString PrefixDefaultValue = pb::ByteString.Empty;

    private pb::ByteString prefix_;
    /// <summary>
    ///`prefix` requires the field value to have the specified bytes at the
    ///beginning of the string.
    ///If the field value doesn't meet the requirement, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    ///// value does not have prefix \x01\x02
    ///optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Prefix {
      get { return prefix_ ?? PrefixDefaultValue; }
      set {
        prefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "prefix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrefix {
      get { return prefix_ != null; }
    }
    /// <summary>Clears the value of the "prefix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrefix() {
      prefix_ = null;
    }

    /// <summary>Field number for the "suffix" field.</summary>
    public const int SuffixFieldNumber = 6;
    private readonly static pb::ByteString SuffixDefaultValue = pb::ByteString.Empty;

    private pb::ByteString suffix_;
    /// <summary>
    ///`suffix` requires the field value to have the specified bytes at the end
    ///of the string.
    ///If the field value doesn't meet the requirement, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value does not have suffix \x03\x04
    /// optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Suffix {
      get { return suffix_ ?? SuffixDefaultValue; }
      set {
        suffix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "suffix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSuffix {
      get { return suffix_ != null; }
    }
    /// <summary>Clears the value of the "suffix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSuffix() {
      suffix_ = null;
    }

    /// <summary>Field number for the "contains" field.</summary>
    public const int ContainsFieldNumber = 7;
    private readonly static pb::ByteString ContainsDefaultValue = pb::ByteString.Empty;

    private pb::ByteString contains_;
    /// <summary>
    ///`contains` requires the field value to have the specified bytes anywhere in
    ///the string.
    ///If the field value doesn't meet the requirement, an error message is generated.
    ///
    ///```protobuf
    ///message MyBytes {
    /// // value does not contain \x02\x03
    /// optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Contains {
      get { return contains_ ?? ContainsDefaultValue; }
      set {
        contains_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contains" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContains {
      get { return contains_ != null; }
    }
    /// <summary>Clears the value of the "contains" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContains() {
      contains_ = null;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 8;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_in_codec
        = pb::FieldCodec.ForBytes(66);
    private readonly pbc::RepeatedField<pb::ByteString> in_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the specified
    ///values. If the field value doesn't match any of the specified values, an
    ///error message is generated.
    ///
    ///```protobuf
    ///message MyBytes {
    /// // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
    /// optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<pb::ByteString> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 9;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_notIn_codec
        = pb::FieldCodec.ForBytes(74);
    private readonly pbc::RepeatedField<pb::ByteString> notIn_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    ///`not_in` requires the field value to be not equal to any of the specified
    ///values.
    ///If the field value matches any of the specified values, an error message is
    ///generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
    /// optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<pb::ByteString> NotIn {
      get { return notIn_; }
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 10;
    /// <summary>
    ///`ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
    ///If the field value doesn't meet this constraint, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value must be a valid IP address
    /// optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ip {
      get { return HasIp ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ip;
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return wellKnownCase_ == WellKnownOneofCase.Ip; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ip" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      if (HasIp) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "ipv4" field.</summary>
    public const int Ipv4FieldNumber = 11;
    /// <summary>
    ///`ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
    ///If the field value doesn't meet this constraint, an error message is generated.
    ///
    ///```proto
    ///message MyBytes {
    /// // value must be a valid IPv4 address
    /// optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ipv4 {
      get { return HasIpv4 ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ipv4;
      }
    }
    /// <summary>Gets whether the "ipv4" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv4 {
      get { return wellKnownCase_ == WellKnownOneofCase.Ipv4; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ipv4" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv4() {
      if (HasIpv4) {
        ClearWellKnown();
      }
    }

    /// <summary>Field number for the "ipv6" field.</summary>
    public const int Ipv6FieldNumber = 12;
    /// <summary>
    ///`ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
    ///If the field value doesn't meet this constraint, an error message is generated.
    ///```proto
    ///message MyBytes {
    /// // value must be a valid IPv6 address
    /// optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ipv6 {
      get { return HasIpv6 ? (bool) wellKnown_ : false; }
      set {
        wellKnown_ = value;
        wellKnownCase_ = WellKnownOneofCase.Ipv6;
      }
    }
    /// <summary>Gets whether the "ipv6" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv6 {
      get { return wellKnownCase_ == WellKnownOneofCase.Ipv6; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ipv6" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv6() {
      if (HasIpv6) {
        ClearWellKnown();
      }
    }

    private object wellKnown_;
    /// <summary>Enum of possible cases for the "well_known" oneof.</summary>
    public enum WellKnownOneofCase {
      None = 0,
      Ip = 10,
      Ipv4 = 11,
      Ipv6 = 12,
    }
    private WellKnownOneofCase wellKnownCase_ = WellKnownOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WellKnownOneofCase WellKnownCase {
      get { return wellKnownCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWellKnown() {
      wellKnownCase_ = WellKnownOneofCase.None;
      wellKnown_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BytesRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BytesRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (Len != other.Len) return false;
      if (MinLen != other.MinLen) return false;
      if (MaxLen != other.MaxLen) return false;
      if (Pattern != other.Pattern) return false;
      if (Prefix != other.Prefix) return false;
      if (Suffix != other.Suffix) return false;
      if (Contains != other.Contains) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      if (Ip != other.Ip) return false;
      if (Ipv4 != other.Ipv4) return false;
      if (Ipv6 != other.Ipv6) return false;
      if (WellKnownCase != other.WellKnownCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasLen) hash ^= Len.GetHashCode();
      if (HasMinLen) hash ^= MinLen.GetHashCode();
      if (HasMaxLen) hash ^= MaxLen.GetHashCode();
      if (HasPattern) hash ^= Pattern.GetHashCode();
      if (HasPrefix) hash ^= Prefix.GetHashCode();
      if (HasSuffix) hash ^= Suffix.GetHashCode();
      if (HasContains) hash ^= Contains.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (HasIp) hash ^= Ip.GetHashCode();
      if (HasIpv4) hash ^= Ipv4.GetHashCode();
      if (HasIpv6) hash ^= Ipv6.GetHashCode();
      hash ^= (int) wellKnownCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(10);
        output.WriteBytes(Const);
      }
      if (HasMinLen) {
        output.WriteRawTag(16);
        output.WriteUInt64(MinLen);
      }
      if (HasMaxLen) {
        output.WriteRawTag(24);
        output.WriteUInt64(MaxLen);
      }
      if (HasPattern) {
        output.WriteRawTag(34);
        output.WriteString(Pattern);
      }
      if (HasPrefix) {
        output.WriteRawTag(42);
        output.WriteBytes(Prefix);
      }
      if (HasSuffix) {
        output.WriteRawTag(50);
        output.WriteBytes(Suffix);
      }
      if (HasContains) {
        output.WriteRawTag(58);
        output.WriteBytes(Contains);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (HasIp) {
        output.WriteRawTag(80);
        output.WriteBool(Ip);
      }
      if (HasIpv4) {
        output.WriteRawTag(88);
        output.WriteBool(Ipv4);
      }
      if (HasIpv6) {
        output.WriteRawTag(96);
        output.WriteBool(Ipv6);
      }
      if (HasLen) {
        output.WriteRawTag(104);
        output.WriteUInt64(Len);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(10);
        output.WriteBytes(Const);
      }
      if (HasMinLen) {
        output.WriteRawTag(16);
        output.WriteUInt64(MinLen);
      }
      if (HasMaxLen) {
        output.WriteRawTag(24);
        output.WriteUInt64(MaxLen);
      }
      if (HasPattern) {
        output.WriteRawTag(34);
        output.WriteString(Pattern);
      }
      if (HasPrefix) {
        output.WriteRawTag(42);
        output.WriteBytes(Prefix);
      }
      if (HasSuffix) {
        output.WriteRawTag(50);
        output.WriteBytes(Suffix);
      }
      if (HasContains) {
        output.WriteRawTag(58);
        output.WriteBytes(Contains);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (HasIp) {
        output.WriteRawTag(80);
        output.WriteBool(Ip);
      }
      if (HasIpv4) {
        output.WriteRawTag(88);
        output.WriteBool(Ipv4);
      }
      if (HasIpv6) {
        output.WriteRawTag(96);
        output.WriteBool(Ipv6);
      }
      if (HasLen) {
        output.WriteRawTag(104);
        output.WriteUInt64(Len);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Const);
      }
      if (HasLen) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Len);
      }
      if (HasMinLen) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MinLen);
      }
      if (HasMaxLen) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxLen);
      }
      if (HasPattern) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pattern);
      }
      if (HasPrefix) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Prefix);
      }
      if (HasSuffix) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Suffix);
      }
      if (HasContains) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Contains);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (HasIp) {
        size += 1 + 1;
      }
      if (HasIpv4) {
        size += 1 + 1;
      }
      if (HasIpv6) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BytesRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasLen) {
        Len = other.Len;
      }
      if (other.HasMinLen) {
        MinLen = other.MinLen;
      }
      if (other.HasMaxLen) {
        MaxLen = other.MaxLen;
      }
      if (other.HasPattern) {
        Pattern = other.Pattern;
      }
      if (other.HasPrefix) {
        Prefix = other.Prefix;
      }
      if (other.HasSuffix) {
        Suffix = other.Suffix;
      }
      if (other.HasContains) {
        Contains = other.Contains;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      switch (other.WellKnownCase) {
        case WellKnownOneofCase.Ip:
          Ip = other.Ip;
          break;
        case WellKnownOneofCase.Ipv4:
          Ipv4 = other.Ipv4;
          break;
        case WellKnownOneofCase.Ipv6:
          Ipv6 = other.Ipv6;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Const = input.ReadBytes();
            break;
          }
          case 16: {
            MinLen = input.ReadUInt64();
            break;
          }
          case 24: {
            MaxLen = input.ReadUInt64();
            break;
          }
          case 34: {
            Pattern = input.ReadString();
            break;
          }
          case 42: {
            Prefix = input.ReadBytes();
            break;
          }
          case 50: {
            Suffix = input.ReadBytes();
            break;
          }
          case 58: {
            Contains = input.ReadBytes();
            break;
          }
          case 66: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 74: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
          case 80: {
            Ip = input.ReadBool();
            break;
          }
          case 88: {
            Ipv4 = input.ReadBool();
            break;
          }
          case 96: {
            Ipv6 = input.ReadBool();
            break;
          }
          case 104: {
            Len = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Const = input.ReadBytes();
            break;
          }
          case 16: {
            MinLen = input.ReadUInt64();
            break;
          }
          case 24: {
            MaxLen = input.ReadUInt64();
            break;
          }
          case 34: {
            Pattern = input.ReadString();
            break;
          }
          case 42: {
            Prefix = input.ReadBytes();
            break;
          }
          case 50: {
            Suffix = input.ReadBytes();
            break;
          }
          case 58: {
            Contains = input.ReadBytes();
            break;
          }
          case 66: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 74: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
          case 80: {
            Ip = input.ReadBool();
            break;
          }
          case 88: {
            Ipv4 = input.ReadBool();
            break;
          }
          case 96: {
            Ipv6 = input.ReadBool();
            break;
          }
          case 104: {
            Len = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EnumRules describe the constraints applied to `enum` values.
  /// </summary>
  public sealed partial class EnumRules : pb::IMessage<EnumRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnumRules> _parser = new pb::MessageParser<EnumRules>(() => new EnumRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnumRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnumRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnumRules(EnumRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_;
      definedOnly_ = other.definedOnly_;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnumRules Clone() {
      return new EnumRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 1;
    private readonly static int ConstDefaultValue = 0;

    private int const_;
    /// <summary>
    ///`const` requires the field value to exactly match the specified enum value.
    ///If the field value doesn't match, an error message is generated.
    ///
    ///```proto
    ///enum MyEnum {
    ///  MY_ENUM_UNSPECIFIED = 0;
    ///  MY_ENUM_VALUE1 = 1;
    ///  MY_ENUM_VALUE2 = 2;
    ///}
    ///
    ///message MyMessage {
    ///  // The field `value` must be exactly MY_ENUM_VALUE1.
    ///   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Const {
      get { if ((_hasBits0 & 1) != 0) { return const_; } else { return ConstDefaultValue; } }
      set {
        _hasBits0 |= 1;
        const_ = value;
      }
    }
    /// <summary>Gets whether the "const" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConst {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "const" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConst() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "defined_only" field.</summary>
    public const int DefinedOnlyFieldNumber = 2;
    private readonly static bool DefinedOnlyDefaultValue = false;

    private bool definedOnly_;
    /// <summary>
    ///`defined_only` requires the field value to be one of the defined values for
    /// this enum, failing on any undefined value.
    ///
    ///```proto
    ///enum MyEnum {
    ///  MY_ENUM_UNSPECIFIED = 0;
    ///  MY_ENUM_VALUE1 = 1;
    ///  MY_ENUM_VALUE2 = 2;
    ///}
    ///
    ///message MyMessage {
    ///  // The field `value` must be a defined value of MyEnum.
    ///   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DefinedOnly {
      get { if ((_hasBits0 & 2) != 0) { return definedOnly_; } else { return DefinedOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        definedOnly_ = value;
      }
    }
    /// <summary>Gets whether the "defined_only" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefinedOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "defined_only" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefinedOnly() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_in_codec
        = pb::FieldCodec.ForInt32(26);
    private readonly pbc::RepeatedField<int> in_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`in` requires the field value to be equal to one of the
    ///specified enum values. If the field value doesn't match any of the
    ///specified values, an error message is generated.
    ///
    ///```proto
    ///enum MyEnum {
    ///  MY_ENUM_UNSPECIFIED = 0;
    ///  MY_ENUM_VALUE1 = 1;
    ///  MY_ENUM_VALUE2 = 2;
    ///}
    ///
    ///message MyMessage {
    ///  // The field `value` must be equal to one of the specified values.
    ///   MyEnum value = 1 [(buf.validate.field).enum.in = {1, 2}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 4;
    private static readonly pb::FieldCodec<int> _repeated_notIn_codec
        = pb::FieldCodec.ForInt32(34);
    private readonly pbc::RepeatedField<int> notIn_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///`not_in` requires the field value to be not equal to any of the
    ///specified enum values. If the field value matches one of the specified
    ///values, an error message is generated.
    ///
    ///```proto
    ///enum MyEnum {
    ///  MY_ENUM_UNSPECIFIED = 0;
    ///  MY_ENUM_VALUE1 = 1;
    ///  MY_ENUM_VALUE2 = 2;
    ///}
    ///
    ///message MyMessage {
    ///  // The field `value` must not be equal to any of the specified values.
    ///   MyEnum value = 1 [(buf.validate.field).enum.not_in = {1, 2}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnumRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnumRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Const != other.Const) return false;
      if (DefinedOnly != other.DefinedOnly) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConst) hash ^= Const.GetHashCode();
      if (HasDefinedOnly) hash ^= DefinedOnly.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt32(Const);
      }
      if (HasDefinedOnly) {
        output.WriteRawTag(16);
        output.WriteBool(DefinedOnly);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConst) {
        output.WriteRawTag(8);
        output.WriteInt32(Const);
      }
      if (HasDefinedOnly) {
        output.WriteRawTag(16);
        output.WriteBool(DefinedOnly);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConst) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Const);
      }
      if (HasDefinedOnly) {
        size += 1 + 1;
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnumRules other) {
      if (other == null) {
        return;
      }
      if (other.HasConst) {
        Const = other.Const;
      }
      if (other.HasDefinedOnly) {
        DefinedOnly = other.DefinedOnly;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Const = input.ReadInt32();
            break;
          }
          case 16: {
            DefinedOnly = input.ReadBool();
            break;
          }
          case 26:
          case 24: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 34:
          case 32: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Const = input.ReadInt32();
            break;
          }
          case 16: {
            DefinedOnly = input.ReadBool();
            break;
          }
          case 26:
          case 24: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 34:
          case 32: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// RepeatedRules describe the constraints applied to `repeated` values.
  /// </summary>
  public sealed partial class RepeatedRules : pb::IMessage<RepeatedRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RepeatedRules> _parser = new pb::MessageParser<RepeatedRules>(() => new RepeatedRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RepeatedRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RepeatedRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RepeatedRules(RepeatedRules other) : this() {
      _hasBits0 = other._hasBits0;
      minItems_ = other.minItems_;
      maxItems_ = other.maxItems_;
      unique_ = other.unique_;
      items_ = other.items_ != null ? other.items_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RepeatedRules Clone() {
      return new RepeatedRules(this);
    }

    /// <summary>Field number for the "min_items" field.</summary>
    public const int MinItemsFieldNumber = 1;
    private readonly static ulong MinItemsDefaultValue = 0UL;

    private ulong minItems_;
    /// <summary>
    ///`min_items` requires that this field must contain at least the specified
    ///minimum number of items.
    ///
    ///```proto
    ///message MyRepeated {
    ///  // value must contain at least  2 items
    ///  repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MinItems {
      get { if ((_hasBits0 & 1) != 0) { return minItems_; } else { return MinItemsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minItems_ = value;
      }
    }
    /// <summary>Gets whether the "min_items" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinItems {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min_items" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinItems() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "max_items" field.</summary>
    public const int MaxItemsFieldNumber = 2;
    private readonly static ulong MaxItemsDefaultValue = 0UL;

    private ulong maxItems_;
    /// <summary>
    ///`max_items` denotes that this field must not exceed a
    ///certain number of items as the upper limit. If the field contains more
    ///items than specified, an error message will be generated, requiring the
    ///field to maintain no more than the specified number of items.
    ///
    ///```proto
    ///message MyRepeated {
    ///  // value must contain no more than 3 item(s)
    ///  repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxItems {
      get { if ((_hasBits0 & 2) != 0) { return maxItems_; } else { return MaxItemsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        maxItems_ = value;
      }
    }
    /// <summary>Gets whether the "max_items" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxItems {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max_items" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxItems() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "unique" field.</summary>
    public const int UniqueFieldNumber = 3;
    private readonly static bool UniqueDefaultValue = false;

    private bool unique_;
    /// <summary>
    ///`unique` indicates that all elements in this field must
    ///be unique. This constraint is strictly applicable to scalar and enum
    ///types, with message types not being supported.
    ///
    ///```proto
    ///message MyRepeated {
    /// // repeated value must contain unique items
    /// repeated string value = 1 [(buf.validate.field).repeated.unique = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Unique {
      get { if ((_hasBits0 & 4) != 0) { return unique_; } else { return UniqueDefaultValue; } }
      set {
        _hasBits0 |= 4;
        unique_ = value;
      }
    }
    /// <summary>Gets whether the "unique" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUnique {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "unique" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUnique() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 4;
    private global::Buf.Validate.FieldConstraints items_;
    /// <summary>
    ///`items` details the constraints to be applied to each item
    ///in the field. Even for repeated message fields, validation is executed
    ///against each item unless skip is explicitly specified.
    ///
    ///```proto
    ///message MyRepeated {
    ///  // The items in the field `value` must follow the specified constraints.
    ///  repeated string value = 1 [(buf.validate.field).repeated.items = {
    ///    string: {
    ///      min_len: 3
    ///      max_len: 10
    ///    }
    ///  }];
    ///}
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.FieldConstraints Items {
      get { return items_; }
      set {
        items_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RepeatedRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RepeatedRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinItems != other.MinItems) return false;
      if (MaxItems != other.MaxItems) return false;
      if (Unique != other.Unique) return false;
      if (!object.Equals(Items, other.Items)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMinItems) hash ^= MinItems.GetHashCode();
      if (HasMaxItems) hash ^= MaxItems.GetHashCode();
      if (HasUnique) hash ^= Unique.GetHashCode();
      if (items_ != null) hash ^= Items.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMinItems) {
        output.WriteRawTag(8);
        output.WriteUInt64(MinItems);
      }
      if (HasMaxItems) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxItems);
      }
      if (HasUnique) {
        output.WriteRawTag(24);
        output.WriteBool(Unique);
      }
      if (items_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Items);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMinItems) {
        output.WriteRawTag(8);
        output.WriteUInt64(MinItems);
      }
      if (HasMaxItems) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxItems);
      }
      if (HasUnique) {
        output.WriteRawTag(24);
        output.WriteBool(Unique);
      }
      if (items_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Items);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMinItems) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MinItems);
      }
      if (HasMaxItems) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxItems);
      }
      if (HasUnique) {
        size += 1 + 1;
      }
      if (items_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Items);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RepeatedRules other) {
      if (other == null) {
        return;
      }
      if (other.HasMinItems) {
        MinItems = other.MinItems;
      }
      if (other.HasMaxItems) {
        MaxItems = other.MaxItems;
      }
      if (other.HasUnique) {
        Unique = other.Unique;
      }
      if (other.items_ != null) {
        if (items_ == null) {
          Items = new global::Buf.Validate.FieldConstraints();
        }
        Items.MergeFrom(other.Items);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MinItems = input.ReadUInt64();
            break;
          }
          case 16: {
            MaxItems = input.ReadUInt64();
            break;
          }
          case 24: {
            Unique = input.ReadBool();
            break;
          }
          case 34: {
            if (items_ == null) {
              Items = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Items);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MinItems = input.ReadUInt64();
            break;
          }
          case 16: {
            MaxItems = input.ReadUInt64();
            break;
          }
          case 24: {
            Unique = input.ReadBool();
            break;
          }
          case 34: {
            if (items_ == null) {
              Items = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Items);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// MapRules describe the constraints applied to `map` values.
  /// </summary>
  public sealed partial class MapRules : pb::IMessage<MapRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MapRules> _parser = new pb::MessageParser<MapRules>(() => new MapRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MapRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MapRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MapRules(MapRules other) : this() {
      _hasBits0 = other._hasBits0;
      minPairs_ = other.minPairs_;
      maxPairs_ = other.maxPairs_;
      keys_ = other.keys_ != null ? other.keys_.Clone() : null;
      values_ = other.values_ != null ? other.values_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MapRules Clone() {
      return new MapRules(this);
    }

    /// <summary>Field number for the "min_pairs" field.</summary>
    public const int MinPairsFieldNumber = 1;
    private readonly static ulong MinPairsDefaultValue = 0UL;

    private ulong minPairs_;
    /// <summary>
    ///Specifies the minimum number of key-value pairs allowed. If the field has
    ///fewer key-value pairs than specified, an error message is generated.
    ///
    ///```proto
    ///message MyMap {
    ///  // The field `value` must have at least 2 key-value pairs.
    ///  map&lt;string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MinPairs {
      get { if ((_hasBits0 & 1) != 0) { return minPairs_; } else { return MinPairsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minPairs_ = value;
      }
    }
    /// <summary>Gets whether the "min_pairs" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinPairs {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min_pairs" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinPairs() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "max_pairs" field.</summary>
    public const int MaxPairsFieldNumber = 2;
    private readonly static ulong MaxPairsDefaultValue = 0UL;

    private ulong maxPairs_;
    /// <summary>
    ///Specifies the maximum number of key-value pairs allowed. If the field has
    ///more key-value pairs than specified, an error message is generated.
    ///
    ///```proto
    ///message MyMap {
    ///  // The field `value` must have at most 3 key-value pairs.
    ///  map&lt;string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxPairs {
      get { if ((_hasBits0 & 2) != 0) { return maxPairs_; } else { return MaxPairsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        maxPairs_ = value;
      }
    }
    /// <summary>Gets whether the "max_pairs" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxPairs {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max_pairs" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxPairs() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 4;
    private global::Buf.Validate.FieldConstraints keys_;
    /// <summary>
    ///Specifies the constraints to be applied to each key in the field.
    ///
    ///```proto
    ///message MyMap {
    ///  // The keys in the field `value` must follow the specified constraints.
    ///  map&lt;string, string> value = 1 [(buf.validate.field).map.keys = {
    ///    string: {
    ///      min_len: 3
    ///      max_len: 10
    ///    }
    ///  }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.FieldConstraints Keys {
      get { return keys_; }
      set {
        keys_ = value;
      }
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 5;
    private global::Buf.Validate.FieldConstraints values_;
    /// <summary>
    ///Specifies the constraints to be applied to the value of each key in the
    ///field. Message values will still have their validations evaluated unless
    ///skip is specified here.
    ///
    ///```proto
    ///message MyMap {
    ///  // The values in the field `value` must follow the specified constraints.
    ///  map&lt;string, string> value = 1 [(buf.validate.field).map.values = {
    ///    string: {
    ///      min_len: 5
    ///      max_len: 20
    ///    }
    ///  }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Buf.Validate.FieldConstraints Values {
      get { return values_; }
      set {
        values_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MapRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MapRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinPairs != other.MinPairs) return false;
      if (MaxPairs != other.MaxPairs) return false;
      if (!object.Equals(Keys, other.Keys)) return false;
      if (!object.Equals(Values, other.Values)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMinPairs) hash ^= MinPairs.GetHashCode();
      if (HasMaxPairs) hash ^= MaxPairs.GetHashCode();
      if (keys_ != null) hash ^= Keys.GetHashCode();
      if (values_ != null) hash ^= Values.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMinPairs) {
        output.WriteRawTag(8);
        output.WriteUInt64(MinPairs);
      }
      if (HasMaxPairs) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxPairs);
      }
      if (keys_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Keys);
      }
      if (values_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Values);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMinPairs) {
        output.WriteRawTag(8);
        output.WriteUInt64(MinPairs);
      }
      if (HasMaxPairs) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxPairs);
      }
      if (keys_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Keys);
      }
      if (values_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Values);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMinPairs) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MinPairs);
      }
      if (HasMaxPairs) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxPairs);
      }
      if (keys_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Keys);
      }
      if (values_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MapRules other) {
      if (other == null) {
        return;
      }
      if (other.HasMinPairs) {
        MinPairs = other.MinPairs;
      }
      if (other.HasMaxPairs) {
        MaxPairs = other.MaxPairs;
      }
      if (other.keys_ != null) {
        if (keys_ == null) {
          Keys = new global::Buf.Validate.FieldConstraints();
        }
        Keys.MergeFrom(other.Keys);
      }
      if (other.values_ != null) {
        if (values_ == null) {
          Values = new global::Buf.Validate.FieldConstraints();
        }
        Values.MergeFrom(other.Values);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MinPairs = input.ReadUInt64();
            break;
          }
          case 16: {
            MaxPairs = input.ReadUInt64();
            break;
          }
          case 34: {
            if (keys_ == null) {
              Keys = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Keys);
            break;
          }
          case 42: {
            if (values_ == null) {
              Values = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Values);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MinPairs = input.ReadUInt64();
            break;
          }
          case 16: {
            MaxPairs = input.ReadUInt64();
            break;
          }
          case 34: {
            if (keys_ == null) {
              Keys = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Keys);
            break;
          }
          case 42: {
            if (values_ == null) {
              Values = new global::Buf.Validate.FieldConstraints();
            }
            input.ReadMessage(Values);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AnyRules describe constraints applied exclusively to the `google.protobuf.Any` well-known type.
  /// </summary>
  public sealed partial class AnyRules : pb::IMessage<AnyRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AnyRules> _parser = new pb::MessageParser<AnyRules>(() => new AnyRules());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AnyRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AnyRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AnyRules(AnyRules other) : this() {
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AnyRules Clone() {
      return new AnyRules(this);
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_in_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> in_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///`in` requires the field's `type_url` to be equal to one of the
    ///specified values. If it doesn't match any of the specified values, an error
    ///message is generated.
    ///
    ///```proto
    ///message MyAny {
    ///  //  The `value` field must have a `type_url` equal to one of the specified values.
    ///   google.protobuf.Any value = 1 [(buf.validate.field).any.in = ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_notIn_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> notIn_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
    ///
    ///```proto
    ///message MyAny {
    ///  // The field `value` must not have a `type_url` equal to any of the specified values.
    ///   google.protobuf.Any value = 1 [(buf.validate.field).any.not_in = ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AnyRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AnyRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AnyRules other) {
      if (other == null) {
        return;
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 26: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 26: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// DurationRules describe the constraints applied exclusively to the `google.protobuf.Duration` well-known type.
  /// </summary>
  public sealed partial class DurationRules : pb::IMessage<DurationRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DurationRules> _parser = new pb::MessageParser<DurationRules>(() => new DurationRules());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DurationRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DurationRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DurationRules(DurationRules other) : this() {
      const_ = other.const_ != null ? other.const_.Clone() : null;
      lt_ = other.lt_ != null ? other.lt_.Clone() : null;
      lte_ = other.lte_ != null ? other.lte_.Clone() : null;
      gt_ = other.gt_ != null ? other.gt_.Clone() : null;
      gte_ = other.gte_ != null ? other.gte_.Clone() : null;
      in_ = other.in_.Clone();
      notIn_ = other.notIn_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DurationRules Clone() {
      return new DurationRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration const_;
    /// <summary>
    ///`const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
    ///If the field's value deviates from the specified value, an error message
    ///will be generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // value must equal 5s
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Const {
      get { return const_; }
      set {
        const_ = value;
      }
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration lt_;
    /// <summary>
    ///`lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
    ///exclusive. If the field's value is greater than or equal to the specified
    ///value, an error message will be generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // value must be less than 5s
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Lt {
      get { return lt_; }
      set {
        lt_ = value;
      }
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration lte_;
    /// <summary>
    ///`lte` indicates that the field must be less than or equal to the specified
    ///value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
    ///an error message will be generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // value must be less than or equal to 10s
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Lte {
      get { return lte_; }
      set {
        lte_ = value;
      }
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration gt_;
    /// <summary>
    /// `gt` requires the duration field value to be greater than the specified
    /// value (exclusive). If the value of `gt` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // duration must be greater than 5s [duration.gt]
    ///  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
    ///
    ///  // duration must be greater than 5s and less than 10s [duration.gt_lt]
    ///  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
    ///
    ///  // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
    ///  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Gt {
      get { return gt_; }
      set {
        gt_ = value;
      }
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Duration gte_;
    /// <summary>
    /// `gte` requires the duration field value to be greater than or equal to the
    /// specified value (exclusive). If the value of `gte` is larger than a
    /// specified `lt` or `lte`, the range is reversed, and the field value must
    /// be outside the specified range. If the field value doesn't meet the
    /// required conditions, an error message is generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // duration must be greater than or equal to 5s [duration.gte]
    ///  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
    ///
    ///  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
    ///  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
    ///
    ///  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
    ///  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Gte {
      get { return gte_; }
      set {
        gte_ = value;
      }
    }

    /// <summary>Field number for the "in" field.</summary>
    public const int InFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Duration> _repeated_in_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Protobuf.WellKnownTypes.Duration.Parser);
    private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> in_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration>();
    /// <summary>
    ///`in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
    ///If the field's value doesn't correspond to any of the specified values,
    ///an error message will be generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // value must be in list [1s, 2s, 3s]
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> In {
      get { return in_; }
    }

    /// <summary>Field number for the "not_in" field.</summary>
    public const int NotInFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Duration> _repeated_notIn_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Protobuf.WellKnownTypes.Duration.Parser);
    private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> notIn_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration>();
    /// <summary>
    ///`not_in` denotes that the field must not be equal to
    ///any of the specified values of the `google.protobuf.Duration` type.
    ///If the field's value matches any of these values, an error message will be
    ///generated.
    ///
    ///```proto
    ///message MyDuration {
    ///  // value must not be in list [1s, 2s, 3s]
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> NotIn {
      get { return notIn_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DurationRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DurationRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Const, other.Const)) return false;
      if (!object.Equals(Lt, other.Lt)) return false;
      if (!object.Equals(Lte, other.Lte)) return false;
      if (!object.Equals(Gt, other.Gt)) return false;
      if (!object.Equals(Gte, other.Gte)) return false;
      if(!in_.Equals(other.in_)) return false;
      if(!notIn_.Equals(other.notIn_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (const_ != null) hash ^= Const.GetHashCode();
      if (lt_ != null) hash ^= Lt.GetHashCode();
      if (lte_ != null) hash ^= Lte.GetHashCode();
      if (gt_ != null) hash ^= Gt.GetHashCode();
      if (gte_ != null) hash ^= Gte.GetHashCode();
      hash ^= in_.GetHashCode();
      hash ^= notIn_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (const_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Const);
      }
      if (lt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Lt);
      }
      if (lte_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lte);
      }
      if (gt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Gt);
      }
      if (gte_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Gte);
      }
      in_.WriteTo(output, _repeated_in_codec);
      notIn_.WriteTo(output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (const_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Const);
      }
      if (lt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Lt);
      }
      if (lte_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lte);
      }
      if (gt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Gt);
      }
      if (gte_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Gte);
      }
      in_.WriteTo(ref output, _repeated_in_codec);
      notIn_.WriteTo(ref output, _repeated_notIn_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (const_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Const);
      }
      if (lt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lt);
      }
      if (lte_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lte);
      }
      if (gt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gt);
      }
      if (gte_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gte);
      }
      size += in_.CalculateSize(_repeated_in_codec);
      size += notIn_.CalculateSize(_repeated_notIn_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DurationRules other) {
      if (other == null) {
        return;
      }
      if (other.const_ != null) {
        if (const_ == null) {
          Const = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Const.MergeFrom(other.Const);
      }
      if (other.lt_ != null) {
        if (lt_ == null) {
          Lt = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lt.MergeFrom(other.Lt);
      }
      if (other.lte_ != null) {
        if (lte_ == null) {
          Lte = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lte.MergeFrom(other.Lte);
      }
      if (other.gt_ != null) {
        if (gt_ == null) {
          Gt = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Gt.MergeFrom(other.Gt);
      }
      if (other.gte_ != null) {
        if (gte_ == null) {
          Gte = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Gte.MergeFrom(other.Gte);
      }
      in_.Add(other.in_);
      notIn_.Add(other.notIn_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (const_ == null) {
              Const = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Const);
            break;
          }
          case 26: {
            if (lt_ == null) {
              Lt = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lt);
            break;
          }
          case 34: {
            if (lte_ == null) {
              Lte = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lte);
            break;
          }
          case 42: {
            if (gt_ == null) {
              Gt = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Gt);
            break;
          }
          case 50: {
            if (gte_ == null) {
              Gte = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Gte);
            break;
          }
          case 58: {
            in_.AddEntriesFrom(input, _repeated_in_codec);
            break;
          }
          case 66: {
            notIn_.AddEntriesFrom(input, _repeated_notIn_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (const_ == null) {
              Const = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Const);
            break;
          }
          case 26: {
            if (lt_ == null) {
              Lt = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lt);
            break;
          }
          case 34: {
            if (lte_ == null) {
              Lte = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lte);
            break;
          }
          case 42: {
            if (gt_ == null) {
              Gt = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Gt);
            break;
          }
          case 50: {
            if (gte_ == null) {
              Gte = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Gte);
            break;
          }
          case 58: {
            in_.AddEntriesFrom(ref input, _repeated_in_codec);
            break;
          }
          case 66: {
            notIn_.AddEntriesFrom(ref input, _repeated_notIn_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// TimestampRules describe the constraints applied exclusively to the `google.protobuf.Timestamp` well-known type.
  /// </summary>
  public sealed partial class TimestampRules : pb::IMessage<TimestampRules>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TimestampRules> _parser = new pb::MessageParser<TimestampRules>(() => new TimestampRules());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TimestampRules> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Buf.Validate.ValidateReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimestampRules() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimestampRules(TimestampRules other) : this() {
      _hasBits0 = other._hasBits0;
      const_ = other.const_ != null ? other.const_.Clone() : null;
      lt_ = other.lt_ != null ? other.lt_.Clone() : null;
      lte_ = other.lte_ != null ? other.lte_.Clone() : null;
      gt_ = other.gt_ != null ? other.gt_.Clone() : null;
      gte_ = other.gte_ != null ? other.gte_.Clone() : null;
      ltNow_ = other.ltNow_;
      gtNow_ = other.gtNow_;
      within_ = other.within_ != null ? other.within_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimestampRules Clone() {
      return new TimestampRules(this);
    }

    /// <summary>Field number for the "const" field.</summary>
    public const int ConstFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp const_;
    /// <summary>
    ///`const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // value must equal 2023-05-03T10:00:00Z
    ///   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Const {
      get { return const_; }
      set {
        const_ = value;
      }
    }

    /// <summary>Field number for the "lt" field.</summary>
    public const int LtFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp lt_;
    /// <summary>
    /// requires the duration field value to be less than the specified value (field &lt; value). If the field value doesn't meet the required conditions, an error message is generated.
    ///
    /// ```proto
    /// message MyDuration {
    ///   // duration must be less than 'P3D' [duration.lt]
    ///   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
    /// }
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Lt {
      get { return lt_; }
      set {
        lt_ = value;
      }
    }

    /// <summary>Field number for the "lte" field.</summary>
    public const int LteFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp lte_;
    /// <summary>
    /// requires the timestamp field value to be less than or equal to the specified value (field &lt;= value). If the field value doesn't meet the required conditions, an error message is generated.
    ///
    /// ```proto
    /// message MyTimestamp {
    ///   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
    ///   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
    /// }
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Lte {
      get { return lte_; }
      set {
        lte_ = value;
      }
    }

    /// <summary>Field number for the "gt" field.</summary>
    public const int GtFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp gt_;
    /// <summary>
    ///`gt` requires the timestamp field value to be greater than the specified
    /// value (exclusive). If the value of `gt` is larger than a specified `lt`
    /// or `lte`, the range is reversed, and the field value must be outside the
    /// specified range. If the field value doesn't meet the required conditions,
    /// an error message is generated.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
    ///  google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
    ///
    ///  // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
    ///  google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    ///
    ///  // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
    ///  google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Gt {
      get { return gt_; }
      set {
        gt_ = value;
      }
    }

    /// <summary>Field number for the "gte" field.</summary>
    public const int GteFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp gte_;
    /// <summary>
    ///`gte` requires the timestamp field value to be greater than or equal to the
    /// specified value (exclusive). If the value of `gte` is larger than a
    /// specified `lt` or `lte`, the range is reversed, and the field value
    /// must be outside the specified range. If the field value doesn't meet
    /// the required conditions, an error message is generated.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
    ///  google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
    ///
    ///  // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
    ///  google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    ///
    ///  // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
    ///  google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Gte {
      get { return gte_; }
      set {
        gte_ = value;
      }
    }

    /// <summary>Field number for the "lt_now" field.</summary>
    public const int LtNowFieldNumber = 7;
    private readonly static bool LtNowDefaultValue = false;

    private bool ltNow_;
    /// <summary>
    ///`lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // value must be less than now
    ///   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool LtNow {
      get { if ((_hasBits0 & 1) != 0) { return ltNow_; } else { return LtNowDefaultValue; } }
      set {
        _hasBits0 |= 1;
        ltNow_ = value;
      }
    }
    /// <summary>Gets whether the "lt_now" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLtNow {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "lt_now" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLtNow() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "gt_now" field.</summary>
    public const int GtNowFieldNumber = 8;
    private readonly static bool GtNowDefaultValue = false;

    private bool gtNow_;
    /// <summary>
    ///`gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // value must be greater than now
    ///   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool GtNow {
      get { if ((_hasBits0 & 2) != 0) { return gtNow_; } else { return GtNowDefaultValue; } }
      set {
        _hasBits0 |= 2;
        gtNow_ = value;
      }
    }
    /// <summary>Gets whether the "gt_now" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGtNow {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "gt_now" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGtNow() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "within" field.</summary>
    public const int WithinFieldNumber = 9;
    private global::Google.Protobuf.WellKnownTypes.Duration within_;
    /// <summary>
    /// `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
    ///
    ///```proto
    ///message MyTimestamp {
    ///  // value must be within 1 hour of now
    ///   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
    ///}
    ///```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Within {
      get { return within_; }
      set {
        within_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TimestampRules);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TimestampRules other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Const, other.Const)) return false;
      if (!object.Equals(Lt, other.Lt)) return false;
      if (!object.Equals(Lte, other.Lte)) return false;
      if (!object.Equals(Gt, other.Gt)) return false;
      if (!object.Equals(Gte, other.Gte)) return false;
      if (LtNow != other.LtNow) return false;
      if (GtNow != other.GtNow) return false;
      if (!object.Equals(Within, other.Within)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (const_ != null) hash ^= Const.GetHashCode();
      if (lt_ != null) hash ^= Lt.GetHashCode();
      if (lte_ != null) hash ^= Lte.GetHashCode();
      if (gt_ != null) hash ^= Gt.GetHashCode();
      if (gte_ != null) hash ^= Gte.GetHashCode();
      if (HasLtNow) hash ^= LtNow.GetHashCode();
      if (HasGtNow) hash ^= GtNow.GetHashCode();
      if (within_ != null) hash ^= Within.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (const_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Const);
      }
      if (lt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Lt);
      }
      if (lte_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lte);
      }
      if (gt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Gt);
      }
      if (gte_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Gte);
      }
      if (HasLtNow) {
        output.WriteRawTag(56);
        output.WriteBool(LtNow);
      }
      if (HasGtNow) {
        output.WriteRawTag(64);
        output.WriteBool(GtNow);
      }
      if (within_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Within);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (const_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Const);
      }
      if (lt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Lt);
      }
      if (lte_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lte);
      }
      if (gt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Gt);
      }
      if (gte_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Gte);
      }
      if (HasLtNow) {
        output.WriteRawTag(56);
        output.WriteBool(LtNow);
      }
      if (HasGtNow) {
        output.WriteRawTag(64);
        output.WriteBool(GtNow);
      }
      if (within_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Within);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (const_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Const);
      }
      if (lt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lt);
      }
      if (lte_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lte);
      }
      if (gt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gt);
      }
      if (gte_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gte);
      }
      if (HasLtNow) {
        size += 1 + 1;
      }
      if (HasGtNow) {
        size += 1 + 1;
      }
      if (within_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Within);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TimestampRules other) {
      if (other == null) {
        return;
      }
      if (other.const_ != null) {
        if (const_ == null) {
          Const = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Const.MergeFrom(other.Const);
      }
      if (other.lt_ != null) {
        if (lt_ == null) {
          Lt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Lt.MergeFrom(other.Lt);
      }
      if (other.lte_ != null) {
        if (lte_ == null) {
          Lte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Lte.MergeFrom(other.Lte);
      }
      if (other.gt_ != null) {
        if (gt_ == null) {
          Gt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Gt.MergeFrom(other.Gt);
      }
      if (other.gte_ != null) {
        if (gte_ == null) {
          Gte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Gte.MergeFrom(other.Gte);
      }
      if (other.HasLtNow) {
        LtNow = other.LtNow;
      }
      if (other.HasGtNow) {
        GtNow = other.GtNow;
      }
      if (other.within_ != null) {
        if (within_ == null) {
          Within = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Within.MergeFrom(other.Within);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (const_ == null) {
              Const = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Const);
            break;
          }
          case 26: {
            if (lt_ == null) {
              Lt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Lt);
            break;
          }
          case 34: {
            if (lte_ == null) {
              Lte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Lte);
            break;
          }
          case 42: {
            if (gt_ == null) {
              Gt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Gt);
            break;
          }
          case 50: {
            if (gte_ == null) {
              Gte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Gte);
            break;
          }
          case 56: {
            LtNow = input.ReadBool();
            break;
          }
          case 64: {
            GtNow = input.ReadBool();
            break;
          }
          case 74: {
            if (within_ == null) {
              Within = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Within);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (const_ == null) {
              Const = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Const);
            break;
          }
          case 26: {
            if (lt_ == null) {
              Lt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Lt);
            break;
          }
          case 34: {
            if (lte_ == null) {
              Lte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Lte);
            break;
          }
          case 42: {
            if (gt_ == null) {
              Gt = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Gt);
            break;
          }
          case 50: {
            if (gte_ == null) {
              Gte = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Gte);
            break;
          }
          case 56: {
            LtNow = input.ReadBool();
            break;
          }
          case 64: {
            GtNow = input.ReadBool();
            break;
          }
          case 74: {
            if (within_ == null) {
              Within = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Within);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
