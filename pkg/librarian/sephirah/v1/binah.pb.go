// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: librarian/sephirah/v1/binah.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ChunkTransferStatus int32

const (
	ChunkTransferStatus_CHUNK_TRANSFER_STATUS_UNSPECIFIED ChunkTransferStatus = 0
	ChunkTransferStatus_CHUNK_TRANSFER_STATUS_PENDING     ChunkTransferStatus = 1
	ChunkTransferStatus_CHUNK_TRANSFER_STATUS_IN_PROGRESS ChunkTransferStatus = 2
	ChunkTransferStatus_CHUNK_TRANSFER_STATUS_SUCCESS     ChunkTransferStatus = 3
	ChunkTransferStatus_CHUNK_TRANSFER_STATUS_FAILED      ChunkTransferStatus = 4
)

var ChunkTransferStatus_name = map[int32]string{
	0: "CHUNK_TRANSFER_STATUS_UNSPECIFIED",
	1: "CHUNK_TRANSFER_STATUS_PENDING",
	2: "CHUNK_TRANSFER_STATUS_IN_PROGRESS",
	3: "CHUNK_TRANSFER_STATUS_SUCCESS",
	4: "CHUNK_TRANSFER_STATUS_FAILED",
}

var ChunkTransferStatus_value = map[string]int32{
	"CHUNK_TRANSFER_STATUS_UNSPECIFIED": 0,
	"CHUNK_TRANSFER_STATUS_PENDING":     1,
	"CHUNK_TRANSFER_STATUS_IN_PROGRESS": 2,
	"CHUNK_TRANSFER_STATUS_SUCCESS":     3,
	"CHUNK_TRANSFER_STATUS_FAILED":      4,
}

func (x ChunkTransferStatus) String() string {
	return proto.EnumName(ChunkTransferStatus_name, int32(x))
}

func (ChunkTransferStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{0}
}

type FileTransferStatus int32

const (
	FileTransferStatus_FILE_TRANSFER_STATUS_UNSPECIFIED FileTransferStatus = 0
	FileTransferStatus_FILE_TRANSFER_STATUS_PENDING     FileTransferStatus = 1
	FileTransferStatus_FILE_TRANSFER_STATUS_IN_PROGRESS FileTransferStatus = 2
	FileTransferStatus_FILE_TRANSFER_STATUS_SUCCESS     FileTransferStatus = 3
	FileTransferStatus_FILE_TRANSFER_STATUS_FAILED      FileTransferStatus = 4
)

var FileTransferStatus_name = map[int32]string{
	0: "FILE_TRANSFER_STATUS_UNSPECIFIED",
	1: "FILE_TRANSFER_STATUS_PENDING",
	2: "FILE_TRANSFER_STATUS_IN_PROGRESS",
	3: "FILE_TRANSFER_STATUS_SUCCESS",
	4: "FILE_TRANSFER_STATUS_FAILED",
}

var FileTransferStatus_value = map[string]int32{
	"FILE_TRANSFER_STATUS_UNSPECIFIED": 0,
	"FILE_TRANSFER_STATUS_PENDING":     1,
	"FILE_TRANSFER_STATUS_IN_PROGRESS": 2,
	"FILE_TRANSFER_STATUS_SUCCESS":     3,
	"FILE_TRANSFER_STATUS_FAILED":      4,
}

func (x FileTransferStatus) String() string {
	return proto.EnumName(FileTransferStatus_name, int32(x))
}

func (FileTransferStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{1}
}

type UploadFileRequest struct {
	// Types that are valid to be assigned to Content:
	//	*UploadFileRequest_FileChunk
	//	*UploadFileRequest_RequireFileStatus
	Content              isUploadFileRequest_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UploadFileRequest) Reset()         { *m = UploadFileRequest{} }
func (m *UploadFileRequest) String() string { return proto.CompactTextString(m) }
func (*UploadFileRequest) ProtoMessage()    {}
func (*UploadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{0}
}
func (m *UploadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileRequest.Merge(m, src)
}
func (m *UploadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileRequest proto.InternalMessageInfo

type isUploadFileRequest_Content interface {
	isUploadFileRequest_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadFileRequest_FileChunk struct {
	FileChunk *FileChunk `protobuf:"bytes,1,opt,name=file_chunk,json=fileChunk,proto3,oneof" json:"file_chunk,omitempty"`
}
type UploadFileRequest_RequireFileStatus struct {
	RequireFileStatus bool `protobuf:"varint,2,opt,name=require_file_status,json=requireFileStatus,proto3,oneof" json:"require_file_status,omitempty"`
}

func (*UploadFileRequest_FileChunk) isUploadFileRequest_Content()         {}
func (*UploadFileRequest_RequireFileStatus) isUploadFileRequest_Content() {}

func (m *UploadFileRequest) GetContent() isUploadFileRequest_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *UploadFileRequest) GetFileChunk() *FileChunk {
	if x, ok := m.GetContent().(*UploadFileRequest_FileChunk); ok {
		return x.FileChunk
	}
	return nil
}

func (m *UploadFileRequest) GetRequireFileStatus() bool {
	if x, ok := m.GetContent().(*UploadFileRequest_RequireFileStatus); ok {
		return x.RequireFileStatus
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadFileRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadFileRequest_FileChunk)(nil),
		(*UploadFileRequest_RequireFileStatus)(nil),
	}
}

type UploadFileResponse struct {
	// Types that are valid to be assigned to Content:
	//	*UploadFileResponse_ChunkStatus_
	//	*UploadFileResponse_FileStatus_
	Content              isUploadFileResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *UploadFileResponse) Reset()         { *m = UploadFileResponse{} }
func (m *UploadFileResponse) String() string { return proto.CompactTextString(m) }
func (*UploadFileResponse) ProtoMessage()    {}
func (*UploadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{1}
}
func (m *UploadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileResponse.Merge(m, src)
}
func (m *UploadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileResponse proto.InternalMessageInfo

type isUploadFileResponse_Content interface {
	isUploadFileResponse_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadFileResponse_ChunkStatus_ struct {
	ChunkStatus *UploadFileResponse_ChunkStatus `protobuf:"bytes,1,opt,name=chunk_status,json=chunkStatus,proto3,oneof" json:"chunk_status,omitempty"`
}
type UploadFileResponse_FileStatus_ struct {
	FileStatus *UploadFileResponse_FileStatus `protobuf:"bytes,2,opt,name=file_status,json=fileStatus,proto3,oneof" json:"file_status,omitempty"`
}

func (*UploadFileResponse_ChunkStatus_) isUploadFileResponse_Content() {}
func (*UploadFileResponse_FileStatus_) isUploadFileResponse_Content()  {}

func (m *UploadFileResponse) GetContent() isUploadFileResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *UploadFileResponse) GetChunkStatus() *UploadFileResponse_ChunkStatus {
	if x, ok := m.GetContent().(*UploadFileResponse_ChunkStatus_); ok {
		return x.ChunkStatus
	}
	return nil
}

func (m *UploadFileResponse) GetFileStatus() *UploadFileResponse_FileStatus {
	if x, ok := m.GetContent().(*UploadFileResponse_FileStatus_); ok {
		return x.FileStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadFileResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadFileResponse_ChunkStatus_)(nil),
		(*UploadFileResponse_FileStatus_)(nil),
	}
}

type UploadFileResponse_ChunkStatus struct {
	ChunkNumber          int64               `protobuf:"varint,1,opt,name=chunk_number,json=chunkNumber,proto3" json:"chunk_number,omitempty"`
	Status               ChunkTransferStatus `protobuf:"varint,2,opt,name=status,proto3,enum=librarian.sephirah.v1.ChunkTransferStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *UploadFileResponse_ChunkStatus) Reset()         { *m = UploadFileResponse_ChunkStatus{} }
func (m *UploadFileResponse_ChunkStatus) String() string { return proto.CompactTextString(m) }
func (*UploadFileResponse_ChunkStatus) ProtoMessage()    {}
func (*UploadFileResponse_ChunkStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{1, 0}
}
func (m *UploadFileResponse_ChunkStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileResponse_ChunkStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileResponse_ChunkStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileResponse_ChunkStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileResponse_ChunkStatus.Merge(m, src)
}
func (m *UploadFileResponse_ChunkStatus) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileResponse_ChunkStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileResponse_ChunkStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileResponse_ChunkStatus proto.InternalMessageInfo

func (m *UploadFileResponse_ChunkStatus) GetChunkNumber() int64 {
	if m != nil {
		return m.ChunkNumber
	}
	return 0
}

func (m *UploadFileResponse_ChunkStatus) GetStatus() ChunkTransferStatus {
	if m != nil {
		return m.Status
	}
	return ChunkTransferStatus_CHUNK_TRANSFER_STATUS_UNSPECIFIED
}

type UploadFileResponse_FileStatus struct {
	MissingChunkList     []int64            `protobuf:"varint,1,rep,packed,name=missing_chunk_list,json=missingChunkList,proto3" json:"missing_chunk_list,omitempty"`
	Status               FileTransferStatus `protobuf:"varint,2,opt,name=status,proto3,enum=librarian.sephirah.v1.FileTransferStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UploadFileResponse_FileStatus) Reset()         { *m = UploadFileResponse_FileStatus{} }
func (m *UploadFileResponse_FileStatus) String() string { return proto.CompactTextString(m) }
func (*UploadFileResponse_FileStatus) ProtoMessage()    {}
func (*UploadFileResponse_FileStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{1, 1}
}
func (m *UploadFileResponse_FileStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileResponse_FileStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileResponse_FileStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileResponse_FileStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileResponse_FileStatus.Merge(m, src)
}
func (m *UploadFileResponse_FileStatus) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileResponse_FileStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileResponse_FileStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileResponse_FileStatus proto.InternalMessageInfo

func (m *UploadFileResponse_FileStatus) GetMissingChunkList() []int64 {
	if m != nil {
		return m.MissingChunkList
	}
	return nil
}

func (m *UploadFileResponse_FileStatus) GetStatus() FileTransferStatus {
	if m != nil {
		return m.Status
	}
	return FileTransferStatus_FILE_TRANSFER_STATUS_UNSPECIFIED
}

type DownloadFileRequest struct {
	StartChunkNumber int64 `protobuf:"varint,1,opt,name=start_chunk_number,json=startChunkNumber,proto3" json:"start_chunk_number,omitempty"`
	// Types that are valid to be assigned to XEndChunkNumber:
	//
	//	*DownloadFileRequest_EndChunkNumber
	XEndChunkNumber      isDownloadFileRequest_XEndChunkNumber `protobuf_oneof:"_end_chunk_number"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *DownloadFileRequest) Reset()         { *m = DownloadFileRequest{} }
func (m *DownloadFileRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRequest) ProtoMessage()    {}
func (*DownloadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{2}
}
func (m *DownloadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadFileRequest.Merge(m, src)
}
func (m *DownloadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadFileRequest proto.InternalMessageInfo

type isDownloadFileRequest_XEndChunkNumber interface {
	isDownloadFileRequest_XEndChunkNumber()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DownloadFileRequest_EndChunkNumber struct {
	EndChunkNumber int64 `protobuf:"varint,2,opt,name=end_chunk_number,json=endChunkNumber,proto3,oneof" json:"end_chunk_number,omitempty"`
}

func (*DownloadFileRequest_EndChunkNumber) isDownloadFileRequest_XEndChunkNumber() {}

func (m *DownloadFileRequest) GetXEndChunkNumber() isDownloadFileRequest_XEndChunkNumber {
	if m != nil {
		return m.XEndChunkNumber
	}
	return nil
}

func (m *DownloadFileRequest) GetStartChunkNumber() int64 {
	if m != nil {
		return m.StartChunkNumber
	}
	return 0
}

func (m *DownloadFileRequest) GetEndChunkNumber() int64 {
	if x, ok := m.GetXEndChunkNumber().(*DownloadFileRequest_EndChunkNumber); ok {
		return x.EndChunkNumber
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DownloadFileRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DownloadFileRequest_EndChunkNumber)(nil),
	}
}

type DownloadFileResponse struct {
	FileChunk            *FileChunk `protobuf:"bytes,1,opt,name=file_chunk,json=fileChunk,proto3" json:"file_chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DownloadFileResponse) Reset()         { *m = DownloadFileResponse{} }
func (m *DownloadFileResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadFileResponse) ProtoMessage()    {}
func (*DownloadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{3}
}
func (m *DownloadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadFileResponse.Merge(m, src)
}
func (m *DownloadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadFileResponse proto.InternalMessageInfo

func (m *DownloadFileResponse) GetFileChunk() *FileChunk {
	if m != nil {
		return m.FileChunk
	}
	return nil
}

type SimpleUploadFileRequest struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleUploadFileRequest) Reset()         { *m = SimpleUploadFileRequest{} }
func (m *SimpleUploadFileRequest) String() string { return proto.CompactTextString(m) }
func (*SimpleUploadFileRequest) ProtoMessage()    {}
func (*SimpleUploadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{4}
}
func (m *SimpleUploadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleUploadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleUploadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleUploadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleUploadFileRequest.Merge(m, src)
}
func (m *SimpleUploadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *SimpleUploadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleUploadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleUploadFileRequest proto.InternalMessageInfo

func (m *SimpleUploadFileRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SimpleUploadFileResponse struct {
	Status               FileTransferStatus `protobuf:"varint,1,opt,name=status,proto3,enum=librarian.sephirah.v1.FileTransferStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SimpleUploadFileResponse) Reset()         { *m = SimpleUploadFileResponse{} }
func (m *SimpleUploadFileResponse) String() string { return proto.CompactTextString(m) }
func (*SimpleUploadFileResponse) ProtoMessage()    {}
func (*SimpleUploadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{5}
}
func (m *SimpleUploadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleUploadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleUploadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleUploadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleUploadFileResponse.Merge(m, src)
}
func (m *SimpleUploadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *SimpleUploadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleUploadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleUploadFileResponse proto.InternalMessageInfo

func (m *SimpleUploadFileResponse) GetStatus() FileTransferStatus {
	if m != nil {
		return m.Status
	}
	return FileTransferStatus_FILE_TRANSFER_STATUS_UNSPECIFIED
}

type SimpleDownloadFileRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleDownloadFileRequest) Reset()         { *m = SimpleDownloadFileRequest{} }
func (m *SimpleDownloadFileRequest) String() string { return proto.CompactTextString(m) }
func (*SimpleDownloadFileRequest) ProtoMessage()    {}
func (*SimpleDownloadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{6}
}
func (m *SimpleDownloadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleDownloadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleDownloadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleDownloadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleDownloadFileRequest.Merge(m, src)
}
func (m *SimpleDownloadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *SimpleDownloadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleDownloadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleDownloadFileRequest proto.InternalMessageInfo

type SimpleDownloadFileResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleDownloadFileResponse) Reset()         { *m = SimpleDownloadFileResponse{} }
func (m *SimpleDownloadFileResponse) String() string { return proto.CompactTextString(m) }
func (*SimpleDownloadFileResponse) ProtoMessage()    {}
func (*SimpleDownloadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{7}
}
func (m *SimpleDownloadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleDownloadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleDownloadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleDownloadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleDownloadFileResponse.Merge(m, src)
}
func (m *SimpleDownloadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *SimpleDownloadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleDownloadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleDownloadFileResponse proto.InternalMessageInfo

func (m *SimpleDownloadFileResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type FileChunk struct {
	ChunkNumber          int64    `protobuf:"varint,1,opt,name=chunk_number,json=chunkNumber,proto3" json:"chunk_number,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileChunk) Reset()         { *m = FileChunk{} }
func (m *FileChunk) String() string { return proto.CompactTextString(m) }
func (*FileChunk) ProtoMessage()    {}
func (*FileChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_72f7f9e0a2e1b9a7, []int{8}
}
func (m *FileChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChunk.Merge(m, src)
}
func (m *FileChunk) XXX_Size() int {
	return m.Size()
}
func (m *FileChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChunk.DiscardUnknown(m)
}

var xxx_messageInfo_FileChunk proto.InternalMessageInfo

func (m *FileChunk) GetChunkNumber() int64 {
	if m != nil {
		return m.ChunkNumber
	}
	return 0
}

func (m *FileChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("librarian.sephirah.v1.ChunkTransferStatus", ChunkTransferStatus_name, ChunkTransferStatus_value)
	proto.RegisterEnum("librarian.sephirah.v1.FileTransferStatus", FileTransferStatus_name, FileTransferStatus_value)
	proto.RegisterType((*UploadFileRequest)(nil), "librarian.sephirah.v1.UploadFileRequest")
	proto.RegisterType((*UploadFileResponse)(nil), "librarian.sephirah.v1.UploadFileResponse")
	proto.RegisterType((*UploadFileResponse_ChunkStatus)(nil), "librarian.sephirah.v1.UploadFileResponse.ChunkStatus")
	proto.RegisterType((*UploadFileResponse_FileStatus)(nil), "librarian.sephirah.v1.UploadFileResponse.FileStatus")
	proto.RegisterType((*DownloadFileRequest)(nil), "librarian.sephirah.v1.DownloadFileRequest")
	proto.RegisterType((*DownloadFileResponse)(nil), "librarian.sephirah.v1.DownloadFileResponse")
	proto.RegisterType((*SimpleUploadFileRequest)(nil), "librarian.sephirah.v1.SimpleUploadFileRequest")
	proto.RegisterType((*SimpleUploadFileResponse)(nil), "librarian.sephirah.v1.SimpleUploadFileResponse")
	proto.RegisterType((*SimpleDownloadFileRequest)(nil), "librarian.sephirah.v1.SimpleDownloadFileRequest")
	proto.RegisterType((*SimpleDownloadFileResponse)(nil), "librarian.sephirah.v1.SimpleDownloadFileResponse")
	proto.RegisterType((*FileChunk)(nil), "librarian.sephirah.v1.FileChunk")
}

func init() { proto.RegisterFile("librarian/sephirah/v1/binah.proto", fileDescriptor_72f7f9e0a2e1b9a7) }

var fileDescriptor_72f7f9e0a2e1b9a7 = []byte{
	// 677 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xcd, 0x24, 0x55, 0xbf, 0xaf, 0x37, 0x55, 0xe5, 0x4e, 0xbe, 0x4f, 0x84, 0xb6, 0x04, 0xc7,
	0x80, 0x28, 0x55, 0xeb, 0x34, 0x05, 0x56, 0x2c, 0x50, 0x7e, 0x9c, 0x3a, 0x22, 0x32, 0x91, 0x9d,
	0x50, 0xa9, 0x12, 0xb2, 0xec, 0x64, 0xda, 0x8c, 0x48, 0xec, 0xd4, 0x3f, 0x65, 0xc5, 0x1a, 0xf6,
	0x6c, 0x78, 0x06, 0xde, 0x03, 0x09, 0xc4, 0x86, 0x47, 0x40, 0xe5, 0x45, 0x50, 0x26, 0x76, 0xed,
	0x34, 0x0e, 0x54, 0xdd, 0x65, 0x72, 0xcf, 0x9c, 0x7b, 0xce, 0xbd, 0xc7, 0x1a, 0x28, 0x0e, 0xa9,
	0xe9, 0x18, 0x0e, 0x35, 0xac, 0x92, 0x4b, 0xc6, 0x03, 0xea, 0x18, 0x83, 0xd2, 0x79, 0xb9, 0x64,
	0x52, 0xcb, 0x18, 0x88, 0x63, 0xc7, 0xf6, 0x6c, 0xfc, 0xff, 0x25, 0x44, 0x0c, 0x21, 0xe2, 0x79,
	0x59, 0xf8, 0x88, 0x60, 0xbd, 0x3b, 0x1e, 0xda, 0x46, 0xbf, 0x41, 0x87, 0x44, 0x25, 0x67, 0x3e,
	0x71, 0x3d, 0x5c, 0x01, 0x38, 0xa1, 0x43, 0xa2, 0xf7, 0x06, 0xbe, 0xf5, 0x26, 0x8f, 0x78, 0xb4,
	0x9d, 0x3d, 0xe0, 0xc5, 0x44, 0x06, 0x71, 0x72, 0xaf, 0x36, 0xc1, 0xc9, 0x29, 0x75, 0xe5, 0x24,
	0x3c, 0xe0, 0x7d, 0xc8, 0x39, 0xe4, 0xcc, 0xa7, 0x0e, 0xd1, 0x19, 0x95, 0xeb, 0x19, 0x9e, 0xef,
	0xe6, 0xd3, 0x3c, 0xda, 0xfe, 0x57, 0x4e, 0xa9, 0xeb, 0x41, 0x71, 0x72, 0x5b, 0x63, 0xa5, 0xea,
	0x0a, 0xfc, 0xd3, 0xb3, 0x2d, 0x8f, 0x58, 0x9e, 0xf0, 0x2d, 0x03, 0x38, 0xae, 0xca, 0x1d, 0xdb,
	0x96, 0x4b, 0xf0, 0x31, 0xac, 0x32, 0x45, 0x21, 0xd9, 0x54, 0xd8, 0xd3, 0x05, 0xc2, 0xe6, 0x09,
	0x44, 0x26, 0x6d, 0xda, 0x4e, 0x4e, 0xa9, 0xd9, 0x5e, 0x74, 0xc4, 0x47, 0x90, 0xbd, 0xaa, 0x33,
	0x7b, 0xf0, 0xe4, 0xfa, 0xd4, 0x91, 0x11, 0x39, 0xa5, 0xb2, 0xe9, 0x4d, 0x4f, 0x1b, 0x1e, 0x64,
	0x63, 0x6d, 0x71, 0x31, 0xf4, 0x60, 0xf9, 0x23, 0x93, 0x38, 0xcc, 0x43, 0x26, 0x90, 0xa2, 0xb0,
	0xbf, 0x70, 0x15, 0x96, 0x63, 0x2a, 0xd6, 0x0e, 0x76, 0x16, 0xa8, 0x60, 0xb4, 0x1d, 0xc7, 0xb0,
	0xdc, 0x13, 0xe2, 0x4c, 0xe9, 0xd5, 0xe0, 0xe6, 0xc6, 0x3b, 0x80, 0x48, 0x11, 0xde, 0x05, 0x3c,
	0xa2, 0xae, 0x4b, 0xad, 0xd3, 0xe9, 0x4a, 0xf5, 0x21, 0x75, 0xbd, 0x3c, 0xe2, 0x33, 0xdb, 0x19,
	0x95, 0x0b, 0x2a, 0x8c, 0xad, 0x45, 0xd9, 0xf6, 0x67, 0xfb, 0x3f, 0xfa, 0xc3, 0xe6, 0x93, 0xdb,
	0xc7, 0x77, 0xf9, 0x1e, 0x41, 0xae, 0x6e, 0xbf, 0xb5, 0xae, 0x66, 0x6c, 0x17, 0xb0, 0xeb, 0x19,
	0x8e, 0xa7, 0x27, 0x8c, 0x83, 0x63, 0x95, 0x5a, 0x6c, 0x26, 0x7b, 0xc0, 0x11, 0xab, 0x3f, 0x8b,
	0x9d, 0xa8, 0xcb, 0xc8, 0x29, 0x75, 0x8d, 0x58, 0xfd, 0x18, 0xf6, 0x03, 0x42, 0xd5, 0x1c, 0xac,
	0xeb, 0x57, 0xf1, 0xc2, 0x11, 0xfc, 0x37, 0x2b, 0x24, 0x88, 0xd5, 0xf3, 0x9b, 0xa4, 0x3d, 0x96,
	0x75, 0x61, 0x0f, 0x6e, 0x69, 0x74, 0x34, 0x1e, 0x92, 0xf9, 0x2f, 0x09, 0xc3, 0x52, 0xdf, 0xf0,
	0x0c, 0xc6, 0xba, 0xaa, 0xb2, 0xdf, 0xc2, 0x6b, 0xc8, 0xcf, 0xc3, 0x03, 0x2d, 0xd1, 0xec, 0xd1,
	0x0d, 0x67, 0x2f, 0x6c, 0xc2, 0xed, 0x29, 0x7d, 0xc2, 0xd4, 0x85, 0x7d, 0xd8, 0x48, 0x2a, 0x06,
	0xdd, 0x93, 0xd4, 0x56, 0x61, 0xe5, 0xd2, 0xf4, 0x75, 0xd2, 0x1b, 0x72, 0xa4, 0x23, 0x8e, 0x9d,
	0xef, 0x08, 0x72, 0x09, 0x69, 0xc5, 0x0f, 0xa0, 0x58, 0x93, 0xbb, 0xca, 0x0b, 0xbd, 0xa3, 0x56,
	0x14, 0xad, 0x21, 0xa9, 0xba, 0xd6, 0xa9, 0x74, 0xba, 0x9a, 0xde, 0x55, 0xb4, 0xb6, 0x54, 0x6b,
	0x36, 0x9a, 0x52, 0x9d, 0x4b, 0xe1, 0x22, 0xdc, 0x49, 0x86, 0xb5, 0x25, 0xa5, 0xde, 0x54, 0x0e,
	0x39, 0xb4, 0x98, 0xa9, 0xa9, 0xe8, 0x6d, 0xf5, 0xe5, 0xa1, 0x2a, 0x69, 0x1a, 0x97, 0x5e, 0xcc,
	0xa4, 0x75, 0x6b, 0xb5, 0x09, 0x24, 0x83, 0x79, 0xd8, 0x4a, 0x86, 0x34, 0x2a, 0xcd, 0x96, 0x54,
	0xe7, 0x96, 0x76, 0xbe, 0x20, 0xc0, 0xf3, 0xf3, 0xc7, 0xf7, 0x81, 0x6f, 0x34, 0x5b, 0xd2, 0x5f,
	0xbc, 0xf0, 0xb0, 0x95, 0x88, 0x8a, 0xac, 0x2c, 0xe2, 0x99, 0x75, 0xb2, 0x88, 0x27, 0x32, 0x72,
	0x17, 0x36, 0x13, 0x11, 0xa1, 0x8f, 0xaa, 0xfe, 0xf5, 0xa2, 0x80, 0x7e, 0x5c, 0x14, 0xd0, 0xcf,
	0x8b, 0x02, 0xfa, 0xf4, 0xab, 0x90, 0x3a, 0x7e, 0x78, 0x4a, 0xbd, 0x81, 0x6f, 0x8a, 0x3d, 0x7b,
	0x54, 0xf2, 0x7c, 0x3a, 0xf0, 0xcd, 0xd2, 0xfc, 0xcb, 0xf2, 0xec, 0xbc, 0xfc, 0x39, 0x7d, 0xaf,
	0xe3, 0x53, 0xd9, 0x37, 0xc5, 0xf6, 0xe4, 0x71, 0x71, 0xc5, 0xd6, 0x65, 0x48, 0xb5, 0x30, 0xa4,
	0xaf, 0xca, 0xe6, 0x32, 0x7b, 0x7a, 0x1e, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x15, 0x1f, 0xb2,
	0x22, 0x9f, 0x06, 0x00, 0x00,
}

func (m *UploadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileRequest_FileChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileRequest_FileChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FileChunk != nil {
		{
			size, err := m.FileChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinah(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UploadFileRequest_RequireFileStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileRequest_RequireFileStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.RequireFileStatus {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *UploadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileResponse_ChunkStatus_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileResponse_ChunkStatus_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChunkStatus != nil {
		{
			size, err := m.ChunkStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinah(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UploadFileResponse_FileStatus_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileResponse_FileStatus_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FileStatus != nil {
		{
			size, err := m.FileStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinah(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UploadFileResponse_ChunkStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileResponse_ChunkStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileResponse_ChunkStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ChunkNumber != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.ChunkNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileResponse_FileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileResponse_FileStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileResponse_FileStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MissingChunkList) > 0 {
		dAtA5 := make([]byte, len(m.MissingChunkList)*10)
		var j4 int
		for _, num1 := range m.MissingChunkList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintBinah(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XEndChunkNumber != nil {
		{
			size := m.XEndChunkNumber.Size()
			i -= size
			if _, err := m.XEndChunkNumber.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StartChunkNumber != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.StartChunkNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadFileRequest_EndChunkNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileRequest_EndChunkNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintBinah(dAtA, i, uint64(m.EndChunkNumber))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *DownloadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileChunk != nil {
		{
			size, err := m.FileChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinah(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleUploadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleUploadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleUploadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBinah(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleUploadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleUploadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleUploadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleDownloadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleDownloadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDownloadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SimpleDownloadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleDownloadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleDownloadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBinah(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBinah(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChunkNumber != 0 {
		i = encodeVarintBinah(dAtA, i, uint64(m.ChunkNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBinah(dAtA []byte, offset int, v uint64) int {
	offset -= sovBinah(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UploadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileRequest_FileChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileChunk != nil {
		l = m.FileChunk.Size()
		n += 1 + l + sovBinah(uint64(l))
	}
	return n
}
func (m *UploadFileRequest_RequireFileStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *UploadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileResponse_ChunkStatus_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkStatus != nil {
		l = m.ChunkStatus.Size()
		n += 1 + l + sovBinah(uint64(l))
	}
	return n
}
func (m *UploadFileResponse_FileStatus_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileStatus != nil {
		l = m.FileStatus.Size()
		n += 1 + l + sovBinah(uint64(l))
	}
	return n
}
func (m *UploadFileResponse_ChunkStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkNumber != 0 {
		n += 1 + sovBinah(uint64(m.ChunkNumber))
	}
	if m.Status != 0 {
		n += 1 + sovBinah(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileResponse_FileStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MissingChunkList) > 0 {
		l = 0
		for _, e := range m.MissingChunkList {
			l += sovBinah(uint64(e))
		}
		n += 1 + sovBinah(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovBinah(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartChunkNumber != 0 {
		n += 1 + sovBinah(uint64(m.StartChunkNumber))
	}
	if m.XEndChunkNumber != nil {
		n += m.XEndChunkNumber.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadFileRequest_EndChunkNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBinah(uint64(m.EndChunkNumber))
	return n
}
func (m *DownloadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileChunk != nil {
		l = m.FileChunk.Size()
		n += 1 + l + sovBinah(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleUploadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBinah(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleUploadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBinah(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleDownloadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleDownloadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBinah(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkNumber != 0 {
		n += 1 + sovBinah(uint64(m.ChunkNumber))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBinah(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBinah(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBinah(x uint64) (n int) {
	return sovBinah(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UploadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &UploadFileRequest_FileChunk{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFileStatus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Content = &UploadFileRequest_RequireFileStatus{b}
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UploadFileResponse_ChunkStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &UploadFileResponse_ChunkStatus_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UploadFileResponse_FileStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &UploadFileResponse_FileStatus_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileResponse_ChunkStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkNumber", wireType)
			}
			m.ChunkNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ChunkTransferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileResponse_FileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBinah
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MissingChunkList = append(m.MissingChunkList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBinah
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBinah
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBinah
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MissingChunkList) == 0 {
					m.MissingChunkList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBinah
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MissingChunkList = append(m.MissingChunkList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingChunkList", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FileTransferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartChunkNumber", wireType)
			}
			m.StartChunkNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartChunkNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndChunkNumber", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XEndChunkNumber = &DownloadFileRequest_EndChunkNumber{v}
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileChunk == nil {
				m.FileChunk = &FileChunk{}
			}
			if err := m.FileChunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleUploadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleUploadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleUploadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleUploadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleUploadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleUploadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FileTransferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleDownloadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleDownloadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleDownloadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleDownloadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleDownloadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleDownloadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkNumber", wireType)
			}
			m.ChunkNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBinah
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBinah
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinah(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBinah
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBinah(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBinah
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinah
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBinah
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBinah
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBinah
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBinah        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBinah          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBinah = fmt.Errorf("proto: unexpected end of group")
)
