// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: librarian/sephirah/v1/gebura.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AppType int32

const (
	AppType_APP_TYPE_UNSPECIFIED AppType = 0
	AppType_APP_TYPE_GAME        AppType = 1
)

var AppType_name = map[int32]string{
	0: "APP_TYPE_UNSPECIFIED",
	1: "APP_TYPE_GAME",
}

var AppType_value = map[string]int32{
	"APP_TYPE_UNSPECIFIED": 0,
	"APP_TYPE_GAME":        1,
}

func (x AppType) String() string {
	return proto.EnumName(AppType_name, int32(x))
}

func (AppType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{0}
}

type AppSource int32

const (
	AppSource_APP_SOURCE_UNSPECIFIED AppSource = 0
	AppSource_APP_SOURCE_INTERNAL    AppSource = 1
	AppSource_APP_SOURCE_STEAM       AppSource = 2
)

var AppSource_name = map[int32]string{
	0: "APP_SOURCE_UNSPECIFIED",
	1: "APP_SOURCE_INTERNAL",
	2: "APP_SOURCE_STEAM",
}

var AppSource_value = map[string]int32{
	"APP_SOURCE_UNSPECIFIED": 0,
	"APP_SOURCE_INTERNAL":    1,
	"APP_SOURCE_STEAM":       2,
}

func (x AppSource) String() string {
	return proto.EnumName(AppSource_name, int32(x))
}

func (AppSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{1}
}

type CreateAppRequest struct {
	// `id` can be anything, `source` must be APP_SOURCE_INTERNAL
	App                  *App     `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAppRequest) Reset()         { *m = CreateAppRequest{} }
func (m *CreateAppRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAppRequest) ProtoMessage()    {}
func (*CreateAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{0}
}
func (m *CreateAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAppRequest.Merge(m, src)
}
func (m *CreateAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAppRequest proto.InternalMessageInfo

func (m *CreateAppRequest) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type CreateAppResponse struct {
	Id                   *InternalID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateAppResponse) Reset()         { *m = CreateAppResponse{} }
func (m *CreateAppResponse) String() string { return proto.CompactTextString(m) }
func (*CreateAppResponse) ProtoMessage()    {}
func (*CreateAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{1}
}
func (m *CreateAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAppResponse.Merge(m, src)
}
func (m *CreateAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAppResponse proto.InternalMessageInfo

func (m *CreateAppResponse) GetId() *InternalID {
	if m != nil {
		return m.Id
	}
	return nil
}

type UpdateAppRequest struct {
	// source must be APP_SOURCE_INTERNAL
	App                  *App     `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateAppRequest) Reset()         { *m = UpdateAppRequest{} }
func (m *UpdateAppRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateAppRequest) ProtoMessage()    {}
func (*UpdateAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{2}
}
func (m *UpdateAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAppRequest.Merge(m, src)
}
func (m *UpdateAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAppRequest proto.InternalMessageInfo

func (m *UpdateAppRequest) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type UpdateAppResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateAppResponse) Reset()         { *m = UpdateAppResponse{} }
func (m *UpdateAppResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateAppResponse) ProtoMessage()    {}
func (*UpdateAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{3}
}
func (m *UpdateAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAppResponse.Merge(m, src)
}
func (m *UpdateAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAppResponse proto.InternalMessageInfo

type ListAppRequest struct {
	PageNum              int64       `protobuf:"varint,1,opt,name=page_num,json=pageNum,proto3" json:"page_num,omitempty"`
	PageSize             int64       `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	SourceFilter         []AppSource `protobuf:"varint,3,rep,packed,name=source_filter,json=sourceFilter,proto3,enum=librarian.sephirah.v1.AppSource" json:"source_filter,omitempty"`
	TypeFilter           []AppType   `protobuf:"varint,4,rep,packed,name=type_filter,json=typeFilter,proto3,enum=librarian.sephirah.v1.AppType" json:"type_filter,omitempty"`
	IdFilter             []int64     `protobuf:"varint,5,rep,packed,name=id_filter,json=idFilter,proto3" json:"id_filter,omitempty"`
	ContainDetails       bool        `protobuf:"varint,6,opt,name=contain_details,json=containDetails,proto3" json:"contain_details,omitempty"`
	WithBind             bool        `protobuf:"varint,7,opt,name=with_bind,json=withBind,proto3" json:"with_bind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListAppRequest) Reset()         { *m = ListAppRequest{} }
func (m *ListAppRequest) String() string { return proto.CompactTextString(m) }
func (*ListAppRequest) ProtoMessage()    {}
func (*ListAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{4}
}
func (m *ListAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppRequest.Merge(m, src)
}
func (m *ListAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppRequest proto.InternalMessageInfo

func (m *ListAppRequest) GetPageNum() int64 {
	if m != nil {
		return m.PageNum
	}
	return 0
}

func (m *ListAppRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListAppRequest) GetSourceFilter() []AppSource {
	if m != nil {
		return m.SourceFilter
	}
	return nil
}

func (m *ListAppRequest) GetTypeFilter() []AppType {
	if m != nil {
		return m.TypeFilter
	}
	return nil
}

func (m *ListAppRequest) GetIdFilter() []int64 {
	if m != nil {
		return m.IdFilter
	}
	return nil
}

func (m *ListAppRequest) GetContainDetails() bool {
	if m != nil {
		return m.ContainDetails
	}
	return false
}

func (m *ListAppRequest) GetWithBind() bool {
	if m != nil {
		return m.WithBind
	}
	return false
}

type ListAppResponse struct {
	// Types that are valid to be assigned to Content:
	//	*ListAppResponse_WithoutBind
	//	*ListAppResponse_WithBind
	Content              isListAppResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ListAppResponse) Reset()         { *m = ListAppResponse{} }
func (m *ListAppResponse) String() string { return proto.CompactTextString(m) }
func (*ListAppResponse) ProtoMessage()    {}
func (*ListAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{5}
}
func (m *ListAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppResponse.Merge(m, src)
}
func (m *ListAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppResponse proto.InternalMessageInfo

type isListAppResponse_Content interface {
	isListAppResponse_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListAppResponse_WithoutBind struct {
	WithoutBind *ListAppResponse_AppList `protobuf:"bytes,1,opt,name=without_bind,json=withoutBind,proto3,oneof" json:"without_bind,omitempty"`
}
type ListAppResponse_WithBind struct {
	WithBind *ListAppResponse_AppListList `protobuf:"bytes,2,opt,name=with_bind,json=withBind,proto3,oneof" json:"with_bind,omitempty"`
}

func (*ListAppResponse_WithoutBind) isListAppResponse_Content() {}
func (*ListAppResponse_WithBind) isListAppResponse_Content()    {}

func (m *ListAppResponse) GetContent() isListAppResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ListAppResponse) GetWithoutBind() *ListAppResponse_AppList {
	if x, ok := m.GetContent().(*ListAppResponse_WithoutBind); ok {
		return x.WithoutBind
	}
	return nil
}

func (m *ListAppResponse) GetWithBind() *ListAppResponse_AppListList {
	if x, ok := m.GetContent().(*ListAppResponse_WithBind); ok {
		return x.WithBind
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ListAppResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ListAppResponse_WithoutBind)(nil),
		(*ListAppResponse_WithBind)(nil),
	}
}

type ListAppResponse_AppList struct {
	AppList              []*App   `protobuf:"bytes,1,rep,name=app_list,json=appList,proto3" json:"app_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAppResponse_AppList) Reset()         { *m = ListAppResponse_AppList{} }
func (m *ListAppResponse_AppList) String() string { return proto.CompactTextString(m) }
func (*ListAppResponse_AppList) ProtoMessage()    {}
func (*ListAppResponse_AppList) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{5, 0}
}
func (m *ListAppResponse_AppList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppResponse_AppList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppResponse_AppList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppResponse_AppList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppResponse_AppList.Merge(m, src)
}
func (m *ListAppResponse_AppList) XXX_Size() int {
	return m.Size()
}
func (m *ListAppResponse_AppList) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppResponse_AppList.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppResponse_AppList proto.InternalMessageInfo

func (m *ListAppResponse_AppList) GetAppList() []*App {
	if m != nil {
		return m.AppList
	}
	return nil
}

type ListAppResponse_AppListList struct {
	AppListList          []*ListAppResponse_AppList `protobuf:"bytes,1,rep,name=app_list_list,json=appListList,proto3" json:"app_list_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ListAppResponse_AppListList) Reset()         { *m = ListAppResponse_AppListList{} }
func (m *ListAppResponse_AppListList) String() string { return proto.CompactTextString(m) }
func (*ListAppResponse_AppListList) ProtoMessage()    {}
func (*ListAppResponse_AppListList) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{5, 1}
}
func (m *ListAppResponse_AppListList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppResponse_AppListList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppResponse_AppListList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppResponse_AppListList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppResponse_AppListList.Merge(m, src)
}
func (m *ListAppResponse_AppListList) XXX_Size() int {
	return m.Size()
}
func (m *ListAppResponse_AppListList) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppResponse_AppListList.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppResponse_AppListList proto.InternalMessageInfo

func (m *ListAppResponse_AppListList) GetAppListList() []*ListAppResponse_AppList {
	if m != nil {
		return m.AppListList
	}
	return nil
}

type BindAppRequest struct {
	SrcId                *InternalID `protobuf:"bytes,1,opt,name=src_id,json=srcId,proto3" json:"src_id,omitempty"`
	DstId                *InternalID `protobuf:"bytes,2,opt,name=dst_id,json=dstId,proto3" json:"dst_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BindAppRequest) Reset()         { *m = BindAppRequest{} }
func (m *BindAppRequest) String() string { return proto.CompactTextString(m) }
func (*BindAppRequest) ProtoMessage()    {}
func (*BindAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{6}
}
func (m *BindAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindAppRequest.Merge(m, src)
}
func (m *BindAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *BindAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BindAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BindAppRequest proto.InternalMessageInfo

func (m *BindAppRequest) GetSrcId() *InternalID {
	if m != nil {
		return m.SrcId
	}
	return nil
}

func (m *BindAppRequest) GetDstId() *InternalID {
	if m != nil {
		return m.DstId
	}
	return nil
}

type BindAppResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BindAppResponse) Reset()         { *m = BindAppResponse{} }
func (m *BindAppResponse) String() string { return proto.CompactTextString(m) }
func (*BindAppResponse) ProtoMessage()    {}
func (*BindAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{7}
}
func (m *BindAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindAppResponse.Merge(m, src)
}
func (m *BindAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *BindAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BindAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BindAppResponse proto.InternalMessageInfo

type UnBindAppRequest struct {
	SrcId                *InternalID `protobuf:"bytes,1,opt,name=src_id,json=srcId,proto3" json:"src_id,omitempty"`
	DstId                *InternalID `protobuf:"bytes,2,opt,name=dst_id,json=dstId,proto3" json:"dst_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UnBindAppRequest) Reset()         { *m = UnBindAppRequest{} }
func (m *UnBindAppRequest) String() string { return proto.CompactTextString(m) }
func (*UnBindAppRequest) ProtoMessage()    {}
func (*UnBindAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{8}
}
func (m *UnBindAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnBindAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnBindAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnBindAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnBindAppRequest.Merge(m, src)
}
func (m *UnBindAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnBindAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnBindAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnBindAppRequest proto.InternalMessageInfo

func (m *UnBindAppRequest) GetSrcId() *InternalID {
	if m != nil {
		return m.SrcId
	}
	return nil
}

func (m *UnBindAppRequest) GetDstId() *InternalID {
	if m != nil {
		return m.DstId
	}
	return nil
}

type UnBindAppResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnBindAppResponse) Reset()         { *m = UnBindAppResponse{} }
func (m *UnBindAppResponse) String() string { return proto.CompactTextString(m) }
func (*UnBindAppResponse) ProtoMessage()    {}
func (*UnBindAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{9}
}
func (m *UnBindAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnBindAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnBindAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnBindAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnBindAppResponse.Merge(m, src)
}
func (m *UnBindAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnBindAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnBindAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnBindAppResponse proto.InternalMessageInfo

type RefreshAppRequest struct {
	Id                   *InternalID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RefreshAppRequest) Reset()         { *m = RefreshAppRequest{} }
func (m *RefreshAppRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshAppRequest) ProtoMessage()    {}
func (*RefreshAppRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{10}
}
func (m *RefreshAppRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshAppRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshAppRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshAppRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshAppRequest.Merge(m, src)
}
func (m *RefreshAppRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshAppRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshAppRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshAppRequest proto.InternalMessageInfo

func (m *RefreshAppRequest) GetId() *InternalID {
	if m != nil {
		return m.Id
	}
	return nil
}

type RefreshAppResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RefreshAppResponse) Reset()         { *m = RefreshAppResponse{} }
func (m *RefreshAppResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshAppResponse) ProtoMessage()    {}
func (*RefreshAppResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{11}
}
func (m *RefreshAppResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshAppResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshAppResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshAppResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshAppResponse.Merge(m, src)
}
func (m *RefreshAppResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshAppResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshAppResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshAppResponse proto.InternalMessageInfo

type UploadArtifactsRequest struct {
	FileMetadata         *FileMetadata `protobuf:"bytes,1,opt,name=file_metadata,json=fileMetadata,proto3" json:"file_metadata,omitempty"`
	AppId                *InternalID   `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UploadArtifactsRequest) Reset()         { *m = UploadArtifactsRequest{} }
func (m *UploadArtifactsRequest) String() string { return proto.CompactTextString(m) }
func (*UploadArtifactsRequest) ProtoMessage()    {}
func (*UploadArtifactsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{12}
}
func (m *UploadArtifactsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadArtifactsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadArtifactsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadArtifactsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadArtifactsRequest.Merge(m, src)
}
func (m *UploadArtifactsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadArtifactsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadArtifactsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadArtifactsRequest proto.InternalMessageInfo

func (m *UploadArtifactsRequest) GetFileMetadata() *FileMetadata {
	if m != nil {
		return m.FileMetadata
	}
	return nil
}

func (m *UploadArtifactsRequest) GetAppId() *InternalID {
	if m != nil {
		return m.AppId
	}
	return nil
}

type UploadArtifactsResponse struct {
	UploadToken          string   `protobuf:"bytes,1,opt,name=upload_token,json=uploadToken,proto3" json:"upload_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadArtifactsResponse) Reset()         { *m = UploadArtifactsResponse{} }
func (m *UploadArtifactsResponse) String() string { return proto.CompactTextString(m) }
func (*UploadArtifactsResponse) ProtoMessage()    {}
func (*UploadArtifactsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{13}
}
func (m *UploadArtifactsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadArtifactsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadArtifactsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadArtifactsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadArtifactsResponse.Merge(m, src)
}
func (m *UploadArtifactsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadArtifactsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadArtifactsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadArtifactsResponse proto.InternalMessageInfo

func (m *UploadArtifactsResponse) GetUploadToken() string {
	if m != nil {
		return m.UploadToken
	}
	return ""
}

type DownloadArtifactsRequest struct {
	Id                   *InternalID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DownloadArtifactsRequest) Reset()         { *m = DownloadArtifactsRequest{} }
func (m *DownloadArtifactsRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadArtifactsRequest) ProtoMessage()    {}
func (*DownloadArtifactsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{14}
}
func (m *DownloadArtifactsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadArtifactsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadArtifactsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadArtifactsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadArtifactsRequest.Merge(m, src)
}
func (m *DownloadArtifactsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadArtifactsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadArtifactsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadArtifactsRequest proto.InternalMessageInfo

func (m *DownloadArtifactsRequest) GetId() *InternalID {
	if m != nil {
		return m.Id
	}
	return nil
}

type DownloadArtifactsResponse struct {
	DownloadToken        string   `protobuf:"bytes,2,opt,name=download_token,json=downloadToken,proto3" json:"download_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadArtifactsResponse) Reset()         { *m = DownloadArtifactsResponse{} }
func (m *DownloadArtifactsResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadArtifactsResponse) ProtoMessage()    {}
func (*DownloadArtifactsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{15}
}
func (m *DownloadArtifactsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadArtifactsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadArtifactsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadArtifactsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadArtifactsResponse.Merge(m, src)
}
func (m *DownloadArtifactsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadArtifactsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadArtifactsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadArtifactsResponse proto.InternalMessageInfo

func (m *DownloadArtifactsResponse) GetDownloadToken() string {
	if m != nil {
		return m.DownloadToken
	}
	return ""
}

type ListArtifactsRequest struct {
	PageNum              int64       `protobuf:"varint,1,opt,name=page_num,json=pageNum,proto3" json:"page_num,omitempty"`
	PageSize             int64       `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	AppId                *InternalID `protobuf:"bytes,3,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	WithBindApp          bool        `protobuf:"varint,4,opt,name=with_bind_app,json=withBindApp,proto3" json:"with_bind_app,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListArtifactsRequest) Reset()         { *m = ListArtifactsRequest{} }
func (m *ListArtifactsRequest) String() string { return proto.CompactTextString(m) }
func (*ListArtifactsRequest) ProtoMessage()    {}
func (*ListArtifactsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{16}
}
func (m *ListArtifactsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArtifactsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArtifactsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListArtifactsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArtifactsRequest.Merge(m, src)
}
func (m *ListArtifactsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListArtifactsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArtifactsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListArtifactsRequest proto.InternalMessageInfo

func (m *ListArtifactsRequest) GetPageNum() int64 {
	if m != nil {
		return m.PageNum
	}
	return 0
}

func (m *ListArtifactsRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListArtifactsRequest) GetAppId() *InternalID {
	if m != nil {
		return m.AppId
	}
	return nil
}

func (m *ListArtifactsRequest) GetWithBindApp() bool {
	if m != nil {
		return m.WithBindApp
	}
	return false
}

type ListArtifactsResponse struct {
	FileList             []*FileMetadata `protobuf:"bytes,1,rep,name=file_list,json=fileList,proto3" json:"file_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListArtifactsResponse) Reset()         { *m = ListArtifactsResponse{} }
func (m *ListArtifactsResponse) String() string { return proto.CompactTextString(m) }
func (*ListArtifactsResponse) ProtoMessage()    {}
func (*ListArtifactsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{17}
}
func (m *ListArtifactsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArtifactsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArtifactsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListArtifactsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArtifactsResponse.Merge(m, src)
}
func (m *ListArtifactsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListArtifactsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArtifactsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListArtifactsResponse proto.InternalMessageInfo

func (m *ListArtifactsResponse) GetFileList() []*FileMetadata {
	if m != nil {
		return m.FileList
	}
	return nil
}

type App struct {
	Id     *InternalID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Source AppSource   `protobuf:"varint,2,opt,name=source,proto3,enum=librarian.sephirah.v1.AppSource" json:"source,omitempty"`
	// Types that are valid to be assigned to XSourceAppId:
	//	*App_SourceAppId
	XSourceAppId isApp_XSourceAppId `protobuf_oneof:"_source_app_id"`
	// Types that are valid to be assigned to XSourceUrl:
	//	*App_SourceUrl
	XSourceUrl       isApp_XSourceUrl `protobuf_oneof:"_source_url"`
	Name             string           `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Type             AppType          `protobuf:"varint,7,opt,name=type,proto3,enum=librarian.sephirah.v1.AppType" json:"type,omitempty"`
	ShortDescription string           `protobuf:"bytes,8,opt,name=short_description,json=shortDescription,proto3" json:"short_description,omitempty"`
	ImageUrl         string           `protobuf:"bytes,9,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	// Types that are valid to be assigned to XDetails:
	//	*App_Details
	XDetails             isApp_XDetails `protobuf_oneof:"_details"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *App) Reset()         { *m = App{} }
func (m *App) String() string { return proto.CompactTextString(m) }
func (*App) ProtoMessage()    {}
func (*App) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{18}
}
func (m *App) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *App) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_App.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *App) XXX_Merge(src proto.Message) {
	xxx_messageInfo_App.Merge(m, src)
}
func (m *App) XXX_Size() int {
	return m.Size()
}
func (m *App) XXX_DiscardUnknown() {
	xxx_messageInfo_App.DiscardUnknown(m)
}

var xxx_messageInfo_App proto.InternalMessageInfo

type isApp_XSourceAppId interface {
	isApp_XSourceAppId()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isApp_XSourceUrl interface {
	isApp_XSourceUrl()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isApp_XDetails interface {
	isApp_XDetails()
	MarshalTo([]byte) (int, error)
	Size() int
}

type App_SourceAppId struct {
	SourceAppId string `protobuf:"bytes,3,opt,name=source_app_id,json=sourceAppId,proto3,oneof" json:"source_app_id,omitempty"`
}
type App_SourceUrl struct {
	SourceUrl string `protobuf:"bytes,4,opt,name=source_url,json=sourceUrl,proto3,oneof" json:"source_url,omitempty"`
}
type App_Details struct {
	Details *AppDetails `protobuf:"bytes,10,opt,name=details,proto3,oneof" json:"details,omitempty"`
}

func (*App_SourceAppId) isApp_XSourceAppId() {}
func (*App_SourceUrl) isApp_XSourceUrl()     {}
func (*App_Details) isApp_XDetails()         {}

func (m *App) GetXSourceAppId() isApp_XSourceAppId {
	if m != nil {
		return m.XSourceAppId
	}
	return nil
}
func (m *App) GetXSourceUrl() isApp_XSourceUrl {
	if m != nil {
		return m.XSourceUrl
	}
	return nil
}
func (m *App) GetXDetails() isApp_XDetails {
	if m != nil {
		return m.XDetails
	}
	return nil
}

func (m *App) GetId() *InternalID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *App) GetSource() AppSource {
	if m != nil {
		return m.Source
	}
	return AppSource_APP_SOURCE_UNSPECIFIED
}

func (m *App) GetSourceAppId() string {
	if x, ok := m.GetXSourceAppId().(*App_SourceAppId); ok {
		return x.SourceAppId
	}
	return ""
}

func (m *App) GetSourceUrl() string {
	if x, ok := m.GetXSourceUrl().(*App_SourceUrl); ok {
		return x.SourceUrl
	}
	return ""
}

func (m *App) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *App) GetType() AppType {
	if m != nil {
		return m.Type
	}
	return AppType_APP_TYPE_UNSPECIFIED
}

func (m *App) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *App) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

func (m *App) GetDetails() *AppDetails {
	if x, ok := m.GetXDetails().(*App_Details); ok {
		return x.Details
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*App) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*App_SourceAppId)(nil),
		(*App_SourceUrl)(nil),
		(*App_Details)(nil),
	}
}

type AppDetails struct {
	Description          string   `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	ReleaseDate          string   `protobuf:"bytes,2,opt,name=release_date,json=releaseDate,proto3" json:"release_date,omitempty"`
	Developer            string   `protobuf:"bytes,3,opt,name=developer,proto3" json:"developer,omitempty"`
	Publisher            string   `protobuf:"bytes,4,opt,name=publisher,proto3" json:"publisher,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppDetails) Reset()         { *m = AppDetails{} }
func (m *AppDetails) String() string { return proto.CompactTextString(m) }
func (*AppDetails) ProtoMessage()    {}
func (*AppDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f05086cd4f57cb0, []int{19}
}
func (m *AppDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppDetails.Merge(m, src)
}
func (m *AppDetails) XXX_Size() int {
	return m.Size()
}
func (m *AppDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_AppDetails.DiscardUnknown(m)
}

var xxx_messageInfo_AppDetails proto.InternalMessageInfo

func (m *AppDetails) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AppDetails) GetReleaseDate() string {
	if m != nil {
		return m.ReleaseDate
	}
	return ""
}

func (m *AppDetails) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

func (m *AppDetails) GetPublisher() string {
	if m != nil {
		return m.Publisher
	}
	return ""
}

func init() {
	proto.RegisterEnum("librarian.sephirah.v1.AppType", AppType_name, AppType_value)
	proto.RegisterEnum("librarian.sephirah.v1.AppSource", AppSource_name, AppSource_value)
	proto.RegisterType((*CreateAppRequest)(nil), "librarian.sephirah.v1.CreateAppRequest")
	proto.RegisterType((*CreateAppResponse)(nil), "librarian.sephirah.v1.CreateAppResponse")
	proto.RegisterType((*UpdateAppRequest)(nil), "librarian.sephirah.v1.UpdateAppRequest")
	proto.RegisterType((*UpdateAppResponse)(nil), "librarian.sephirah.v1.UpdateAppResponse")
	proto.RegisterType((*ListAppRequest)(nil), "librarian.sephirah.v1.ListAppRequest")
	proto.RegisterType((*ListAppResponse)(nil), "librarian.sephirah.v1.ListAppResponse")
	proto.RegisterType((*ListAppResponse_AppList)(nil), "librarian.sephirah.v1.ListAppResponse.AppList")
	proto.RegisterType((*ListAppResponse_AppListList)(nil), "librarian.sephirah.v1.ListAppResponse.AppListList")
	proto.RegisterType((*BindAppRequest)(nil), "librarian.sephirah.v1.BindAppRequest")
	proto.RegisterType((*BindAppResponse)(nil), "librarian.sephirah.v1.BindAppResponse")
	proto.RegisterType((*UnBindAppRequest)(nil), "librarian.sephirah.v1.UnBindAppRequest")
	proto.RegisterType((*UnBindAppResponse)(nil), "librarian.sephirah.v1.UnBindAppResponse")
	proto.RegisterType((*RefreshAppRequest)(nil), "librarian.sephirah.v1.RefreshAppRequest")
	proto.RegisterType((*RefreshAppResponse)(nil), "librarian.sephirah.v1.RefreshAppResponse")
	proto.RegisterType((*UploadArtifactsRequest)(nil), "librarian.sephirah.v1.UploadArtifactsRequest")
	proto.RegisterType((*UploadArtifactsResponse)(nil), "librarian.sephirah.v1.UploadArtifactsResponse")
	proto.RegisterType((*DownloadArtifactsRequest)(nil), "librarian.sephirah.v1.DownloadArtifactsRequest")
	proto.RegisterType((*DownloadArtifactsResponse)(nil), "librarian.sephirah.v1.DownloadArtifactsResponse")
	proto.RegisterType((*ListArtifactsRequest)(nil), "librarian.sephirah.v1.ListArtifactsRequest")
	proto.RegisterType((*ListArtifactsResponse)(nil), "librarian.sephirah.v1.ListArtifactsResponse")
	proto.RegisterType((*App)(nil), "librarian.sephirah.v1.App")
	proto.RegisterType((*AppDetails)(nil), "librarian.sephirah.v1.AppDetails")
}

func init() {
	proto.RegisterFile("librarian/sephirah/v1/gebura.proto", fileDescriptor_5f05086cd4f57cb0)
}

var fileDescriptor_5f05086cd4f57cb0 = []byte{
	// 1081 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xae, 0xd3, 0xd8, 0xfb, 0x1c, 0x3b, 0xf6, 0x34, 0x6d, 0xdd, 0x14, 0x45, 0xee, 0x56,
	0x28, 0x51, 0x41, 0x8e, 0x12, 0x04, 0x42, 0x02, 0x89, 0xd8, 0xb1, 0x43, 0x2c, 0x25, 0x21, 0xac,
	0xed, 0x4a, 0xe5, 0xb2, 0x1a, 0x7b, 0x27, 0xf1, 0x88, 0xf5, 0xee, 0xb0, 0x33, 0x9b, 0xaa, 0x3d,
	0x23, 0xd4, 0x0b, 0x77, 0x0e, 0xfc, 0x02, 0xc4, 0x8d, 0x3f, 0xc0, 0x91, 0x23, 0x3f, 0x01, 0x85,
	0x13, 0xff, 0x02, 0xcd, 0xec, 0x78, 0xbd, 0xa4, 0x09, 0x8d, 0xc3, 0x85, 0x9b, 0xfd, 0xbe, 0xf7,
	0x7d, 0xfb, 0xcd, 0x9b, 0x79, 0xf3, 0x06, 0x6c, 0x9f, 0x0e, 0x23, 0x1c, 0x51, 0x1c, 0x6c, 0x71,
	0xc2, 0xc6, 0x34, 0xc2, 0xe3, 0xad, 0xf3, 0xed, 0xad, 0x33, 0x32, 0x8c, 0x23, 0xdc, 0x60, 0x51,
	0x28, 0x42, 0x74, 0x2f, 0xcd, 0x69, 0x4c, 0x73, 0x1a, 0xe7, 0xdb, 0x6b, 0xf5, 0xab, 0xa9, 0x43,
	0xcc, 0x49, 0x42, 0xb4, 0x77, 0xa1, 0xb2, 0x17, 0x11, 0x2c, 0x48, 0x93, 0x31, 0x87, 0x7c, 0x13,
	0x13, 0x2e, 0xd0, 0xfb, 0x90, 0xc3, 0x8c, 0xd5, 0x8c, 0xba, 0xb1, 0x59, 0xdc, 0x59, 0x6b, 0x5c,
	0x29, 0xdd, 0x90, 0xf9, 0x32, 0xcd, 0xde, 0x87, 0x6a, 0x46, 0x81, 0xb3, 0x30, 0xe0, 0x04, 0x6d,
	0x83, 0x49, 0x3d, 0xad, 0xf0, 0xf8, 0x1a, 0x85, 0x6e, 0x20, 0x48, 0x14, 0x60, 0xbf, 0xdb, 0x76,
	0x4c, 0xea, 0x49, 0x27, 0x03, 0xe6, 0xfd, 0x17, 0x27, 0x77, 0xa1, 0x9a, 0x51, 0x48, 0x9c, 0xd8,
	0xbf, 0x98, 0x50, 0x3e, 0xa4, 0x5c, 0x64, 0x54, 0x1f, 0x42, 0x81, 0xe1, 0x33, 0xe2, 0x06, 0xf1,
	0x44, 0x49, 0xe7, 0x9c, 0xbc, 0xfc, 0x7f, 0x1c, 0x4f, 0xd0, 0x23, 0xb0, 0x14, 0xc4, 0xe9, 0x2b,
	0x52, 0x33, 0x15, 0xa6, 0x72, 0x7b, 0xf4, 0x15, 0x41, 0x1d, 0x28, 0xf1, 0x30, 0x8e, 0x46, 0xc4,
	0x3d, 0xa5, 0xbe, 0x20, 0x51, 0x2d, 0x57, 0xcf, 0x6d, 0x96, 0x77, 0xea, 0xd7, 0xfb, 0xea, 0xa9,
	0x74, 0x67, 0x39, 0xa1, 0xed, 0x2b, 0x16, 0xfa, 0x0c, 0x8a, 0xe2, 0x25, 0x4b, 0x45, 0x16, 0x95,
	0xc8, 0xfa, 0xf5, 0x22, 0xfd, 0x97, 0x8c, 0x38, 0x20, 0x29, 0x5a, 0xe0, 0x11, 0x58, 0xd4, 0x9b,
	0xd2, 0xef, 0xd4, 0x73, 0xd2, 0x24, 0xf5, 0x34, 0xb8, 0x01, 0x2b, 0xa3, 0x30, 0x10, 0x98, 0x06,
	0xae, 0x47, 0x04, 0xa6, 0x3e, 0xaf, 0x2d, 0xd5, 0x8d, 0xcd, 0x82, 0x53, 0xd6, 0xe1, 0x76, 0x12,
	0x95, 0x2a, 0x2f, 0xa8, 0x18, 0xbb, 0x43, 0x1a, 0x78, 0xb5, 0xbc, 0x4a, 0x29, 0xc8, 0x40, 0x8b,
	0x06, 0x9e, 0xfd, 0x97, 0x09, 0x2b, 0x69, 0xd5, 0xf4, 0x9e, 0xf6, 0x60, 0x59, 0xe2, 0x61, 0x2c,
	0x12, 0x4e, 0xb2, 0x2b, 0x8d, 0x6b, 0x8c, 0x5f, 0x62, 0xcb, 0x85, 0xc8, 0xd0, 0xc1, 0x82, 0x53,
	0xd4, 0x2a, 0xf2, 0x43, 0xe8, 0xcb, 0xac, 0x0b, 0x53, 0x29, 0xee, 0xcc, 0xa7, 0xa8, 0x55, 0x53,
	0xef, 0x6b, 0xbb, 0x90, 0xd7, 0x10, 0xfa, 0x10, 0x0a, 0x98, 0x31, 0xd7, 0xa7, 0x5c, 0xd4, 0x8c,
	0x7a, 0xee, 0x2d, 0x87, 0x28, 0x8f, 0x13, 0xda, 0x1a, 0x86, 0x62, 0x46, 0x1c, 0x39, 0x50, 0x9a,
	0xaa, 0x64, 0xa5, 0xe6, 0x5c, 0xb9, 0x53, 0xc4, 0x33, 0xcd, 0x96, 0x05, 0x79, 0xb9, 0x1f, 0x24,
	0x10, 0xf6, 0xb7, 0x06, 0x94, 0xa5, 0xf1, 0xcc, 0x09, 0xfd, 0x18, 0x96, 0x78, 0x34, 0x72, 0xe7,
	0x69, 0xa1, 0x3b, 0x3c, 0x1a, 0x75, 0x3d, 0xc9, 0xf4, 0xb8, 0x90, 0x4c, 0xf3, 0xc6, 0x4c, 0x8f,
	0x8b, 0xae, 0x67, 0x57, 0x61, 0x25, 0x75, 0xa1, 0x7b, 0xe7, 0x3b, 0x03, 0x2a, 0x83, 0xe0, 0x7f,
	0xe0, 0x4d, 0x76, 0x76, 0x70, 0xd9, 0xdd, 0x3e, 0x54, 0x1d, 0x72, 0x1a, 0x11, 0x3e, 0xce, 0xb8,
	0xbb, 0xc5, 0xc5, 0xb3, 0x0a, 0x28, 0xab, 0xa3, 0xd5, 0x7f, 0x34, 0xe0, 0xfe, 0x80, 0xf9, 0x21,
	0xf6, 0x9a, 0x91, 0xa0, 0xa7, 0x78, 0x24, 0xf8, 0xf4, 0x1b, 0x07, 0x50, 0x3a, 0xa5, 0x3e, 0x71,
	0x27, 0x44, 0x60, 0x0f, 0x0b, 0xac, 0x3f, 0xf7, 0xe4, 0x9a, 0xcf, 0xed, 0x53, 0x9f, 0x1c, 0xe9,
	0x54, 0x67, 0xf9, 0x34, 0xf3, 0x4f, 0x56, 0x44, 0x9e, 0xac, 0xb9, 0x2a, 0x82, 0x19, 0xeb, 0x7a,
	0xf6, 0xa7, 0xf0, 0xe0, 0x0d, 0x77, 0xba, 0x4f, 0x1f, 0xc3, 0x72, 0xac, 0x20, 0x57, 0x84, 0x5f,
	0x93, 0x40, 0xb9, 0xb3, 0x9c, 0x62, 0x12, 0xeb, 0xcb, 0x90, 0x7d, 0x04, 0xb5, 0x76, 0xf8, 0x22,
	0xb8, 0x72, 0x75, 0xb7, 0xa8, 0x60, 0x0b, 0x1e, 0x5e, 0x21, 0xa7, 0xed, 0xbc, 0x0b, 0x65, 0x4f,
	0x83, 0xda, 0x90, 0xa9, 0x0c, 0x95, 0xa6, 0xd1, 0xc4, 0xd2, 0xcf, 0x06, 0xac, 0xaa, 0xce, 0xb9,
	0xec, 0xe7, 0xb6, 0xb7, 0xf5, 0xac, 0xb6, 0xb9, 0xf9, 0x6a, 0x8b, 0x6c, 0x28, 0xa5, 0x77, 0x92,
	0x2b, 0xe7, 0xcf, 0xa2, 0xba, 0x1d, 0x8b, 0xd3, 0x1b, 0xa6, 0xc9, 0x98, 0xfd, 0x1c, 0xee, 0x5d,
	0x72, 0xab, 0x97, 0xbb, 0x0b, 0x96, 0x3a, 0x1c, 0x99, 0x8b, 0xe2, 0x46, 0x07, 0xa3, 0x20, 0x59,
	0x52, 0xd2, 0xfe, 0x35, 0x07, 0xb9, 0x26, 0x63, 0xb7, 0xd8, 0x08, 0xd5, 0x9b, 0x6a, 0xd4, 0xa8,
	0x6a, 0xdc, 0x64, 0x34, 0xe9, 0x7c, 0xb4, 0x91, 0xce, 0xb6, 0x4c, 0xd1, 0x2c, 0x79, 0x5b, 0x27,
	0xe1, 0xa6, 0xac, 0xcc, 0x6b, 0xc3, 0x40, 0x36, 0x80, 0x4e, 0x8c, 0x23, 0x5f, 0x55, 0xc6, 0x3a,
	0x30, 0x1c, 0x2b, 0x89, 0x0d, 0x22, 0x5f, 0xe6, 0x20, 0x58, 0x0c, 0xf0, 0x84, 0xa8, 0xc1, 0x63,
	0x39, 0xea, 0x37, 0xda, 0x81, 0x45, 0x39, 0xc2, 0xd4, 0xa4, 0x79, 0xfb, 0xb8, 0x53, 0xb9, 0xe8,
	0x3d, 0xa8, 0xf2, 0x71, 0x18, 0x09, 0xd7, 0x23, 0x7c, 0x14, 0x51, 0x26, 0x68, 0x18, 0xd4, 0x0a,
	0x4a, 0xb4, 0xa2, 0x80, 0xf6, 0x2c, 0xae, 0xa6, 0xe2, 0x44, 0x9e, 0x06, 0xe9, 0xcb, 0x52, 0x49,
	0x05, 0x15, 0x18, 0x44, 0x3e, 0xda, 0x85, 0xfc, 0x74, 0x1a, 0xc2, 0xbf, 0x16, 0xb4, 0xc9, 0x98,
	0x1e, 0x90, 0x07, 0xa6, 0x33, 0xe5, 0xbc, 0x36, 0x8c, 0x56, 0x05, 0xca, 0xee, 0x3f, 0x2a, 0xd4,
	0x2a, 0x41, 0xd1, 0x9d, 0x95, 0xa2, 0x05, 0x50, 0x98, 0x4e, 0x5c, 0xfb, 0x7b, 0x03, 0x60, 0xa6,
	0x84, 0xea, 0x50, 0xcc, 0xae, 0x40, 0x37, 0x64, 0x26, 0x24, 0x7b, 0x36, 0x22, 0x3e, 0xc1, 0x9c,
	0xb8, 0xf2, 0x01, 0xa3, 0x5b, 0xa4, 0xa8, 0x63, 0x6d, 0x2c, 0x08, 0x7a, 0x07, 0x2c, 0x8f, 0x9c,
	0x13, 0x3f, 0x64, 0xea, 0xe5, 0x21, 0xf1, 0x59, 0x40, 0xa2, 0x2c, 0x1e, 0xfa, 0x94, 0x8f, 0xd5,
	0x93, 0x42, 0xa1, 0x69, 0xe0, 0xe9, 0x47, 0x6a, 0x24, 0xca, 0xca, 0xa2, 0x1a, 0xac, 0x36, 0x4f,
	0x4e, 0xdc, 0xfe, 0xf3, 0x93, 0x8e, 0x3b, 0x38, 0xee, 0x9d, 0x74, 0xf6, 0xba, 0xfb, 0xdd, 0x4e,
	0xbb, 0xb2, 0x80, 0xaa, 0x50, 0x4a, 0x91, 0xcf, 0x9b, 0x47, 0x9d, 0x8a, 0xf1, 0xf4, 0x19, 0x58,
	0xe9, 0x51, 0x41, 0x6b, 0x70, 0x5f, 0xe2, 0xbd, 0x2f, 0x06, 0xce, 0xde, 0x65, 0xee, 0x03, 0xb8,
	0x9b, 0xc1, 0xba, 0xc7, 0xfd, 0x8e, 0x73, 0xdc, 0x3c, 0xac, 0x18, 0x68, 0x15, 0x2a, 0x19, 0xa0,
	0xd7, 0xef, 0x34, 0x8f, 0x2a, 0x66, 0xcb, 0xfd, 0xed, 0x62, 0xdd, 0xf8, 0xfd, 0x62, 0xdd, 0xf8,
	0xe3, 0x62, 0xdd, 0xf8, 0xe1, 0xcf, 0xf5, 0x85, 0xaf, 0x36, 0xce, 0xa8, 0x18, 0xc7, 0xc3, 0xc6,
	0x28, 0x9c, 0x6c, 0x89, 0x98, 0x8e, 0xe3, 0xe1, 0xd6, 0x9b, 0x6f, 0xd7, 0x4f, 0xce, 0xb7, 0x7f,
	0x32, 0x9f, 0xf4, 0x63, 0x7a, 0x10, 0x0f, 0x1b, 0x27, 0xf2, 0xfd, 0xca, 0x1b, 0x87, 0xe9, 0x36,
	0xf6, 0xa6, 0xdb, 0xf8, 0x6c, 0x7b, 0xb8, 0xa4, 0x5e, 0xb7, 0x1f, 0xfc, 0x1d, 0x00, 0x00, 0xff,
	0xff, 0x93, 0x71, 0x74, 0xd2, 0x3c, 0x0b, 0x00, 0x00,
}

func (m *CreateAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithBind {
		i--
		if m.WithBind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ContainDetails {
		i--
		if m.ContainDetails {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.IdFilter) > 0 {
		dAtA5 := make([]byte, len(m.IdFilter)*10)
		var j4 int
		for _, num1 := range m.IdFilter {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintGebura(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TypeFilter) > 0 {
		dAtA7 := make([]byte, len(m.TypeFilter)*10)
		var j6 int
		for _, num := range m.TypeFilter {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintGebura(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourceFilter) > 0 {
		dAtA9 := make([]byte, len(m.SourceFilter)*10)
		var j8 int
		for _, num := range m.SourceFilter {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintGebura(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if m.PageNum != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.PageNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListAppResponse_WithoutBind) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppResponse_WithoutBind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WithoutBind != nil {
		{
			size, err := m.WithoutBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ListAppResponse_WithBind) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppResponse_WithBind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WithBind != nil {
		{
			size, err := m.WithBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ListAppResponse_AppList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppResponse_AppList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppResponse_AppList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppList) > 0 {
		for iNdEx := len(m.AppList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGebura(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListAppResponse_AppListList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppResponse_AppListList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppResponse_AppListList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppListList) > 0 {
		for iNdEx := len(m.AppListList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppListList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGebura(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BindAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BindAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstId != nil {
		{
			size, err := m.DstId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcId != nil {
		{
			size, err := m.SrcId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BindAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BindAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnBindAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnBindAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnBindAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstId != nil {
		{
			size, err := m.DstId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcId != nil {
		{
			size, err := m.SrcId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnBindAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnBindAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnBindAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RefreshAppRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshAppRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshAppRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RefreshAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshAppResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshAppResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UploadArtifactsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadArtifactsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadArtifactsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppId != nil {
		{
			size, err := m.AppId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FileMetadata != nil {
		{
			size, err := m.FileMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadArtifactsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadArtifactsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadArtifactsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UploadToken) > 0 {
		i -= len(m.UploadToken)
		copy(dAtA[i:], m.UploadToken)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.UploadToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadArtifactsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadArtifactsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadArtifactsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadArtifactsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadArtifactsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadArtifactsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DownloadToken) > 0 {
		i -= len(m.DownloadToken)
		copy(dAtA[i:], m.DownloadToken)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.DownloadToken)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ListArtifactsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArtifactsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListArtifactsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithBindApp {
		i--
		if m.WithBindApp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AppId != nil {
		{
			size, err := m.AppId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if m.PageNum != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.PageNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListArtifactsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArtifactsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListArtifactsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGebura(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *App) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XDetails != nil {
		{
			size := m.XDetails.Size()
			i -= size
			if _, err := m.XDetails.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ShortDescription) > 0 {
		i -= len(m.ShortDescription)
		copy(dAtA[i:], m.ShortDescription)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.ShortDescription)))
		i--
		dAtA[i] = 0x42
	}
	if m.Type != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.XSourceUrl != nil {
		{
			size := m.XSourceUrl.Size()
			i -= size
			if _, err := m.XSourceUrl.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XSourceAppId != nil {
		{
			size := m.XSourceAppId.Size()
			i -= size
			if _, err := m.XSourceAppId.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Source != 0 {
		i = encodeVarintGebura(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *App_SourceAppId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *App_SourceAppId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SourceAppId)
	copy(dAtA[i:], m.SourceAppId)
	i = encodeVarintGebura(dAtA, i, uint64(len(m.SourceAppId)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *App_SourceUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *App_SourceUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SourceUrl)
	copy(dAtA[i:], m.SourceUrl)
	i = encodeVarintGebura(dAtA, i, uint64(len(m.SourceUrl)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *App_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *App_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGebura(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AppDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Publisher) > 0 {
		i -= len(m.Publisher)
		copy(dAtA[i:], m.Publisher)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.Publisher)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Developer) > 0 {
		i -= len(m.Developer)
		copy(dAtA[i:], m.Developer)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.Developer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReleaseDate) > 0 {
		i -= len(m.ReleaseDate)
		copy(dAtA[i:], m.ReleaseDate)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.ReleaseDate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintGebura(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGebura(dAtA []byte, offset int, v uint64) int {
	offset -= sovGebura(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageNum != 0 {
		n += 1 + sovGebura(uint64(m.PageNum))
	}
	if m.PageSize != 0 {
		n += 1 + sovGebura(uint64(m.PageSize))
	}
	if len(m.SourceFilter) > 0 {
		l = 0
		for _, e := range m.SourceFilter {
			l += sovGebura(uint64(e))
		}
		n += 1 + sovGebura(uint64(l)) + l
	}
	if len(m.TypeFilter) > 0 {
		l = 0
		for _, e := range m.TypeFilter {
			l += sovGebura(uint64(e))
		}
		n += 1 + sovGebura(uint64(l)) + l
	}
	if len(m.IdFilter) > 0 {
		l = 0
		for _, e := range m.IdFilter {
			l += sovGebura(uint64(e))
		}
		n += 1 + sovGebura(uint64(l)) + l
	}
	if m.ContainDetails {
		n += 2
	}
	if m.WithBind {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppResponse_WithoutBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithoutBind != nil {
		l = m.WithoutBind.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	return n
}
func (m *ListAppResponse_WithBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithBind != nil {
		l = m.WithBind.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	return n
}
func (m *ListAppResponse_AppList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppList) > 0 {
		for _, e := range m.AppList {
			l = e.Size()
			n += 1 + l + sovGebura(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppResponse_AppListList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppListList) > 0 {
		for _, e := range m.AppListList {
			l = e.Size()
			n += 1 + l + sovGebura(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BindAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcId != nil {
		l = m.SrcId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.DstId != nil {
		l = m.DstId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BindAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnBindAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcId != nil {
		l = m.SrcId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.DstId != nil {
		l = m.DstId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnBindAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefreshAppRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefreshAppResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadArtifactsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileMetadata != nil {
		l = m.FileMetadata.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.AppId != nil {
		l = m.AppId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadArtifactsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UploadToken)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadArtifactsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadArtifactsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DownloadToken)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListArtifactsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageNum != 0 {
		n += 1 + sovGebura(uint64(m.PageNum))
	}
	if m.PageSize != 0 {
		n += 1 + sovGebura(uint64(m.PageSize))
	}
	if m.AppId != nil {
		l = m.AppId.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.WithBindApp {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListArtifactsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FileList) > 0 {
		for _, e := range m.FileList {
			l = e.Size()
			n += 1 + l + sovGebura(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *App) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.Source != 0 {
		n += 1 + sovGebura(uint64(m.Source))
	}
	if m.XSourceAppId != nil {
		n += m.XSourceAppId.Size()
	}
	if m.XSourceUrl != nil {
		n += m.XSourceUrl.Size()
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGebura(uint64(m.Type))
	}
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XDetails != nil {
		n += m.XDetails.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *App_SourceAppId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceAppId)
	n += 1 + l + sovGebura(uint64(l))
	return n
}
func (m *App_SourceUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceUrl)
	n += 1 + l + sovGebura(uint64(l))
	return n
}
func (m *App_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovGebura(uint64(l))
	}
	return n
}
func (m *AppDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	l = len(m.ReleaseDate)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	l = len(m.Developer)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	l = len(m.Publisher)
	if l > 0 {
		n += 1 + l + sovGebura(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGebura(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGebura(x uint64) (n int) {
	return sovGebura(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &InternalID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v AppSource
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= AppSource(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SourceFilter = append(m.SourceFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGebura
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGebura
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SourceFilter) == 0 {
					m.SourceFilter = make([]AppSource, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v AppSource
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGebura
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= AppSource(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SourceFilter = append(m.SourceFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFilter", wireType)
			}
		case 4:
			if wireType == 0 {
				var v AppType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= AppType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TypeFilter = append(m.TypeFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGebura
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGebura
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.TypeFilter) == 0 {
					m.TypeFilter = make([]AppType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v AppType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGebura
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= AppType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TypeFilter = append(m.TypeFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeFilter", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdFilter = append(m.IdFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGebura
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGebura
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGebura
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdFilter) == 0 {
					m.IdFilter = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGebura
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdFilter = append(m.IdFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdFilter", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainDetails", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainDetails = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBind = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListAppResponse_AppList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ListAppResponse_WithoutBind{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListAppResponse_AppListList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ListAppResponse_WithBind{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppResponse_AppList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppList = append(m.AppList, &App{})
			if err := m.AppList[len(m.AppList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppResponse_AppListList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppListList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppListList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppListList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppListList = append(m.AppListList, &ListAppResponse_AppList{})
			if err := m.AppListList[len(m.AppListList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcId == nil {
				m.SrcId = &InternalID{}
			}
			if err := m.SrcId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstId == nil {
				m.DstId = &InternalID{}
			}
			if err := m.DstId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnBindAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnBindAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnBindAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcId == nil {
				m.SrcId = &InternalID{}
			}
			if err := m.SrcId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstId == nil {
				m.DstId = &InternalID{}
			}
			if err := m.DstId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnBindAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnBindAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnBindAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshAppRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshAppRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshAppRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &InternalID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadArtifactsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadArtifactsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadArtifactsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMetadata == nil {
				m.FileMetadata = &FileMetadata{}
			}
			if err := m.FileMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppId == nil {
				m.AppId = &InternalID{}
			}
			if err := m.AppId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadArtifactsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadArtifactsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadArtifactsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadArtifactsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadArtifactsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadArtifactsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &InternalID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadArtifactsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadArtifactsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadArtifactsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArtifactsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArtifactsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArtifactsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppId == nil {
				m.AppId = &InternalID{}
			}
			if err := m.AppId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBindApp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBindApp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArtifactsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArtifactsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArtifactsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, &FileMetadata{})
			if err := m.FileList[len(m.FileList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &InternalID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= AppSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSourceAppId = &App_SourceAppId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSourceUrl = &App_SourceUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AppType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XDetails = &App_Details{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Developer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Developer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGebura
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGebura
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publisher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGebura(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGebura
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGebura(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGebura
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGebura
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGebura
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGebura
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGebura
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGebura        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGebura          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGebura = fmt.Errorf("proto: unexpected end of group")
)
