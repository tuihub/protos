// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: librarian/mapper/v1/mapper.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type VertexType int32

const (
	VertexType_VERTEX_TYPE_UNSPECIFIED VertexType = 0
	VertexType_VERTEX_TYPE_ABSTRACT    VertexType = 1
	VertexType_VERTEX_TYPE_ENTITY      VertexType = 2
	VertexType_VERTEX_TYPE_MESSAGE     VertexType = 3
	VertexType_VERTEX_TYPE_OBJECT      VertexType = 4
)

var VertexType_name = map[int32]string{
	0: "VERTEX_TYPE_UNSPECIFIED",
	1: "VERTEX_TYPE_ABSTRACT",
	2: "VERTEX_TYPE_ENTITY",
	3: "VERTEX_TYPE_MESSAGE",
	4: "VERTEX_TYPE_OBJECT",
}

var VertexType_value = map[string]int32{
	"VERTEX_TYPE_UNSPECIFIED": 0,
	"VERTEX_TYPE_ABSTRACT":    1,
	"VERTEX_TYPE_ENTITY":      2,
	"VERTEX_TYPE_MESSAGE":     3,
	"VERTEX_TYPE_OBJECT":      4,
}

func (x VertexType) String() string {
	return proto.EnumName(VertexType_name, int32(x))
}

func (VertexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{0}
}

type EdgeType int32

const (
	EdgeType_EDGE_TYPE_UNSPECIFIED EdgeType = 0
	EdgeType_EDGE_TYPE_GENERAL     EdgeType = 1
	EdgeType_EDGE_TYPE_EQUAL       EdgeType = 2
	EdgeType_EDGE_TYPE_CREATE      EdgeType = 3
	EdgeType_EDGE_TYPE_ENJOY       EdgeType = 4
	EdgeType_EDGE_TYPE_MENTION     EdgeType = 5
	EdgeType_EDGE_TYPE_DERIVE      EdgeType = 6
	EdgeType_EDGE_TYPE_CONTROL     EdgeType = 7
	EdgeType_EDGE_TYPE_FOLLOW      EdgeType = 8
)

var EdgeType_name = map[int32]string{
	0: "EDGE_TYPE_UNSPECIFIED",
	1: "EDGE_TYPE_GENERAL",
	2: "EDGE_TYPE_EQUAL",
	3: "EDGE_TYPE_CREATE",
	4: "EDGE_TYPE_ENJOY",
	5: "EDGE_TYPE_MENTION",
	6: "EDGE_TYPE_DERIVE",
	7: "EDGE_TYPE_CONTROL",
	8: "EDGE_TYPE_FOLLOW",
}

var EdgeType_value = map[string]int32{
	"EDGE_TYPE_UNSPECIFIED": 0,
	"EDGE_TYPE_GENERAL":     1,
	"EDGE_TYPE_EQUAL":       2,
	"EDGE_TYPE_CREATE":      3,
	"EDGE_TYPE_ENJOY":       4,
	"EDGE_TYPE_MENTION":     5,
	"EDGE_TYPE_DERIVE":      6,
	"EDGE_TYPE_CONTROL":     7,
	"EDGE_TYPE_FOLLOW":      8,
}

func (x EdgeType) String() string {
	return proto.EnumName(EdgeType_name, int32(x))
}

func (EdgeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{1}
}

type EdgeDirection int32

const (
	EdgeDirection_EDGE_DIRECTION_UNSPECIFIED EdgeDirection = 0
	EdgeDirection_EDGE_DIRECTION_OUT         EdgeDirection = 1
	EdgeDirection_EDGE_DIRECTION_IN          EdgeDirection = 2
	EdgeDirection_EDGE_DIRECTION_BOTH        EdgeDirection = 3
)

var EdgeDirection_name = map[int32]string{
	0: "EDGE_DIRECTION_UNSPECIFIED",
	1: "EDGE_DIRECTION_OUT",
	2: "EDGE_DIRECTION_IN",
	3: "EDGE_DIRECTION_BOTH",
}

var EdgeDirection_value = map[string]int32{
	"EDGE_DIRECTION_UNSPECIFIED": 0,
	"EDGE_DIRECTION_OUT":         1,
	"EDGE_DIRECTION_IN":          2,
	"EDGE_DIRECTION_BOTH":        3,
}

func (x EdgeDirection) String() string {
	return proto.EnumName(EdgeDirection_name, int32(x))
}

func (EdgeDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{2}
}

type InsertVertexRequest struct {
	VertexList           []*Vertex `protobuf:"bytes,1,rep,name=vertex_list,json=vertexList,proto3" json:"vertex_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InsertVertexRequest) Reset()         { *m = InsertVertexRequest{} }
func (m *InsertVertexRequest) String() string { return proto.CompactTextString(m) }
func (*InsertVertexRequest) ProtoMessage()    {}
func (*InsertVertexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{0}
}
func (m *InsertVertexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertVertexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertVertexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertVertexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertVertexRequest.Merge(m, src)
}
func (m *InsertVertexRequest) XXX_Size() int {
	return m.Size()
}
func (m *InsertVertexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertVertexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InsertVertexRequest proto.InternalMessageInfo

func (m *InsertVertexRequest) GetVertexList() []*Vertex {
	if m != nil {
		return m.VertexList
	}
	return nil
}

type InsertVertexResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertVertexResponse) Reset()         { *m = InsertVertexResponse{} }
func (m *InsertVertexResponse) String() string { return proto.CompactTextString(m) }
func (*InsertVertexResponse) ProtoMessage()    {}
func (*InsertVertexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{1}
}
func (m *InsertVertexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertVertexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertVertexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertVertexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertVertexResponse.Merge(m, src)
}
func (m *InsertVertexResponse) XXX_Size() int {
	return m.Size()
}
func (m *InsertVertexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertVertexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InsertVertexResponse proto.InternalMessageInfo

type DeleteVertexRequest struct {
	VidList              []int64  `protobuf:"varint,1,rep,packed,name=vid_list,json=vidList,proto3" json:"vid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteVertexRequest) Reset()         { *m = DeleteVertexRequest{} }
func (m *DeleteVertexRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteVertexRequest) ProtoMessage()    {}
func (*DeleteVertexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{2}
}
func (m *DeleteVertexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVertexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVertexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVertexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVertexRequest.Merge(m, src)
}
func (m *DeleteVertexRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVertexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVertexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVertexRequest proto.InternalMessageInfo

func (m *DeleteVertexRequest) GetVidList() []int64 {
	if m != nil {
		return m.VidList
	}
	return nil
}

type DeleteVertexResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteVertexResponse) Reset()         { *m = DeleteVertexResponse{} }
func (m *DeleteVertexResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteVertexResponse) ProtoMessage()    {}
func (*DeleteVertexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{3}
}
func (m *DeleteVertexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVertexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVertexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVertexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVertexResponse.Merge(m, src)
}
func (m *DeleteVertexResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVertexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVertexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVertexResponse proto.InternalMessageInfo

type UpdateVertexRequest struct {
	VertexList           []*Vertex `protobuf:"bytes,1,rep,name=vertex_list,json=vertexList,proto3" json:"vertex_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UpdateVertexRequest) Reset()         { *m = UpdateVertexRequest{} }
func (m *UpdateVertexRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateVertexRequest) ProtoMessage()    {}
func (*UpdateVertexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{4}
}
func (m *UpdateVertexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVertexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVertexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateVertexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVertexRequest.Merge(m, src)
}
func (m *UpdateVertexRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVertexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVertexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVertexRequest proto.InternalMessageInfo

func (m *UpdateVertexRequest) GetVertexList() []*Vertex {
	if m != nil {
		return m.VertexList
	}
	return nil
}

type UpdateVertexResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateVertexResponse) Reset()         { *m = UpdateVertexResponse{} }
func (m *UpdateVertexResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateVertexResponse) ProtoMessage()    {}
func (*UpdateVertexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{5}
}
func (m *UpdateVertexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVertexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVertexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateVertexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVertexResponse.Merge(m, src)
}
func (m *UpdateVertexResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVertexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVertexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVertexResponse proto.InternalMessageInfo

type InsertEdgeRequest struct {
	EdgeList             []*Edge  `protobuf:"bytes,1,rep,name=edge_list,json=edgeList,proto3" json:"edge_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertEdgeRequest) Reset()         { *m = InsertEdgeRequest{} }
func (m *InsertEdgeRequest) String() string { return proto.CompactTextString(m) }
func (*InsertEdgeRequest) ProtoMessage()    {}
func (*InsertEdgeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{6}
}
func (m *InsertEdgeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertEdgeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertEdgeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertEdgeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertEdgeRequest.Merge(m, src)
}
func (m *InsertEdgeRequest) XXX_Size() int {
	return m.Size()
}
func (m *InsertEdgeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertEdgeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InsertEdgeRequest proto.InternalMessageInfo

func (m *InsertEdgeRequest) GetEdgeList() []*Edge {
	if m != nil {
		return m.EdgeList
	}
	return nil
}

type InsertEdgeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertEdgeResponse) Reset()         { *m = InsertEdgeResponse{} }
func (m *InsertEdgeResponse) String() string { return proto.CompactTextString(m) }
func (*InsertEdgeResponse) ProtoMessage()    {}
func (*InsertEdgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{7}
}
func (m *InsertEdgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertEdgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertEdgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertEdgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertEdgeResponse.Merge(m, src)
}
func (m *InsertEdgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *InsertEdgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertEdgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InsertEdgeResponse proto.InternalMessageInfo

type DeleteEdgeRequest struct {
	EdgeList             []*Edge  `protobuf:"bytes,2,rep,name=edge_list,json=edgeList,proto3" json:"edge_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteEdgeRequest) Reset()         { *m = DeleteEdgeRequest{} }
func (m *DeleteEdgeRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteEdgeRequest) ProtoMessage()    {}
func (*DeleteEdgeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{8}
}
func (m *DeleteEdgeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteEdgeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteEdgeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteEdgeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteEdgeRequest.Merge(m, src)
}
func (m *DeleteEdgeRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteEdgeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteEdgeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteEdgeRequest proto.InternalMessageInfo

func (m *DeleteEdgeRequest) GetEdgeList() []*Edge {
	if m != nil {
		return m.EdgeList
	}
	return nil
}

type DeleteEdgeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteEdgeResponse) Reset()         { *m = DeleteEdgeResponse{} }
func (m *DeleteEdgeResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteEdgeResponse) ProtoMessage()    {}
func (*DeleteEdgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{9}
}
func (m *DeleteEdgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteEdgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteEdgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteEdgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteEdgeResponse.Merge(m, src)
}
func (m *DeleteEdgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteEdgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteEdgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteEdgeResponse proto.InternalMessageInfo

type UpdateEdgeRequest struct {
	EdgeList             []*Edge  `protobuf:"bytes,3,rep,name=edge_list,json=edgeList,proto3" json:"edge_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateEdgeRequest) Reset()         { *m = UpdateEdgeRequest{} }
func (m *UpdateEdgeRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateEdgeRequest) ProtoMessage()    {}
func (*UpdateEdgeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{10}
}
func (m *UpdateEdgeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEdgeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEdgeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEdgeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEdgeRequest.Merge(m, src)
}
func (m *UpdateEdgeRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEdgeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEdgeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEdgeRequest proto.InternalMessageInfo

func (m *UpdateEdgeRequest) GetEdgeList() []*Edge {
	if m != nil {
		return m.EdgeList
	}
	return nil
}

type UpdateEdgeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateEdgeResponse) Reset()         { *m = UpdateEdgeResponse{} }
func (m *UpdateEdgeResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateEdgeResponse) ProtoMessage()    {}
func (*UpdateEdgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{11}
}
func (m *UpdateEdgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEdgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEdgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEdgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEdgeResponse.Merge(m, src)
}
func (m *UpdateEdgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEdgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEdgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEdgeResponse proto.InternalMessageInfo

type GoFromVertexRequest struct {
	SrcVid               int64         `protobuf:"varint,1,opt,name=src_vid,json=srcVid,proto3" json:"src_vid,omitempty"`
	EdgeTypeFilter       []EdgeType    `protobuf:"varint,2,rep,packed,name=edge_type_filter,json=edgeTypeFilter,proto3,enum=librarian.mapper.v1.EdgeType" json:"edge_type_filter,omitempty"`
	EdgeDirection        EdgeDirection `protobuf:"varint,3,opt,name=edge_direction,json=edgeDirection,proto3,enum=librarian.mapper.v1.EdgeDirection" json:"edge_direction,omitempty"`
	MinStep              int64         `protobuf:"varint,4,opt,name=min_step,json=minStep,proto3" json:"min_step,omitempty"`
	MaxStep              int64         `protobuf:"varint,5,opt,name=max_step,json=maxStep,proto3" json:"max_step,omitempty"`
	Limit                int64         `protobuf:"varint,14,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               int64         `protobuf:"varint,15,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GoFromVertexRequest) Reset()         { *m = GoFromVertexRequest{} }
func (m *GoFromVertexRequest) String() string { return proto.CompactTextString(m) }
func (*GoFromVertexRequest) ProtoMessage()    {}
func (*GoFromVertexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{12}
}
func (m *GoFromVertexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoFromVertexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoFromVertexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoFromVertexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoFromVertexRequest.Merge(m, src)
}
func (m *GoFromVertexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GoFromVertexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GoFromVertexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GoFromVertexRequest proto.InternalMessageInfo

func (m *GoFromVertexRequest) GetSrcVid() int64 {
	if m != nil {
		return m.SrcVid
	}
	return 0
}

func (m *GoFromVertexRequest) GetEdgeTypeFilter() []EdgeType {
	if m != nil {
		return m.EdgeTypeFilter
	}
	return nil
}

func (m *GoFromVertexRequest) GetEdgeDirection() EdgeDirection {
	if m != nil {
		return m.EdgeDirection
	}
	return EdgeDirection_EDGE_DIRECTION_UNSPECIFIED
}

func (m *GoFromVertexRequest) GetMinStep() int64 {
	if m != nil {
		return m.MinStep
	}
	return 0
}

func (m *GoFromVertexRequest) GetMaxStep() int64 {
	if m != nil {
		return m.MaxStep
	}
	return 0
}

func (m *GoFromVertexRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GoFromVertexRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type GoFromVertexResponse struct {
	VertexList           []*Vertex `protobuf:"bytes,1,rep,name=vertex_list,json=vertexList,proto3" json:"vertex_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GoFromVertexResponse) Reset()         { *m = GoFromVertexResponse{} }
func (m *GoFromVertexResponse) String() string { return proto.CompactTextString(m) }
func (*GoFromVertexResponse) ProtoMessage()    {}
func (*GoFromVertexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{13}
}
func (m *GoFromVertexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoFromVertexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoFromVertexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoFromVertexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoFromVertexResponse.Merge(m, src)
}
func (m *GoFromVertexResponse) XXX_Size() int {
	return m.Size()
}
func (m *GoFromVertexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GoFromVertexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GoFromVertexResponse proto.InternalMessageInfo

func (m *GoFromVertexResponse) GetVertexList() []*Vertex {
	if m != nil {
		return m.VertexList
	}
	return nil
}

type FetchEqualVertexRequest struct {
	SrcVid               int64    `protobuf:"varint,1,opt,name=src_vid,json=srcVid,proto3" json:"src_vid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchEqualVertexRequest) Reset()         { *m = FetchEqualVertexRequest{} }
func (m *FetchEqualVertexRequest) String() string { return proto.CompactTextString(m) }
func (*FetchEqualVertexRequest) ProtoMessage()    {}
func (*FetchEqualVertexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{14}
}
func (m *FetchEqualVertexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEqualVertexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEqualVertexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEqualVertexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEqualVertexRequest.Merge(m, src)
}
func (m *FetchEqualVertexRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchEqualVertexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEqualVertexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEqualVertexRequest proto.InternalMessageInfo

func (m *FetchEqualVertexRequest) GetSrcVid() int64 {
	if m != nil {
		return m.SrcVid
	}
	return 0
}

type FetchEqualVertexResponse struct {
	VertexList           []*Vertex `protobuf:"bytes,1,rep,name=vertex_list,json=vertexList,proto3" json:"vertex_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FetchEqualVertexResponse) Reset()         { *m = FetchEqualVertexResponse{} }
func (m *FetchEqualVertexResponse) String() string { return proto.CompactTextString(m) }
func (*FetchEqualVertexResponse) ProtoMessage()    {}
func (*FetchEqualVertexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{15}
}
func (m *FetchEqualVertexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEqualVertexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEqualVertexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEqualVertexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEqualVertexResponse.Merge(m, src)
}
func (m *FetchEqualVertexResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchEqualVertexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEqualVertexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEqualVertexResponse proto.InternalMessageInfo

func (m *FetchEqualVertexResponse) GetVertexList() []*Vertex {
	if m != nil {
		return m.VertexList
	}
	return nil
}

type FetchEqualVertexNeighborRequest struct {
	SrcVid               int64         `protobuf:"varint,1,opt,name=src_vid,json=srcVid,proto3" json:"src_vid,omitempty"`
	EdgeTypeFilter       []EdgeType    `protobuf:"varint,2,rep,packed,name=edge_type_filter,json=edgeTypeFilter,proto3,enum=librarian.mapper.v1.EdgeType" json:"edge_type_filter,omitempty"`
	EdgeDirection        EdgeDirection `protobuf:"varint,3,opt,name=edge_direction,json=edgeDirection,proto3,enum=librarian.mapper.v1.EdgeDirection" json:"edge_direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FetchEqualVertexNeighborRequest) Reset()         { *m = FetchEqualVertexNeighborRequest{} }
func (m *FetchEqualVertexNeighborRequest) String() string { return proto.CompactTextString(m) }
func (*FetchEqualVertexNeighborRequest) ProtoMessage()    {}
func (*FetchEqualVertexNeighborRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{16}
}
func (m *FetchEqualVertexNeighborRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEqualVertexNeighborRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEqualVertexNeighborRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEqualVertexNeighborRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEqualVertexNeighborRequest.Merge(m, src)
}
func (m *FetchEqualVertexNeighborRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchEqualVertexNeighborRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEqualVertexNeighborRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEqualVertexNeighborRequest proto.InternalMessageInfo

func (m *FetchEqualVertexNeighborRequest) GetSrcVid() int64 {
	if m != nil {
		return m.SrcVid
	}
	return 0
}

func (m *FetchEqualVertexNeighborRequest) GetEdgeTypeFilter() []EdgeType {
	if m != nil {
		return m.EdgeTypeFilter
	}
	return nil
}

func (m *FetchEqualVertexNeighborRequest) GetEdgeDirection() EdgeDirection {
	if m != nil {
		return m.EdgeDirection
	}
	return EdgeDirection_EDGE_DIRECTION_UNSPECIFIED
}

type FetchEqualVertexNeighborResponse struct {
	EdgeList             []*Edge  `protobuf:"bytes,1,rep,name=edge_list,json=edgeList,proto3" json:"edge_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchEqualVertexNeighborResponse) Reset()         { *m = FetchEqualVertexNeighborResponse{} }
func (m *FetchEqualVertexNeighborResponse) String() string { return proto.CompactTextString(m) }
func (*FetchEqualVertexNeighborResponse) ProtoMessage()    {}
func (*FetchEqualVertexNeighborResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{17}
}
func (m *FetchEqualVertexNeighborResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchEqualVertexNeighborResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchEqualVertexNeighborResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchEqualVertexNeighborResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchEqualVertexNeighborResponse.Merge(m, src)
}
func (m *FetchEqualVertexNeighborResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchEqualVertexNeighborResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchEqualVertexNeighborResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchEqualVertexNeighborResponse proto.InternalMessageInfo

func (m *FetchEqualVertexNeighborResponse) GetEdgeList() []*Edge {
	if m != nil {
		return m.EdgeList
	}
	return nil
}

type FindPathRequest struct {
	SrcVid               []int64       `protobuf:"varint,1,rep,packed,name=src_vid,json=srcVid,proto3" json:"src_vid,omitempty"`
	DstVid               []int64       `protobuf:"varint,2,rep,packed,name=dst_vid,json=dstVid,proto3" json:"dst_vid,omitempty"`
	EdgeTypeFilter       []EdgeType    `protobuf:"varint,3,rep,packed,name=edge_type_filter,json=edgeTypeFilter,proto3,enum=librarian.mapper.v1.EdgeType" json:"edge_type_filter,omitempty"`
	EdgeDirection        EdgeDirection `protobuf:"varint,4,opt,name=edge_direction,json=edgeDirection,proto3,enum=librarian.mapper.v1.EdgeDirection" json:"edge_direction,omitempty"`
	MaxStep              int64         `protobuf:"varint,5,opt,name=max_step,json=maxStep,proto3" json:"max_step,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FindPathRequest) Reset()         { *m = FindPathRequest{} }
func (m *FindPathRequest) String() string { return proto.CompactTextString(m) }
func (*FindPathRequest) ProtoMessage()    {}
func (*FindPathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{18}
}
func (m *FindPathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindPathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindPathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindPathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindPathRequest.Merge(m, src)
}
func (m *FindPathRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindPathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindPathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindPathRequest proto.InternalMessageInfo

func (m *FindPathRequest) GetSrcVid() []int64 {
	if m != nil {
		return m.SrcVid
	}
	return nil
}

func (m *FindPathRequest) GetDstVid() []int64 {
	if m != nil {
		return m.DstVid
	}
	return nil
}

func (m *FindPathRequest) GetEdgeTypeFilter() []EdgeType {
	if m != nil {
		return m.EdgeTypeFilter
	}
	return nil
}

func (m *FindPathRequest) GetEdgeDirection() EdgeDirection {
	if m != nil {
		return m.EdgeDirection
	}
	return EdgeDirection_EDGE_DIRECTION_UNSPECIFIED
}

func (m *FindPathRequest) GetMaxStep() int64 {
	if m != nil {
		return m.MaxStep
	}
	return 0
}

type FindPathResponse struct {
	PathList             []*FindPathResponse_SinglePath `protobuf:"bytes,1,rep,name=path_list,json=pathList,proto3" json:"path_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *FindPathResponse) Reset()         { *m = FindPathResponse{} }
func (m *FindPathResponse) String() string { return proto.CompactTextString(m) }
func (*FindPathResponse) ProtoMessage()    {}
func (*FindPathResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{19}
}
func (m *FindPathResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindPathResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindPathResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindPathResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindPathResponse.Merge(m, src)
}
func (m *FindPathResponse) XXX_Size() int {
	return m.Size()
}
func (m *FindPathResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindPathResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindPathResponse proto.InternalMessageInfo

func (m *FindPathResponse) GetPathList() []*FindPathResponse_SinglePath {
	if m != nil {
		return m.PathList
	}
	return nil
}

type FindPathResponse_SinglePath struct {
	// Path from edge_list[0].src_vid to edge_list[-1].dst_vid
	// If reverse edge is allowed, begin vid may not be src_vid but dst_vid, the end vid is the same
	EdgeList             []*Edge  `protobuf:"bytes,3,rep,name=edge_list,json=edgeList,proto3" json:"edge_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindPathResponse_SinglePath) Reset()         { *m = FindPathResponse_SinglePath{} }
func (m *FindPathResponse_SinglePath) String() string { return proto.CompactTextString(m) }
func (*FindPathResponse_SinglePath) ProtoMessage()    {}
func (*FindPathResponse_SinglePath) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{19, 0}
}
func (m *FindPathResponse_SinglePath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindPathResponse_SinglePath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindPathResponse_SinglePath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindPathResponse_SinglePath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindPathResponse_SinglePath.Merge(m, src)
}
func (m *FindPathResponse_SinglePath) XXX_Size() int {
	return m.Size()
}
func (m *FindPathResponse_SinglePath) XXX_DiscardUnknown() {
	xxx_messageInfo_FindPathResponse_SinglePath.DiscardUnknown(m)
}

var xxx_messageInfo_FindPathResponse_SinglePath proto.InternalMessageInfo

func (m *FindPathResponse_SinglePath) GetEdgeList() []*Edge {
	if m != nil {
		return m.EdgeList
	}
	return nil
}

type Vertex struct {
	Vid  int64      `protobuf:"varint,1,opt,name=vid,proto3" json:"vid,omitempty"`
	Type VertexType `protobuf:"varint,2,opt,name=type,proto3,enum=librarian.mapper.v1.VertexType" json:"type,omitempty"`
	// Types that are valid to be assigned to XProp:
	//	*Vertex_Prop
	XProp                isVertex_XProp `protobuf_oneof:"_prop"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Vertex) Reset()         { *m = Vertex{} }
func (m *Vertex) String() string { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()    {}
func (*Vertex) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{20}
}
func (m *Vertex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vertex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vertex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vertex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vertex.Merge(m, src)
}
func (m *Vertex) XXX_Size() int {
	return m.Size()
}
func (m *Vertex) XXX_DiscardUnknown() {
	xxx_messageInfo_Vertex.DiscardUnknown(m)
}

var xxx_messageInfo_Vertex proto.InternalMessageInfo

type isVertex_XProp interface {
	isVertex_XProp()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Vertex_Prop struct {
	Prop *VertexProp `protobuf:"bytes,3,opt,name=prop,proto3,oneof" json:"prop,omitempty"`
}

func (*Vertex_Prop) isVertex_XProp() {}

func (m *Vertex) GetXProp() isVertex_XProp {
	if m != nil {
		return m.XProp
	}
	return nil
}

func (m *Vertex) GetVid() int64 {
	if m != nil {
		return m.Vid
	}
	return 0
}

func (m *Vertex) GetType() VertexType {
	if m != nil {
		return m.Type
	}
	return VertexType_VERTEX_TYPE_UNSPECIFIED
}

func (m *Vertex) GetProp() *VertexProp {
	if x, ok := m.GetXProp().(*Vertex_Prop); ok {
		return x.Prop
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Vertex) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Vertex_Prop)(nil),
	}
}

type VertexProp struct {
	Common               *VertexCommonProp `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	Additional           map[string]int64  `protobuf:"bytes,2,rep,name=additional,proto3" json:"additional,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VertexProp) Reset()         { *m = VertexProp{} }
func (m *VertexProp) String() string { return proto.CompactTextString(m) }
func (*VertexProp) ProtoMessage()    {}
func (*VertexProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{21}
}
func (m *VertexProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VertexProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VertexProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VertexProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VertexProp.Merge(m, src)
}
func (m *VertexProp) XXX_Size() int {
	return m.Size()
}
func (m *VertexProp) XXX_DiscardUnknown() {
	xxx_messageInfo_VertexProp.DiscardUnknown(m)
}

var xxx_messageInfo_VertexProp proto.InternalMessageInfo

func (m *VertexProp) GetCommon() *VertexCommonProp {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *VertexProp) GetAdditional() map[string]int64 {
	if m != nil {
		return m.Additional
	}
	return nil
}

type VertexCommonProp struct {
	// Types that are valid to be assigned to XOccurTime:
	//	*VertexCommonProp_OccurTime
	XOccurTime isVertexCommonProp_XOccurTime `protobuf_oneof:"_occur_time"`
	// Types that are valid to be assigned to XCreateTime:
	//	*VertexCommonProp_CreateTime
	XCreateTime isVertexCommonProp_XCreateTime `protobuf_oneof:"_create_time"`
	// Types that are valid to be assigned to XUpdateTime:
	//	*VertexCommonProp_UpdateTime
	XUpdateTime          isVertexCommonProp_XUpdateTime `protobuf_oneof:"_update_time"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *VertexCommonProp) Reset()         { *m = VertexCommonProp{} }
func (m *VertexCommonProp) String() string { return proto.CompactTextString(m) }
func (*VertexCommonProp) ProtoMessage()    {}
func (*VertexCommonProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{22}
}
func (m *VertexCommonProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VertexCommonProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VertexCommonProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VertexCommonProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VertexCommonProp.Merge(m, src)
}
func (m *VertexCommonProp) XXX_Size() int {
	return m.Size()
}
func (m *VertexCommonProp) XXX_DiscardUnknown() {
	xxx_messageInfo_VertexCommonProp.DiscardUnknown(m)
}

var xxx_messageInfo_VertexCommonProp proto.InternalMessageInfo

type isVertexCommonProp_XOccurTime interface {
	isVertexCommonProp_XOccurTime()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isVertexCommonProp_XCreateTime interface {
	isVertexCommonProp_XCreateTime()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isVertexCommonProp_XUpdateTime interface {
	isVertexCommonProp_XUpdateTime()
	MarshalTo([]byte) (int, error)
	Size() int
}

type VertexCommonProp_OccurTime struct {
	OccurTime int64 `protobuf:"varint,1,opt,name=occur_time,json=occurTime,proto3,oneof" json:"occur_time,omitempty"`
}
type VertexCommonProp_CreateTime struct {
	CreateTime int64 `protobuf:"varint,2,opt,name=create_time,json=createTime,proto3,oneof" json:"create_time,omitempty"`
}
type VertexCommonProp_UpdateTime struct {
	UpdateTime int64 `protobuf:"varint,3,opt,name=update_time,json=updateTime,proto3,oneof" json:"update_time,omitempty"`
}

func (*VertexCommonProp_OccurTime) isVertexCommonProp_XOccurTime()   {}
func (*VertexCommonProp_CreateTime) isVertexCommonProp_XCreateTime() {}
func (*VertexCommonProp_UpdateTime) isVertexCommonProp_XUpdateTime() {}

func (m *VertexCommonProp) GetXOccurTime() isVertexCommonProp_XOccurTime {
	if m != nil {
		return m.XOccurTime
	}
	return nil
}
func (m *VertexCommonProp) GetXCreateTime() isVertexCommonProp_XCreateTime {
	if m != nil {
		return m.XCreateTime
	}
	return nil
}
func (m *VertexCommonProp) GetXUpdateTime() isVertexCommonProp_XUpdateTime {
	if m != nil {
		return m.XUpdateTime
	}
	return nil
}

func (m *VertexCommonProp) GetOccurTime() int64 {
	if x, ok := m.GetXOccurTime().(*VertexCommonProp_OccurTime); ok {
		return x.OccurTime
	}
	return 0
}

func (m *VertexCommonProp) GetCreateTime() int64 {
	if x, ok := m.GetXCreateTime().(*VertexCommonProp_CreateTime); ok {
		return x.CreateTime
	}
	return 0
}

func (m *VertexCommonProp) GetUpdateTime() int64 {
	if x, ok := m.GetXUpdateTime().(*VertexCommonProp_UpdateTime); ok {
		return x.UpdateTime
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VertexCommonProp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VertexCommonProp_OccurTime)(nil),
		(*VertexCommonProp_CreateTime)(nil),
		(*VertexCommonProp_UpdateTime)(nil),
	}
}

type Edge struct {
	SrcVid int64    `protobuf:"varint,1,opt,name=src_vid,json=srcVid,proto3" json:"src_vid,omitempty"`
	DstVid int64    `protobuf:"varint,2,opt,name=dst_vid,json=dstVid,proto3" json:"dst_vid,omitempty"`
	Type   EdgeType `protobuf:"varint,3,opt,name=type,proto3,enum=librarian.mapper.v1.EdgeType" json:"type,omitempty"`
	// Types that are valid to be assigned to XProp:
	//	*Edge_Prop
	XProp                isEdge_XProp `protobuf_oneof:"_prop"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Edge) Reset()         { *m = Edge{} }
func (m *Edge) String() string { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()    {}
func (*Edge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{23}
}
func (m *Edge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Edge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Edge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Edge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Edge.Merge(m, src)
}
func (m *Edge) XXX_Size() int {
	return m.Size()
}
func (m *Edge) XXX_DiscardUnknown() {
	xxx_messageInfo_Edge.DiscardUnknown(m)
}

var xxx_messageInfo_Edge proto.InternalMessageInfo

type isEdge_XProp interface {
	isEdge_XProp()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Edge_Prop struct {
	Prop *EdgeProp `protobuf:"bytes,4,opt,name=prop,proto3,oneof" json:"prop,omitempty"`
}

func (*Edge_Prop) isEdge_XProp() {}

func (m *Edge) GetXProp() isEdge_XProp {
	if m != nil {
		return m.XProp
	}
	return nil
}

func (m *Edge) GetSrcVid() int64 {
	if m != nil {
		return m.SrcVid
	}
	return 0
}

func (m *Edge) GetDstVid() int64 {
	if m != nil {
		return m.DstVid
	}
	return 0
}

func (m *Edge) GetType() EdgeType {
	if m != nil {
		return m.Type
	}
	return EdgeType_EDGE_TYPE_UNSPECIFIED
}

func (m *Edge) GetProp() *EdgeProp {
	if x, ok := m.GetXProp().(*Edge_Prop); ok {
		return x.Prop
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Edge) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Edge_Prop)(nil),
	}
}

type EdgeProp struct {
	Common               *EdgeCommonProp  `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	Additional           map[string]int64 `protobuf:"bytes,2,rep,name=additional,proto3" json:"additional,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EdgeProp) Reset()         { *m = EdgeProp{} }
func (m *EdgeProp) String() string { return proto.CompactTextString(m) }
func (*EdgeProp) ProtoMessage()    {}
func (*EdgeProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{24}
}
func (m *EdgeProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeProp.Merge(m, src)
}
func (m *EdgeProp) XXX_Size() int {
	return m.Size()
}
func (m *EdgeProp) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeProp.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeProp proto.InternalMessageInfo

func (m *EdgeProp) GetCommon() *EdgeCommonProp {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *EdgeProp) GetAdditional() map[string]int64 {
	if m != nil {
		return m.Additional
	}
	return nil
}

type EdgeCommonProp struct {
	// Types that are valid to be assigned to XOccurTime:
	//	*EdgeCommonProp_OccurTime
	XOccurTime isEdgeCommonProp_XOccurTime `protobuf_oneof:"_occur_time"`
	// Types that are valid to be assigned to XCreateTime:
	//	*EdgeCommonProp_CreateTime
	XCreateTime isEdgeCommonProp_XCreateTime `protobuf_oneof:"_create_time"`
	// Types that are valid to be assigned to XUpdateTime:
	//	*EdgeCommonProp_UpdateTime
	XUpdateTime isEdgeCommonProp_XUpdateTime `protobuf_oneof:"_update_time"`
	// Types that are valid to be assigned to XRank:
	//	*EdgeCommonProp_Rank
	XRank                isEdgeCommonProp_XRank `protobuf_oneof:"_rank"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EdgeCommonProp) Reset()         { *m = EdgeCommonProp{} }
func (m *EdgeCommonProp) String() string { return proto.CompactTextString(m) }
func (*EdgeCommonProp) ProtoMessage()    {}
func (*EdgeCommonProp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca54776e42473b05, []int{25}
}
func (m *EdgeCommonProp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeCommonProp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeCommonProp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeCommonProp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeCommonProp.Merge(m, src)
}
func (m *EdgeCommonProp) XXX_Size() int {
	return m.Size()
}
func (m *EdgeCommonProp) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeCommonProp.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeCommonProp proto.InternalMessageInfo

type isEdgeCommonProp_XOccurTime interface {
	isEdgeCommonProp_XOccurTime()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEdgeCommonProp_XCreateTime interface {
	isEdgeCommonProp_XCreateTime()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEdgeCommonProp_XUpdateTime interface {
	isEdgeCommonProp_XUpdateTime()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEdgeCommonProp_XRank interface {
	isEdgeCommonProp_XRank()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EdgeCommonProp_OccurTime struct {
	OccurTime int64 `protobuf:"varint,1,opt,name=occur_time,json=occurTime,proto3,oneof" json:"occur_time,omitempty"`
}
type EdgeCommonProp_CreateTime struct {
	CreateTime int64 `protobuf:"varint,2,opt,name=create_time,json=createTime,proto3,oneof" json:"create_time,omitempty"`
}
type EdgeCommonProp_UpdateTime struct {
	UpdateTime int64 `protobuf:"varint,3,opt,name=update_time,json=updateTime,proto3,oneof" json:"update_time,omitempty"`
}
type EdgeCommonProp_Rank struct {
	Rank int64 `protobuf:"varint,4,opt,name=rank,proto3,oneof" json:"rank,omitempty"`
}

func (*EdgeCommonProp_OccurTime) isEdgeCommonProp_XOccurTime()   {}
func (*EdgeCommonProp_CreateTime) isEdgeCommonProp_XCreateTime() {}
func (*EdgeCommonProp_UpdateTime) isEdgeCommonProp_XUpdateTime() {}
func (*EdgeCommonProp_Rank) isEdgeCommonProp_XRank()             {}

func (m *EdgeCommonProp) GetXOccurTime() isEdgeCommonProp_XOccurTime {
	if m != nil {
		return m.XOccurTime
	}
	return nil
}
func (m *EdgeCommonProp) GetXCreateTime() isEdgeCommonProp_XCreateTime {
	if m != nil {
		return m.XCreateTime
	}
	return nil
}
func (m *EdgeCommonProp) GetXUpdateTime() isEdgeCommonProp_XUpdateTime {
	if m != nil {
		return m.XUpdateTime
	}
	return nil
}
func (m *EdgeCommonProp) GetXRank() isEdgeCommonProp_XRank {
	if m != nil {
		return m.XRank
	}
	return nil
}

func (m *EdgeCommonProp) GetOccurTime() int64 {
	if x, ok := m.GetXOccurTime().(*EdgeCommonProp_OccurTime); ok {
		return x.OccurTime
	}
	return 0
}

func (m *EdgeCommonProp) GetCreateTime() int64 {
	if x, ok := m.GetXCreateTime().(*EdgeCommonProp_CreateTime); ok {
		return x.CreateTime
	}
	return 0
}

func (m *EdgeCommonProp) GetUpdateTime() int64 {
	if x, ok := m.GetXUpdateTime().(*EdgeCommonProp_UpdateTime); ok {
		return x.UpdateTime
	}
	return 0
}

func (m *EdgeCommonProp) GetRank() int64 {
	if x, ok := m.GetXRank().(*EdgeCommonProp_Rank); ok {
		return x.Rank
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EdgeCommonProp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EdgeCommonProp_OccurTime)(nil),
		(*EdgeCommonProp_CreateTime)(nil),
		(*EdgeCommonProp_UpdateTime)(nil),
		(*EdgeCommonProp_Rank)(nil),
	}
}

func init() {
	proto.RegisterEnum("librarian.mapper.v1.VertexType", VertexType_name, VertexType_value)
	proto.RegisterEnum("librarian.mapper.v1.EdgeType", EdgeType_name, EdgeType_value)
	proto.RegisterEnum("librarian.mapper.v1.EdgeDirection", EdgeDirection_name, EdgeDirection_value)
	proto.RegisterType((*InsertVertexRequest)(nil), "librarian.mapper.v1.InsertVertexRequest")
	proto.RegisterType((*InsertVertexResponse)(nil), "librarian.mapper.v1.InsertVertexResponse")
	proto.RegisterType((*DeleteVertexRequest)(nil), "librarian.mapper.v1.DeleteVertexRequest")
	proto.RegisterType((*DeleteVertexResponse)(nil), "librarian.mapper.v1.DeleteVertexResponse")
	proto.RegisterType((*UpdateVertexRequest)(nil), "librarian.mapper.v1.UpdateVertexRequest")
	proto.RegisterType((*UpdateVertexResponse)(nil), "librarian.mapper.v1.UpdateVertexResponse")
	proto.RegisterType((*InsertEdgeRequest)(nil), "librarian.mapper.v1.InsertEdgeRequest")
	proto.RegisterType((*InsertEdgeResponse)(nil), "librarian.mapper.v1.InsertEdgeResponse")
	proto.RegisterType((*DeleteEdgeRequest)(nil), "librarian.mapper.v1.DeleteEdgeRequest")
	proto.RegisterType((*DeleteEdgeResponse)(nil), "librarian.mapper.v1.DeleteEdgeResponse")
	proto.RegisterType((*UpdateEdgeRequest)(nil), "librarian.mapper.v1.UpdateEdgeRequest")
	proto.RegisterType((*UpdateEdgeResponse)(nil), "librarian.mapper.v1.UpdateEdgeResponse")
	proto.RegisterType((*GoFromVertexRequest)(nil), "librarian.mapper.v1.GoFromVertexRequest")
	proto.RegisterType((*GoFromVertexResponse)(nil), "librarian.mapper.v1.GoFromVertexResponse")
	proto.RegisterType((*FetchEqualVertexRequest)(nil), "librarian.mapper.v1.FetchEqualVertexRequest")
	proto.RegisterType((*FetchEqualVertexResponse)(nil), "librarian.mapper.v1.FetchEqualVertexResponse")
	proto.RegisterType((*FetchEqualVertexNeighborRequest)(nil), "librarian.mapper.v1.FetchEqualVertexNeighborRequest")
	proto.RegisterType((*FetchEqualVertexNeighborResponse)(nil), "librarian.mapper.v1.FetchEqualVertexNeighborResponse")
	proto.RegisterType((*FindPathRequest)(nil), "librarian.mapper.v1.FindPathRequest")
	proto.RegisterType((*FindPathResponse)(nil), "librarian.mapper.v1.FindPathResponse")
	proto.RegisterType((*FindPathResponse_SinglePath)(nil), "librarian.mapper.v1.FindPathResponse.SinglePath")
	proto.RegisterType((*Vertex)(nil), "librarian.mapper.v1.Vertex")
	proto.RegisterType((*VertexProp)(nil), "librarian.mapper.v1.VertexProp")
	proto.RegisterMapType((map[string]int64)(nil), "librarian.mapper.v1.VertexProp.AdditionalEntry")
	proto.RegisterType((*VertexCommonProp)(nil), "librarian.mapper.v1.VertexCommonProp")
	proto.RegisterType((*Edge)(nil), "librarian.mapper.v1.Edge")
	proto.RegisterType((*EdgeProp)(nil), "librarian.mapper.v1.EdgeProp")
	proto.RegisterMapType((map[string]int64)(nil), "librarian.mapper.v1.EdgeProp.AdditionalEntry")
	proto.RegisterType((*EdgeCommonProp)(nil), "librarian.mapper.v1.EdgeCommonProp")
}

func init() { proto.RegisterFile("librarian/mapper/v1/mapper.proto", fileDescriptor_ca54776e42473b05) }

var fileDescriptor_ca54776e42473b05 = []byte{
	// 1400 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xcf, 0x78, 0x9d, 0xc4, 0x79, 0xdc, 0x26, 0xdb, 0x71, 0x1a, 0xbb, 0xae, 0xfe, 0x69, 0xe4,
	0x7f, 0x0b, 0xa1, 0xa2, 0x4e, 0x9d, 0x42, 0x55, 0xa5, 0xf4, 0xe0, 0x97, 0x4d, 0xe2, 0xe2, 0x37,
	0xd6, 0x8e, 0xfb, 0xa2, 0x22, 0x6b, 0xe3, 0x9d, 0x26, 0xab, 0xda, 0x5e, 0x77, 0x3d, 0x36, 0xcd,
	0x27, 0xa0, 0x07, 0x4e, 0x9c, 0xb8, 0x70, 0xe1, 0x00, 0x12, 0xe2, 0xc2, 0xb7, 0x40, 0x20, 0x21,
	0x38, 0xc0, 0x85, 0x0b, 0x0a, 0x37, 0x8e, 0x7c, 0x02, 0xb4, 0x33, 0xeb, 0xec, 0x4b, 0x76, 0xf3,
	0xd2, 0x14, 0x24, 0x6e, 0x3b, 0xcf, 0xfc, 0x9e, 0xdf, 0xef, 0x99, 0x67, 0x9e, 0x19, 0xcf, 0x63,
	0x58, 0xea, 0x68, 0xdb, 0x86, 0x62, 0x68, 0x4a, 0x6f, 0xa5, 0xab, 0xf4, 0xfb, 0xc4, 0x58, 0x19,
	0x65, 0xac, 0xaf, 0x74, 0xdf, 0xd0, 0xa9, 0x8e, 0x63, 0x07, 0x88, 0xb4, 0x65, 0x1f, 0x65, 0x52,
	0x75, 0x88, 0x15, 0x7b, 0x03, 0x62, 0xd0, 0x26, 0x31, 0x28, 0x79, 0x21, 0x93, 0xe7, 0x43, 0x32,
	0xa0, 0xf8, 0x3d, 0x88, 0x8e, 0x98, 0xa1, 0xd5, 0xd1, 0x06, 0x34, 0x81, 0x96, 0x84, 0xe5, 0xe8,
	0xea, 0xe5, 0xb4, 0x0f, 0x43, 0xda, 0x72, 0x04, 0x8e, 0x2f, 0x69, 0x03, 0x9a, 0x5a, 0x80, 0x79,
	0x37, 0xe9, 0xa0, 0xaf, 0xf7, 0x06, 0x24, 0x75, 0x13, 0x62, 0x05, 0xd2, 0x21, 0x94, 0xb8, 0xc5,
	0x2e, 0x41, 0x64, 0xa4, 0xa9, 0xb6, 0x92, 0x20, 0x4f, 0x8f, 0x34, 0x75, 0xcc, 0xe4, 0xf6, 0xb0,
	0x98, 0xea, 0x10, 0xdb, 0xea, 0xab, 0x8a, 0x97, 0xe9, 0xcc, 0x61, 0xbb, 0x49, 0x2d, 0xb1, 0xf7,
	0xe1, 0x02, 0x5f, 0x8e, 0xa4, 0xee, 0x90, 0xb1, 0xd4, 0x6d, 0x98, 0x21, 0xea, 0x0e, 0x71, 0x0a,
	0x5d, 0xf2, 0x15, 0x62, 0x4e, 0x11, 0x13, 0xcb, 0x44, 0xe6, 0x01, 0x3b, 0xc9, 0x6c, 0x09, 0xbe,
	0xce, 0x40, 0x89, 0xd0, 0xa9, 0x24, 0x9c, 0x64, 0xb6, 0x04, 0x5f, 0x5d, 0xa0, 0x84, 0x70, 0x2a,
	0x09, 0x27, 0x99, 0x25, 0xf1, 0x65, 0x08, 0x62, 0x1b, 0xfa, 0xba, 0xa1, 0x77, 0xdd, 0xdb, 0x12,
	0x87, 0xe9, 0x81, 0xd1, 0x6e, 0x8d, 0x34, 0x35, 0x81, 0x96, 0xd0, 0xb2, 0x20, 0x4f, 0x0d, 0x8c,
	0x76, 0x53, 0x53, 0xf1, 0x06, 0x88, 0x4c, 0x9e, 0xee, 0xf5, 0x49, 0xeb, 0xa9, 0xd6, 0xa1, 0xc4,
	0x60, 0x0b, 0x9d, 0x5d, 0xfd, 0x5f, 0x60, 0x14, 0x8d, 0xbd, 0x3e, 0x91, 0x67, 0x89, 0xf5, 0xb5,
	0xce, 0x9c, 0x70, 0x11, 0x98, 0xa5, 0xa5, 0x6a, 0x06, 0x69, 0x53, 0x4d, 0xef, 0x25, 0x84, 0x25,
	0xb4, 0x3c, 0xbb, 0x9a, 0x0a, 0xa4, 0x29, 0x8c, 0x91, 0xf2, 0x79, 0xe2, 0x1c, 0x9a, 0xd5, 0xd8,
	0xd5, 0x7a, 0xad, 0x01, 0x25, 0xfd, 0x44, 0x98, 0x45, 0x3b, 0xdd, 0xd5, 0x7a, 0x75, 0x4a, 0xfa,
	0x6c, 0x4a, 0x79, 0xc1, 0xa7, 0x26, 0xad, 0x29, 0xe5, 0x05, 0x9b, 0x9a, 0x87, 0xc9, 0x8e, 0xd6,
	0xd5, 0x68, 0x62, 0x96, 0xd9, 0xf9, 0x00, 0x2f, 0xc0, 0x94, 0xfe, 0xf4, 0xe9, 0x80, 0xd0, 0xc4,
	0x1c, 0x5f, 0x37, 0x1f, 0xa5, 0x1a, 0x30, 0xef, 0xce, 0x13, 0x4f, 0xe0, 0x19, 0xeb, 0x77, 0x15,
	0xe2, 0xeb, 0x84, 0xb6, 0x77, 0xa5, 0xe7, 0x43, 0xa5, 0x73, 0xb2, 0x1d, 0x48, 0x3d, 0x84, 0xc4,
	0x61, 0x9f, 0xd7, 0x12, 0xcd, 0x8f, 0x08, 0xae, 0x78, 0xa9, 0x2b, 0x44, 0xdb, 0xd9, 0xdd, 0xd6,
	0x8d, 0xff, 0x62, 0x61, 0xa4, 0x1e, 0xc3, 0x52, 0xf0, 0x7a, 0xac, 0x94, 0xbd, 0xea, 0xad, 0xf0,
	0x17, 0x82, 0xb9, 0x75, 0xad, 0xa7, 0xd6, 0x14, 0xba, 0xeb, 0x9b, 0x1c, 0xc1, 0x91, 0x9c, 0x38,
	0x4c, 0xab, 0x03, 0xca, 0x26, 0x42, 0x7c, 0x42, 0x1d, 0xd0, 0xa0, 0xac, 0x09, 0xaf, 0x27, 0x6b,
	0xe1, 0xb3, 0x1c, 0x27, 0xff, 0x33, 0x93, 0xfa, 0x0a, 0x81, 0x68, 0x2f, 0xda, 0xca, 0x60, 0x19,
	0x66, 0xfa, 0x0a, 0xdd, 0x75, 0x66, 0xf0, 0xa6, 0xaf, 0xaa, 0xd7, 0x33, 0x5d, 0xd7, 0x7a, 0x3b,
	0x1d, 0xc2, 0x4c, 0x11, 0x93, 0xc2, 0x4c, 0x6c, 0xb2, 0x00, 0x60, 0xdb, 0x5f, 0xf9, 0xba, 0xfb,
	0x14, 0xc1, 0x14, 0xdf, 0x71, 0x2c, 0x82, 0x60, 0x97, 0xab, 0xf9, 0x89, 0x6f, 0x41, 0xd8, 0x4c,
	0x78, 0x22, 0xc4, 0x52, 0x74, 0xe5, 0x88, 0xf3, 0xc1, 0x72, 0xcd, 0xc0, 0xf8, 0x0e, 0x84, 0xfb,
	0x86, 0xde, 0x67, 0xd5, 0x18, 0x3d, 0xd2, 0xa9, 0x66, 0xe8, 0xfd, 0xcd, 0x09, 0x99, 0xc1, 0x5f,
	0x22, 0x94, 0x9b, 0x86, 0xc9, 0x96, 0xf9, 0x9d, 0xfa, 0x0d, 0x01, 0xd8, 0x10, 0x7c, 0x0f, 0xa6,
	0xda, 0x7a, 0xb7, 0xab, 0xf7, 0x58, 0x6c, 0xd1, 0xd5, 0x6b, 0x47, 0x70, 0xe6, 0x19, 0xd0, 0x74,
	0x93, 0x2d, 0x27, 0x5c, 0x05, 0x50, 0x54, 0x55, 0x33, 0xf7, 0x4c, 0xe9, 0x58, 0xbf, 0x36, 0x2b,
	0xc7, 0x84, 0x95, 0xce, 0x1e, 0x78, 0x48, 0x3d, 0x6a, 0xec, 0xc9, 0x0e, 0x8a, 0xe4, 0x3d, 0x98,
	0xf3, 0x4c, 0x9b, 0xb9, 0x7b, 0x46, 0xf6, 0x58, 0x7c, 0x33, 0xb2, 0xf9, 0x69, 0x5e, 0x9b, 0x23,
	0xa5, 0x33, 0xe4, 0xc9, 0x13, 0x64, 0x3e, 0x58, 0x0b, 0xdd, 0x41, 0xa9, 0x6f, 0x11, 0x88, 0xde,
	0x60, 0x71, 0x0a, 0x40, 0x6f, 0xb7, 0x87, 0x46, 0x8b, 0x6a, 0x5d, 0xc2, 0xf7, 0x60, 0x73, 0x42,
	0x9e, 0x61, 0xb6, 0x86, 0xd6, 0x25, 0x2f, 0x11, 0xc2, 0x57, 0x21, 0xda, 0x36, 0x88, 0x42, 0x09,
	0x07, 0x31, 0xe2, 0x4d, 0x24, 0x03, 0x37, 0x3a, 0x50, 0x43, 0xf6, 0x03, 0xc6, 0x51, 0x02, 0x43,
	0x85, 0x64, 0xe0, 0x46, 0x0b, 0x95, 0x3b, 0x0f, 0xd1, 0x96, 0x2d, 0x98, 0x9b, 0x85, 0x73, 0x2d,
	0x07, 0x37, 0x1b, 0x3b, 0x58, 0x52, 0xdf, 0x20, 0x08, 0x9b, 0x95, 0x13, 0x7c, 0xaf, 0xb9, 0x8e,
	0x2e, 0x72, 0x1c, 0xdd, 0x8c, 0x55, 0x44, 0xfc, 0x76, 0x3a, 0xe6, 0xb8, 0xf2, 0x12, 0xba, 0x6d,
	0x95, 0x50, 0x98, 0x6d, 0x77, 0xb0, 0x4b, 0x60, 0x01, 0xfd, 0x82, 0x20, 0x32, 0x06, 0xe0, 0xbb,
	0x9e, 0xf2, 0xf9, 0x7f, 0x20, 0x9f, 0x4f, 0xf1, 0x94, 0x7d, 0x8a, 0xe7, 0xc6, 0x91, 0x01, 0xfd,
	0x93, 0xa5, 0xf3, 0x33, 0x82, 0x59, 0x77, 0xa0, 0xff, 0x76, 0xe1, 0xe0, 0x38, 0x84, 0x0d, 0xa5,
	0xf7, 0x8c, 0x3f, 0x20, 0x36, 0x05, 0x99, 0x8d, 0x4e, 0x5f, 0x51, 0x6c, 0xaf, 0x4c, 0xd7, 0xeb,
	0x9f, 0x1c, 0x1c, 0x76, 0xb3, 0x02, 0xf0, 0x65, 0x88, 0x37, 0x25, 0xb9, 0x21, 0x3d, 0x6c, 0x35,
	0x1e, 0xd5, 0xa4, 0xd6, 0x56, 0xa5, 0x5e, 0x93, 0xf2, 0xc5, 0xf5, 0xa2, 0x54, 0x10, 0x27, 0x70,
	0x02, 0xe6, 0x9d, 0x93, 0xd9, 0x5c, 0xbd, 0x21, 0x67, 0xf3, 0x0d, 0x11, 0xe1, 0x05, 0xc0, 0xce,
	0x19, 0xa9, 0xd2, 0x28, 0x36, 0x1e, 0x89, 0x21, 0x1c, 0x87, 0x98, 0xd3, 0x5e, 0x96, 0xea, 0xf5,
	0xec, 0x86, 0x24, 0x0a, 0x5e, 0x87, 0x6a, 0xee, 0xbe, 0x94, 0x6f, 0x88, 0xe1, 0xeb, 0xbf, 0x5a,
	0xa5, 0xc3, 0x82, 0xb9, 0x04, 0x17, 0xa5, 0xc2, 0x86, 0xe4, 0x17, 0xca, 0x45, 0xb8, 0x60, 0x4f,
	0x6d, 0x48, 0x15, 0x49, 0xce, 0x96, 0x44, 0x84, 0x63, 0x30, 0x67, 0x9b, 0xa5, 0x0f, 0xb6, 0xb2,
	0x25, 0x31, 0x84, 0xe7, 0x41, 0xb4, 0x8d, 0x79, 0x59, 0xca, 0x36, 0xcc, 0x08, 0xdc, 0xd0, 0xca,
	0xfd, 0xea, 0x23, 0x31, 0xec, 0xa6, 0x2d, 0x9b, 0xcb, 0xa8, 0x56, 0xc4, 0x49, 0x37, 0x43, 0x41,
	0x92, 0x8b, 0x4d, 0x49, 0x9c, 0x72, 0x83, 0xf3, 0xd5, 0x4a, 0x43, 0xae, 0x96, 0xc4, 0x69, 0x37,
	0x78, 0xbd, 0x5a, 0x2a, 0x55, 0x1f, 0x88, 0x91, 0xeb, 0x1f, 0xc1, 0x79, 0xd7, 0xcf, 0x19, 0x5e,
	0x84, 0x24, 0x83, 0x15, 0x8a, 0xb2, 0x94, 0x37, 0x75, 0x3c, 0x2b, 0x5c, 0x00, 0xec, 0x99, 0xaf,
	0x6e, 0x99, 0xa9, 0x1e, 0xab, 0xda, 0xf6, 0x62, 0x85, 0x67, 0xda, 0x63, 0xce, 0x55, 0x1b, 0x9b,
	0xa2, 0xb0, 0xfa, 0x79, 0x04, 0x16, 0x4a, 0xe3, 0x03, 0x53, 0x66, 0xe7, 0xa5, 0x4e, 0x8c, 0x91,
	0xd6, 0x26, 0xb8, 0x0d, 0xe7, 0x9c, 0xed, 0x14, 0x5e, 0xf6, 0x3d, 0x59, 0x3e, 0x6d, 0x5c, 0xf2,
	0xad, 0x13, 0x20, 0xad, 0xdf, 0xdd, 0x36, 0x9c, 0x73, 0x76, 0x5a, 0x01, 0x22, 0x3e, 0xed, 0x5b,
	0x80, 0x88, 0x5f, 0xdb, 0x66, 0x8a, 0x38, 0x3b, 0xac, 0x00, 0x11, 0x9f, 0xce, 0x2e, 0x40, 0xc4,
	0xaf, 0x5d, 0xc3, 0x1f, 0x02, 0xd8, 0x1d, 0x16, 0x7e, 0xe3, 0x88, 0x14, 0x38, 0x3a, 0xa1, 0xe4,
	0x9b, 0xc7, 0xe2, 0x6c, 0x7a, 0xbb, 0xbb, 0x0a, 0xa0, 0x3f, 0xd4, 0xcb, 0x05, 0xd0, 0x1f, 0x6e,
	0xd3, 0x4c, 0x7a, 0xbb, 0xb3, 0x0a, 0xa0, 0x3f, 0xd4, 0xc7, 0x05, 0xd0, 0x1f, 0x6e, 0xd1, 0xcc,
	0x1d, 0x70, 0x76, 0x1e, 0x01, 0x3b, 0xe0, 0xd3, 0xc4, 0x05, 0xec, 0x80, 0x6f, 0x1b, 0xa3, 0x83,
	0xe8, 0x7d, 0x29, 0xe3, 0xb7, 0xfd, 0x1f, 0x71, 0xfe, 0xfd, 0x4a, 0xf2, 0xc6, 0x09, 0xd1, 0x96,
	0xe0, 0xc7, 0xe8, 0x70, 0x1b, 0x33, 0x7e, 0x9b, 0xe3, 0x77, 0x4e, 0xc4, 0xe5, 0x69, 0x4d, 0x92,
	0xef, 0x9e, 0xd2, 0xcb, 0x8a, 0xe4, 0x01, 0x44, 0xc6, 0x0f, 0x53, 0x7c, 0xf5, 0x98, 0x77, 0x2b,
	0x17, 0xba, 0x76, 0xa2, 0xd7, 0x6d, 0xee, 0x07, 0xf4, 0xdd, 0xfe, 0x22, 0xfa, 0x69, 0x7f, 0x11,
	0xfd, 0xbe, 0xbf, 0x88, 0x3e, 0xfb, 0x63, 0x71, 0x02, 0xe2, 0x6d, 0xbd, 0xeb, 0xe7, 0x9c, 0x8b,
	0xf2, 0xfb, 0xa3, 0x66, 0xe8, 0x54, 0xaf, 0xa1, 0xc7, 0xd7, 0x76, 0x34, 0xba, 0x3b, 0xdc, 0x4e,
	0xb7, 0xf5, 0xee, 0x0a, 0x1d, 0x6a, 0xbb, 0xc3, 0xed, 0x15, 0xef, 0x9f, 0x45, 0x77, 0x47, 0x99,
	0x2f, 0x42, 0x42, 0xa9, 0xfc, 0xf0, 0xeb, 0x50, 0xec, 0xe0, 0x16, 0x4a, 0x73, 0x9a, 0x74, 0x33,
	0xf3, 0xbd, 0xc3, 0xfa, 0x84, 0x5b, 0x9f, 0x34, 0x33, 0xfb, 0xa1, 0x2b, 0x3e, 0xd6, 0x27, 0x1b,
	0xb5, 0x5c, 0x99, 0x50, 0x45, 0x55, 0xa8, 0xf2, 0x67, 0xe8, 0xe2, 0x01, 0x62, 0x6d, 0x8d, 0x43,
	0xd6, 0xd6, 0x9a, 0x99, 0xed, 0x29, 0xf6, 0x97, 0xd4, 0xad, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff,
	0xd0, 0xd5, 0x2f, 0xac, 0xb6, 0x12, 0x00, 0x00,
}

func (m *InsertVertexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertVertexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertVertexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VertexList) > 0 {
		for iNdEx := len(m.VertexList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VertexList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InsertVertexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertVertexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertVertexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteVertexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVertexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteVertexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VidList) > 0 {
		dAtA2 := make([]byte, len(m.VidList)*10)
		var j1 int
		for _, num1 := range m.VidList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMapper(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteVertexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVertexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteVertexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateVertexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVertexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateVertexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VertexList) > 0 {
		for iNdEx := len(m.VertexList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VertexList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateVertexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVertexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateVertexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InsertEdgeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertEdgeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertEdgeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeList) > 0 {
		for iNdEx := len(m.EdgeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InsertEdgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertEdgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertEdgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteEdgeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteEdgeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteEdgeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeList) > 0 {
		for iNdEx := len(m.EdgeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteEdgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteEdgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteEdgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEdgeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEdgeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEdgeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeList) > 0 {
		for iNdEx := len(m.EdgeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEdgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEdgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEdgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GoFromVertexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoFromVertexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoFromVertexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x78
	}
	if m.Limit != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxStep != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.MaxStep))
		i--
		dAtA[i] = 0x28
	}
	if m.MinStep != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.MinStep))
		i--
		dAtA[i] = 0x20
	}
	if m.EdgeDirection != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.EdgeDirection))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EdgeTypeFilter) > 0 {
		dAtA4 := make([]byte, len(m.EdgeTypeFilter)*10)
		var j3 int
		for _, num := range m.EdgeTypeFilter {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMapper(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.SrcVid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.SrcVid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoFromVertexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoFromVertexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoFromVertexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VertexList) > 0 {
		for iNdEx := len(m.VertexList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VertexList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchEqualVertexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEqualVertexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEqualVertexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcVid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.SrcVid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchEqualVertexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEqualVertexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEqualVertexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VertexList) > 0 {
		for iNdEx := len(m.VertexList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VertexList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchEqualVertexNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEqualVertexNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEqualVertexNeighborRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EdgeDirection != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.EdgeDirection))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EdgeTypeFilter) > 0 {
		dAtA6 := make([]byte, len(m.EdgeTypeFilter)*10)
		var j5 int
		for _, num := range m.EdgeTypeFilter {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintMapper(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if m.SrcVid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.SrcVid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchEqualVertexNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchEqualVertexNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchEqualVertexNeighborResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeList) > 0 {
		for iNdEx := len(m.EdgeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FindPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindPathRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindPathRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxStep != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.MaxStep))
		i--
		dAtA[i] = 0x28
	}
	if m.EdgeDirection != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.EdgeDirection))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EdgeTypeFilter) > 0 {
		dAtA8 := make([]byte, len(m.EdgeTypeFilter)*10)
		var j7 int
		for _, num := range m.EdgeTypeFilter {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintMapper(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DstVid) > 0 {
		dAtA10 := make([]byte, len(m.DstVid)*10)
		var j9 int
		for _, num1 := range m.DstVid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintMapper(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcVid) > 0 {
		dAtA12 := make([]byte, len(m.SrcVid)*10)
		var j11 int
		for _, num1 := range m.SrcVid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMapper(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindPathResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindPathResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindPathResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PathList) > 0 {
		for iNdEx := len(m.PathList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FindPathResponse_SinglePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindPathResponse_SinglePath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindPathResponse_SinglePath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeList) > 0 {
		for iNdEx := len(m.EdgeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vertex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XProp != nil {
		{
			size := m.XProp.Size()
			i -= size
			if _, err := m.XProp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Vid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.Vid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vertex_Prop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vertex_Prop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prop != nil {
		{
			size, err := m.Prop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VertexProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VertexProp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VertexProp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Additional) > 0 {
		for k := range m.Additional {
			v := m.Additional[k]
			baseI := i
			i = encodeVarintMapper(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMapper(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMapper(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Common != nil {
		{
			size, err := m.Common.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VertexCommonProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VertexCommonProp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VertexCommonProp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XUpdateTime != nil {
		{
			size := m.XUpdateTime.Size()
			i -= size
			if _, err := m.XUpdateTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XCreateTime != nil {
		{
			size := m.XCreateTime.Size()
			i -= size
			if _, err := m.XCreateTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XOccurTime != nil {
		{
			size := m.XOccurTime.Size()
			i -= size
			if _, err := m.XOccurTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VertexCommonProp_OccurTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VertexCommonProp_OccurTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.OccurTime))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *VertexCommonProp_CreateTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VertexCommonProp_CreateTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.CreateTime))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *VertexCommonProp_UpdateTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VertexCommonProp_UpdateTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.UpdateTime))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Edge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Edge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XProp != nil {
		{
			size := m.XProp.Size()
			i -= size
			if _, err := m.XProp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.DstVid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.DstVid))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcVid != 0 {
		i = encodeVarintMapper(dAtA, i, uint64(m.SrcVid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Edge_Prop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Edge_Prop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prop != nil {
		{
			size, err := m.Prop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *EdgeProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeProp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeProp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Additional) > 0 {
		for k := range m.Additional {
			v := m.Additional[k]
			baseI := i
			i = encodeVarintMapper(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMapper(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMapper(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Common != nil {
		{
			size, err := m.Common.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCommonProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeCommonProp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCommonProp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.XRank != nil {
		{
			size := m.XRank.Size()
			i -= size
			if _, err := m.XRank.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XUpdateTime != nil {
		{
			size := m.XUpdateTime.Size()
			i -= size
			if _, err := m.XUpdateTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XCreateTime != nil {
		{
			size := m.XCreateTime.Size()
			i -= size
			if _, err := m.XCreateTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XOccurTime != nil {
		{
			size := m.XOccurTime.Size()
			i -= size
			if _, err := m.XOccurTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCommonProp_OccurTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCommonProp_OccurTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.OccurTime))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *EdgeCommonProp_CreateTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCommonProp_CreateTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.CreateTime))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *EdgeCommonProp_UpdateTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCommonProp_UpdateTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.UpdateTime))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *EdgeCommonProp_Rank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCommonProp_Rank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintMapper(dAtA, i, uint64(m.Rank))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func encodeVarintMapper(dAtA []byte, offset int, v uint64) int {
	offset -= sovMapper(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InsertVertexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VertexList) > 0 {
		for _, e := range m.VertexList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertVertexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteVertexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VidList) > 0 {
		l = 0
		for _, e := range m.VidList {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteVertexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVertexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VertexList) > 0 {
		for _, e := range m.VertexList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVertexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertEdgeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EdgeList) > 0 {
		for _, e := range m.EdgeList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertEdgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteEdgeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EdgeList) > 0 {
		for _, e := range m.EdgeList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteEdgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateEdgeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EdgeList) > 0 {
		for _, e := range m.EdgeList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateEdgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GoFromVertexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcVid != 0 {
		n += 1 + sovMapper(uint64(m.SrcVid))
	}
	if len(m.EdgeTypeFilter) > 0 {
		l = 0
		for _, e := range m.EdgeTypeFilter {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if m.EdgeDirection != 0 {
		n += 1 + sovMapper(uint64(m.EdgeDirection))
	}
	if m.MinStep != 0 {
		n += 1 + sovMapper(uint64(m.MinStep))
	}
	if m.MaxStep != 0 {
		n += 1 + sovMapper(uint64(m.MaxStep))
	}
	if m.Limit != 0 {
		n += 1 + sovMapper(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovMapper(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GoFromVertexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VertexList) > 0 {
		for _, e := range m.VertexList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchEqualVertexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcVid != 0 {
		n += 1 + sovMapper(uint64(m.SrcVid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchEqualVertexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VertexList) > 0 {
		for _, e := range m.VertexList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchEqualVertexNeighborRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcVid != 0 {
		n += 1 + sovMapper(uint64(m.SrcVid))
	}
	if len(m.EdgeTypeFilter) > 0 {
		l = 0
		for _, e := range m.EdgeTypeFilter {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if m.EdgeDirection != 0 {
		n += 1 + sovMapper(uint64(m.EdgeDirection))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchEqualVertexNeighborResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EdgeList) > 0 {
		for _, e := range m.EdgeList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindPathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SrcVid) > 0 {
		l = 0
		for _, e := range m.SrcVid {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if len(m.DstVid) > 0 {
		l = 0
		for _, e := range m.DstVid {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if len(m.EdgeTypeFilter) > 0 {
		l = 0
		for _, e := range m.EdgeTypeFilter {
			l += sovMapper(uint64(e))
		}
		n += 1 + sovMapper(uint64(l)) + l
	}
	if m.EdgeDirection != 0 {
		n += 1 + sovMapper(uint64(m.EdgeDirection))
	}
	if m.MaxStep != 0 {
		n += 1 + sovMapper(uint64(m.MaxStep))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindPathResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PathList) > 0 {
		for _, e := range m.PathList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindPathResponse_SinglePath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EdgeList) > 0 {
		for _, e := range m.EdgeList {
			l = e.Size()
			n += 1 + l + sovMapper(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vertex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vid != 0 {
		n += 1 + sovMapper(uint64(m.Vid))
	}
	if m.Type != 0 {
		n += 1 + sovMapper(uint64(m.Type))
	}
	if m.XProp != nil {
		n += m.XProp.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vertex_Prop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovMapper(uint64(l))
	}
	return n
}
func (m *VertexProp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovMapper(uint64(l))
	}
	if len(m.Additional) > 0 {
		for k, v := range m.Additional {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMapper(uint64(len(k))) + 1 + sovMapper(uint64(v))
			n += mapEntrySize + 1 + sovMapper(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VertexCommonProp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XOccurTime != nil {
		n += m.XOccurTime.Size()
	}
	if m.XCreateTime != nil {
		n += m.XCreateTime.Size()
	}
	if m.XUpdateTime != nil {
		n += m.XUpdateTime.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VertexCommonProp_OccurTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.OccurTime))
	return n
}
func (m *VertexCommonProp_CreateTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.CreateTime))
	return n
}
func (m *VertexCommonProp_UpdateTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.UpdateTime))
	return n
}
func (m *Edge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcVid != 0 {
		n += 1 + sovMapper(uint64(m.SrcVid))
	}
	if m.DstVid != 0 {
		n += 1 + sovMapper(uint64(m.DstVid))
	}
	if m.Type != 0 {
		n += 1 + sovMapper(uint64(m.Type))
	}
	if m.XProp != nil {
		n += m.XProp.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Edge_Prop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovMapper(uint64(l))
	}
	return n
}
func (m *EdgeProp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovMapper(uint64(l))
	}
	if len(m.Additional) > 0 {
		for k, v := range m.Additional {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMapper(uint64(len(k))) + 1 + sovMapper(uint64(v))
			n += mapEntrySize + 1 + sovMapper(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EdgeCommonProp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XOccurTime != nil {
		n += m.XOccurTime.Size()
	}
	if m.XCreateTime != nil {
		n += m.XCreateTime.Size()
	}
	if m.XUpdateTime != nil {
		n += m.XUpdateTime.Size()
	}
	if m.XRank != nil {
		n += m.XRank.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EdgeCommonProp_OccurTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.OccurTime))
	return n
}
func (m *EdgeCommonProp_CreateTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.CreateTime))
	return n
}
func (m *EdgeCommonProp_UpdateTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.UpdateTime))
	return n
}
func (m *EdgeCommonProp_Rank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMapper(uint64(m.Rank))
	return n
}

func sovMapper(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMapper(x uint64) (n int) {
	return sovMapper(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InsertVertexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertVertexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertVertexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VertexList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VertexList = append(m.VertexList, &Vertex{})
			if err := m.VertexList[len(m.VertexList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertVertexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertVertexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertVertexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVertexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVertexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVertexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VidList = append(m.VidList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VidList) == 0 {
					m.VidList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VidList = append(m.VidList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VidList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVertexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVertexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVertexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVertexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVertexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVertexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VertexList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VertexList = append(m.VertexList, &Vertex{})
			if err := m.VertexList[len(m.VertexList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVertexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVertexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVertexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertEdgeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertEdgeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertEdgeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeList = append(m.EdgeList, &Edge{})
			if err := m.EdgeList[len(m.EdgeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertEdgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertEdgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertEdgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteEdgeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteEdgeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteEdgeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeList = append(m.EdgeList, &Edge{})
			if err := m.EdgeList[len(m.EdgeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteEdgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteEdgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteEdgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEdgeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEdgeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEdgeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeList = append(m.EdgeList, &Edge{})
			if err := m.EdgeList[len(m.EdgeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEdgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEdgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEdgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoFromVertexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoFromVertexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoFromVertexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVid", wireType)
			}
			m.SrcVid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcVid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v EdgeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= EdgeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EdgeTypeFilter) == 0 {
					m.EdgeTypeFilter = make([]EdgeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v EdgeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= EdgeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeTypeFilter", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeDirection", wireType)
			}
			m.EdgeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeDirection |= EdgeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStep", wireType)
			}
			m.MinStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinStep |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStep", wireType)
			}
			m.MaxStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStep |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoFromVertexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoFromVertexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoFromVertexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VertexList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VertexList = append(m.VertexList, &Vertex{})
			if err := m.VertexList[len(m.VertexList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEqualVertexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEqualVertexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEqualVertexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVid", wireType)
			}
			m.SrcVid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcVid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEqualVertexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEqualVertexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEqualVertexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VertexList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VertexList = append(m.VertexList, &Vertex{})
			if err := m.VertexList[len(m.VertexList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEqualVertexNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEqualVertexNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEqualVertexNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVid", wireType)
			}
			m.SrcVid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcVid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v EdgeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= EdgeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EdgeTypeFilter) == 0 {
					m.EdgeTypeFilter = make([]EdgeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v EdgeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= EdgeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeTypeFilter", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeDirection", wireType)
			}
			m.EdgeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeDirection |= EdgeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchEqualVertexNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchEqualVertexNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchEqualVertexNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeList = append(m.EdgeList, &Edge{})
			if err := m.EdgeList[len(m.EdgeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcVid = append(m.SrcVid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SrcVid) == 0 {
					m.SrcVid = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcVid = append(m.SrcVid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVid", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstVid = append(m.DstVid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DstVid) == 0 {
					m.DstVid = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstVid = append(m.DstVid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstVid", wireType)
			}
		case 3:
			if wireType == 0 {
				var v EdgeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= EdgeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EdgeTypeFilter) == 0 {
					m.EdgeTypeFilter = make([]EdgeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v EdgeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= EdgeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EdgeTypeFilter = append(m.EdgeTypeFilter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeTypeFilter", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeDirection", wireType)
			}
			m.EdgeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeDirection |= EdgeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStep", wireType)
			}
			m.MaxStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStep |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindPathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindPathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindPathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathList = append(m.PathList, &FindPathResponse_SinglePath{})
			if err := m.PathList[len(m.PathList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindPathResponse_SinglePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SinglePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SinglePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeList = append(m.EdgeList, &Edge{})
			if err := m.EdgeList[len(m.EdgeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vid", wireType)
			}
			m.Vid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VertexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VertexProp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XProp = &Vertex_Prop{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VertexProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VertexProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VertexProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &VertexCommonProp{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Additional == nil {
				m.Additional = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMapper
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMapper
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMapper(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMapper
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Additional[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VertexCommonProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VertexCommonProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VertexCommonProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OccurTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XOccurTime = &VertexCommonProp_OccurTime{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XCreateTime = &VertexCommonProp_CreateTime{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XUpdateTime = &VertexCommonProp_UpdateTime{v}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVid", wireType)
			}
			m.SrcVid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcVid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstVid", wireType)
			}
			m.DstVid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstVid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EdgeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EdgeProp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XProp = &Edge_Prop{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &EdgeCommonProp{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Additional == nil {
				m.Additional = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMapper
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMapper
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMapper(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMapper
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Additional[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeCommonProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeCommonProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeCommonProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OccurTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XOccurTime = &EdgeCommonProp_OccurTime{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XCreateTime = &EdgeCommonProp_CreateTime{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XUpdateTime = &EdgeCommonProp_UpdateTime{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XRank = &EdgeCommonProp_Rank{v}
		default:
			iNdEx = preIndex
			skippy, err := skipMapper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMapper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMapper(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMapper
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMapper
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMapper
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMapper
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMapper        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMapper          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMapper = fmt.Errorf("proto: unexpected end of group")
)
